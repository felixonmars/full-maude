             \||||||||||||||||||/
           --- Welcome to Maude ---
             /||||||||||||||||||\
        Maude 2.6.1 built: Jan  9 2012 14:33:20
        Copyright 1997-2011 SRI International
           Tue Apr 10 18:17:10 2012

Maude> 
        Full Maude 2.6.1 March 20th 2012


Maude> Introduced view Oid

Introduced view Cid

Introduced view Tuple

Introduced module SET-KIND

Introduced module MAYBE

Introduced module PFUN

Introduced module EXTENDED-RENT-A-CAR-STORE

Introduced module EXTENDED-RENT-A-CAR-STORE-TEST

Introduced view Substitution

Advisory: View Tuple redefined.
Introduced view Tuple

Introduced module REW-SEQ

Introduced module REW-SEQ-TEST

result Configuration :
  < 'A1 : EconomyCar | available : true > < 'A3 : MidSizeCar | available : true
    > < 'A5 : FullSizeCar | available : true > < 'C : Calendar | date : 8 > <
    'C1 : Staff | cash : 4500,debt : 60 > < 'C2 : OccasionalCust | cash : 5000,
    debt : 0 > < 'S : Store | calendar : 'C,cars :('A1, 'A3, 'A5),customers :(
    'C1, 'C2),discounts :(((OccasionalCust,EconomyCar),0),((OccasionalCust,
    FullSizeCar),0),((OccasionalCust,MidSizeCar),0),((PreferredCust,
    EconomyCar),10),((PreferredCust,FullSizeCar),20),((PreferredCust,
    MidSizeCar),15),((Staff,EconomyCar),20),((Staff,FullSizeCar),40),((Staff,
    MidSizeCar),30)),payments :('C1,500),penalty : 0,rates :((EconomyCar,100),(
    FullSizeCar,200),(MidSizeCar,150)),rentals : empty,suspended : 'C1,
    threshold : 1000 >

Introduced module RENT-A-CAR-STORE

Introduced module RENT-A-CAR-STORE-TEST

Advisory: View Substitution redefined.
Introduced view Substitution

Advisory: View Tuple redefined.
Introduced view Tuple

Advisory: Module REW-SEQ redefined.
Introduced module REW-SEQ

Advisory: Module REW-SEQ-TEST redefined.
Introduced module REW-SEQ-TEST

result Configuration :
  < 'A1 : EconomyCar | available : true,rate : 100 > < 'A3 : MidSizeCar |
    available : true,rate : 150 > < 'A5 : FullSizeCar | available : true,rate :
    200 > < 'C : Calendar | date : 8 > < 'C1 : Customer | cash : 4400,debt :
    140,suspended : true > < 'C2 : Customer | cash : 5000,debt : 0,suspended :
    false >


        Full Maude 2.6.1 March 20th 2012

Introduced theory NZNAT#

Introduced module NAT/

Introduced module RROBIN

Introduced module CHECK-RROBIN

Introduced view 5

reduce in CHECK-RROBIN{5}:
  modelCheck(init,[]~ twoInCrit)
result Bool :
  true

reduce in CHECK-RROBIN{5}:
  modelCheck(init,[]guaranteedReentrance)
result Bool :
  true

reduce in CHECK-RROBIN{5}:
  modelCheck(init,[](inCrit([1])-> O O O inCrit([1])))
result ModelCheckResult :
  counterexample({go([0])<[0]: Proc | mode : wait > <[1]: Proc | mode : wait >
    <[2]: Proc | mode : wait > <[3]: Proc | mode : wait > <[4]: Proc | mode :
    wait >,'enter}{<[0]: Proc | mode : critical > <[1]: Proc | mode : wait > <[
    2]: Proc | mode : wait > <[3]: Proc | mode : wait > <[4]: Proc | mode :
    wait >,'exit}{go([1])<[0]: Proc | mode : wait > <[1]: Proc | mode : wait >
    <[2]: Proc | mode : wait > <[3]: Proc | mode : wait > <[4]: Proc | mode :
    wait >,'enter}{<[0]: Proc | mode : wait > <[1]: Proc | mode : critical > <[
    2]: Proc | mode : wait > <[3]: Proc | mode : wait > <[4]: Proc | mode :
    wait >,'exit}{go([2])<[0]: Proc | mode : wait > <[1]: Proc | mode : wait >
    <[2]: Proc | mode : wait > <[3]: Proc | mode : wait > <[4]: Proc | mode :
    wait >,'enter}{<[0]: Proc | mode : wait > <[1]: Proc | mode : wait > <[2]:
    Proc | mode : critical > <[3]: Proc | mode : wait > <[4]: Proc | mode :
    wait >,'exit},{go([3])<[0]: Proc | mode : wait > <[1]: Proc | mode : wait >
    <[2]: Proc | mode : wait > <[3]: Proc | mode : wait > <[4]: Proc | mode :
    wait >,'enter}{<[0]: Proc | mode : wait > <[1]: Proc | mode : wait > <[2]:
    Proc | mode : wait > <[3]: Proc | mode : critical > <[4]: Proc | mode :
    wait >,'exit}{go([4])<[0]: Proc | mode : wait > <[1]: Proc | mode : wait >
    <[2]: Proc | mode : wait > <[3]: Proc | mode : wait > <[4]: Proc | mode :
    wait >,'enter}{<[0]: Proc | mode : wait > <[1]: Proc | mode : wait > <[2]:
    Proc | mode : wait > <[3]: Proc | mode : wait > <[4]: Proc | mode :
    critical >,'exit}{go([0])<[0]: Proc | mode : wait > <[1]: Proc | mode :
    wait > <[2]: Proc | mode : wait > <[3]: Proc | mode : wait > <[4]: Proc |
    mode : wait >,'enter}{<[0]: Proc | mode : critical > <[1]: Proc | mode :
    wait > <[2]: Proc | mode : wait > <[3]: Proc | mode : wait > <[4]: Proc |
    mode : wait >,'exit}{go([1])<[0]: Proc | mode : wait > <[1]: Proc | mode :
    wait > <[2]: Proc | mode : wait > <[3]: Proc | mode : wait > <[4]: Proc |
    mode : wait >,'enter}{<[0]: Proc | mode : wait > <[1]: Proc | mode :
    critical > <[2]: Proc | mode : wait > <[3]: Proc | mode : wait > <[4]: Proc
    | mode : wait >,'exit}{go([2])<[0]: Proc | mode : wait > <[1]: Proc | mode
    : wait > <[2]: Proc | mode : wait > <[3]: Proc | mode : wait > <[4]: Proc |
    mode : wait >,'enter}{<[0]: Proc | mode : wait > <[1]: Proc | mode : wait >
    <[2]: Proc | mode : critical > <[3]: Proc | mode : wait > <[4]: Proc | mode
    : wait >,'exit})

Introduced module ACCOUNT

rewrite in ACCOUNT :
  < 'A-06238 : Account | bal : 2000 > debit('A-06238,1000)
result Object :
  < 'A-06238 : Account | bal : 1000 >

Introduced module SAVING-ACCOUNT

rewrite in SAVING-ACCOUNT :
  < 'A-73728 : SavingAccount | bal : 5000,rate : 3.0 > < 'A-06238 : Account |
    bal : 2000 > < 'A-28381 : SavingAccount | bal : 9000,rate : 3.0 > debit(
    'A-06238,1000)credit('A-73728,1300)credit('A-28381,200)
result Configuration :
  < 'A-06238 : Account | bal : 1000 > < 'A-28381 : SavingAccount | bal : 9200,
    rate : 3.0 > < 'A-73728 : SavingAccount | bal : 6300,rate : 3.0 >

search in SAVING-ACCOUNT : < 'A-73728 : SavingAccount | bal : 5000,rate : 3.0 >
    < 'A-06238 : Account | bal : 2000 > < 'A-28381 : SavingAccount | bal :
    9000,rate : 3.0 > debit('A-06238,1000)credit('A-73728,1300)credit('A-28381,
    200) =>! C:Configuration < O:Oid : V#0:Account | bal : N:Nat,
    V#1:AttributeSet > .

Solution 1
C:Configuration --> < 'A-28381 : SavingAccount | bal : 9200,rate : 3.0 > <
    'A-73728 : SavingAccount | bal : 6300,rate : 3.0 > ; N:Nat --> 1000 ; O:Oid
    --> 'A-06238 ; V#0:Account --> Account ; V#1:AttributeSet --> (
    none).AttributeSet

Solution 2
C:Configuration --> < 'A-06238 : Account | bal : 1000 > < 'A-28381 :
    SavingAccount | bal : 9200,rate : 3.0 > ; N:Nat --> 6300 ; O:Oid -->
    'A-73728 ; V#0:Account --> SavingAccount ; V#1:AttributeSet --> rate : 3.0

No more solutions.

Introduced view Set

Introduced module GENERIC-SET-LIST

Introduced module NAT-PLUS

reduce in META-LEVEL :
  fmod 'NAT-PLUS is
  nil
  sorts 'Bool ; 'Nat .
  none
  op '0 : nil -> 'Nat [none] .
  op '_+_ : 'Nat 'Nat -> 'Nat [assoc comm id('0.Nat)] .
  op '_=/=_ : 'Universal 'Universal -> 'Bool [prec(51)poly(1 2)special(
    id-hook('EqualitySymbol,nil)
    term-hook('equalTerm,'false.Bool)
    term-hook('notEqualTerm,'true.Bool))] .
  op '_==_ : 'Universal 'Universal -> 'Bool [prec(51)poly(1 2)special(
    id-hook('EqualitySymbol,nil)
    term-hook('equalTerm,'true.Bool)
    term-hook('notEqualTerm,'false.Bool))] .
  op '_and_ : 'Bool 'Bool -> 'Bool [assoc comm prec(55)] .
  op '_implies_ : 'Bool 'Bool -> 'Bool [prec(61)gather('e 'E)] .
  op '_or_ : 'Bool 'Bool -> 'Bool [assoc comm prec(59)] .
  op '_xor_ : 'Bool 'Bool -> 'Bool [assoc comm prec(57)] .
  op 'false : nil -> 'Bool [ctor special(
    id-hook('SystemFalse,nil))] .
  op 'if_then_else_fi : 'Bool 'Universal 'Universal -> 'Universal [poly(2 3
    0)special(
    id-hook('BranchSymbol,nil)
    term-hook('1,'true.Bool)
    term-hook('2,'false.Bool))] .
  op 'not_ : 'Bool -> 'Bool [prec(53)] .
  op 's_ : 'Nat -> 'Nat [none] .
  op 'true : nil -> 'Bool [ctor special(
    id-hook('SystemTrue,nil))] .
  none
  eq '_+_['s_['N:Nat],'s_['M:Nat]]= 's_['s_['_+_['N:Nat,'M:Nat]]] [none] .
  eq '_and_['A:Bool,'A:Bool]= 'A:Bool [none] .
  eq '_and_['A:Bool,'_xor_['B:Bool,'C:Bool]]= '_xor_['_and_['A:Bool,'B:Bool],
    '_and_['A:Bool,'C:Bool]] [none] .
  eq '_and_['false.Bool,'A:Bool]= 'false.Bool [none] .
  eq '_and_['true.Bool,'A:Bool]= 'A:Bool [none] .
  eq '_implies_['A:Bool,'B:Bool]= 'not_['_xor_['A:Bool,'_and_['A:Bool,
    'B:Bool]]] [none] .
  eq '_or_['A:Bool,'B:Bool]= '_xor_['_and_['A:Bool,'B:Bool],'_xor_['A:Bool,
    'B:Bool]] [none] .
  eq '_xor_['A:Bool,'A:Bool]= 'false.Bool [none] .
  eq '_xor_['false.Bool,'A:Bool]= 'A:Bool [none] .
  eq 'not_['A:Bool]= '_xor_['true.Bool,'A:Bool] [none] .
endfm
result FModule :
  fmod 'NAT-PLUS is
  nil
  sorts 'Bool ; 'Nat .
  none
  op '0 : nil -> 'Nat [none] .
  op '_+_ : 'Nat 'Nat -> 'Nat [assoc comm id('0.Nat)] .
  op '_=/=_ : 'Universal 'Universal -> 'Bool [poly(1 2)prec(51)special(
    id-hook('EqualitySymbol,nil)
    term-hook('equalTerm,'false.Bool)
    term-hook('notEqualTerm,'true.Bool))] .
  op '_==_ : 'Universal 'Universal -> 'Bool [poly(1 2)prec(51)special(
    id-hook('EqualitySymbol,nil)
    term-hook('equalTerm,'true.Bool)
    term-hook('notEqualTerm,'false.Bool))] .
  op '_and_ : 'Bool 'Bool -> 'Bool [assoc comm prec(55)] .
  op '_implies_ : 'Bool 'Bool -> 'Bool [gather('e 'E)prec(61)] .
  op '_or_ : 'Bool 'Bool -> 'Bool [assoc comm prec(59)] .
  op '_xor_ : 'Bool 'Bool -> 'Bool [assoc comm prec(57)] .
  op 'false : nil -> 'Bool [ctor special(
    id-hook('SystemFalse,nil))] .
  op 'if_then_else_fi : 'Bool 'Universal 'Universal -> 'Universal [poly(2 3
    0)special(
    id-hook('BranchSymbol,nil)
    term-hook('1,'true.Bool)
    term-hook('2,'false.Bool))] .
  op 'not_ : 'Bool -> 'Bool [prec(53)] .
  op 's_ : 'Nat -> 'Nat [none] .
  op 'true : nil -> 'Bool [ctor special(
    id-hook('SystemTrue,nil))] .
  none
  eq '_+_['s_['N:Nat],'s_['M:Nat]]= 's_['s_['_+_['N:Nat,'M:Nat]]] [none] .
  eq '_and_['A:Bool,'A:Bool]= 'A:Bool [none] .
  eq '_and_['A:Bool,'_xor_['B:Bool,'C:Bool]]= '_xor_['_and_['A:Bool,'B:Bool],
    '_and_['A:Bool,'C:Bool]] [none] .
  eq '_and_['false.Bool,'A:Bool]= 'false.Bool [none] .
  eq '_and_['true.Bool,'A:Bool]= 'A:Bool [none] .
  eq '_implies_['A:Bool,'B:Bool]= 'not_['_xor_['A:Bool,'_and_['A:Bool,
    'B:Bool]]] [none] .
  eq '_or_['A:Bool,'B:Bool]= '_xor_['_and_['A:Bool,'B:Bool],'_xor_['A:Bool,
    'B:Bool]] [none] .
  eq '_xor_['A:Bool,'A:Bool]= 'false.Bool [none] .
  eq '_xor_['false.Bool,'A:Bool]= 'A:Bool [none] .
  eq 'not_['A:Bool]= '_xor_['true.Bool,'A:Bool] [none] .
endfm

reduce in META-LEVEL :
  metaReduce(fmod 'NAT-PLUS is
  nil
  sorts 'Bool ; 'Nat .
  none
  op '0 : nil -> 'Nat [none] .
  op '_+_ : 'Nat 'Nat -> 'Nat [assoc comm id('0.Nat)] .
  op '_=/=_ : 'Universal 'Universal -> 'Bool [prec(51)poly(1 2)special(
    id-hook('EqualitySymbol,nil)
    term-hook('equalTerm,'false.Bool)
    term-hook('notEqualTerm,'true.Bool))] .
  op '_==_ : 'Universal 'Universal -> 'Bool [prec(51)poly(1 2)special(
    id-hook('EqualitySymbol,nil)
    term-hook('equalTerm,'true.Bool)
    term-hook('notEqualTerm,'false.Bool))] .
  op '_and_ : 'Bool 'Bool -> 'Bool [assoc comm prec(55)] .
  op '_implies_ : 'Bool 'Bool -> 'Bool [prec(61)gather('e 'E)] .
  op '_or_ : 'Bool 'Bool -> 'Bool [assoc comm prec(59)] .
  op '_xor_ : 'Bool 'Bool -> 'Bool [assoc comm prec(57)] .
  op 'false : nil -> 'Bool [ctor special(
    id-hook('SystemFalse,nil))] .
  op 'if_then_else_fi : 'Bool 'Universal 'Universal -> 'Universal [poly(2 3
    0)special(
    id-hook('BranchSymbol,nil)
    term-hook('1,'true.Bool)
    term-hook('2,'false.Bool))] .
  op 'not_ : 'Bool -> 'Bool [prec(53)] .
  op 's_ : 'Nat -> 'Nat [none] .
  op 'true : nil -> 'Bool [ctor special(
    id-hook('SystemTrue,nil))] .
  none
  eq '_+_['s_['N:Nat],'s_['M:Nat]]= 's_['s_['_+_['N:Nat,'M:Nat]]] [none] .
  eq '_and_['A:Bool,'A:Bool]= 'A:Bool [none] .
  eq '_and_['A:Bool,'_xor_['B:Bool,'C:Bool]]= '_xor_['_and_['A:Bool,'B:Bool],
    '_and_['A:Bool,'C:Bool]] [none] .
  eq '_and_['false.Bool,'A:Bool]= 'false.Bool [none] .
  eq '_and_['true.Bool,'A:Bool]= 'A:Bool [none] .
  eq '_implies_['A:Bool,'B:Bool]= 'not_['_xor_['A:Bool,'_and_['A:Bool,
    'B:Bool]]] [none] .
  eq '_or_['A:Bool,'B:Bool]= '_xor_['_and_['A:Bool,'B:Bool],'_xor_['A:Bool,
    'B:Bool]] [none] .
  eq '_xor_['A:Bool,'A:Bool]= 'false.Bool [none] .
  eq '_xor_['false.Bool,'A:Bool]= 'A:Bool [none] .
  eq 'not_['A:Bool]= '_xor_['true.Bool,'A:Bool] [none] .
endfm,'_+_['0.Nat,'s_['0.Nat]])
result ResultPair :
  {'s_['0.Nat],'Nat}

reduce in META-LEVEL :
  metaReduce(fmod 'NAT-PLUS is
  nil
  sorts 'Bool ; 'Nat .
  none
  op '0 : nil -> 'Nat [none] .
  op '_+_ : 'Nat 'Nat -> 'Nat [assoc comm id('0.Nat)] .
  op '_=/=_ : 'Universal 'Universal -> 'Bool [prec(51)poly(1 2)special(
    id-hook('EqualitySymbol,nil)
    term-hook('equalTerm,'false.Bool)
    term-hook('notEqualTerm,'true.Bool))] .
  op '_==_ : 'Universal 'Universal -> 'Bool [prec(51)poly(1 2)special(
    id-hook('EqualitySymbol,nil)
    term-hook('equalTerm,'true.Bool)
    term-hook('notEqualTerm,'false.Bool))] .
  op '_and_ : 'Bool 'Bool -> 'Bool [assoc comm prec(55)] .
  op '_implies_ : 'Bool 'Bool -> 'Bool [prec(61)gather('e 'E)] .
  op '_or_ : 'Bool 'Bool -> 'Bool [assoc comm prec(59)] .
  op '_xor_ : 'Bool 'Bool -> 'Bool [assoc comm prec(57)] .
  op 'false : nil -> 'Bool [ctor special(
    id-hook('SystemFalse,nil))] .
  op 'if_then_else_fi : 'Bool 'Universal 'Universal -> 'Universal [poly(2 3
    0)special(
    id-hook('BranchSymbol,nil)
    term-hook('1,'true.Bool)
    term-hook('2,'false.Bool))] .
  op 'not_ : 'Bool -> 'Bool [prec(53)] .
  op 's_ : 'Nat -> 'Nat [none] .
  op 'true : nil -> 'Bool [ctor special(
    id-hook('SystemTrue,nil))] .
  none
  eq '_+_['s_['N:Nat],'s_['M:Nat]]= 's_['s_['_+_['N:Nat,'M:Nat]]] [none] .
  eq '_and_['A:Bool,'A:Bool]= 'A:Bool [none] .
  eq '_and_['A:Bool,'_xor_['B:Bool,'C:Bool]]= '_xor_['_and_['A:Bool,'B:Bool],
    '_and_['A:Bool,'C:Bool]] [none] .
  eq '_and_['false.Bool,'A:Bool]= 'false.Bool [none] .
  eq '_and_['true.Bool,'A:Bool]= 'A:Bool [none] .
  eq '_implies_['A:Bool,'B:Bool]= 'not_['_xor_['A:Bool,'_and_['A:Bool,
    'B:Bool]]] [none] .
  eq '_or_['A:Bool,'B:Bool]= '_xor_['_and_['A:Bool,'B:Bool],'_xor_['A:Bool,
    'B:Bool]] [none] .
  eq '_xor_['A:Bool,'A:Bool]= 'false.Bool [none] .
  eq '_xor_['false.Bool,'A:Bool]= 'A:Bool [none] .
  eq 'not_['A:Bool]= '_xor_['true.Bool,'A:Bool] [none] .
endfm,'_+_['0.Nat,'s_['0.Nat]])
result ResultPair :
  {'s_['0.Nat],'Nat}

reduce in META-LEVEL :
  's_['0.Nat]
result GroundTerm :
  's_['0.Nat]

result Nat :
  s 0

reduce in META-LEVEL :
  getTerm(metaReduce(fmod 'META-LEVEL is
  nil
  sorts '@Attr@ ; '@AttrList@ ; '@Bubble@ ; '@Hook@ ; '@HookList@ ; '@Kind@ ;
    '@Map@ ; '@MapList@ ; '@ModExp@ ; '@NeTokenList@ ; '@Sort@ ; '@SortList@ ;
    '@SortToken@ ; '@Token@ ; '@Type@ ; '@TypeList@ ; '@ViewExp@ ; '@ViewToken@
    ; 'Assignment ; 'Attr ; 'AttrSet ; 'Bool ; 'Bound ; 'Char ; 'Condition ;
    'Constant ; 'Context ; 'EmptyCommaList ; 'EmptyTypeSet ; 'EqCondition ;
    'Equation ; 'EquationSet ; 'FModule ; 'FTheory ; 'FindResult ; 'GTermList ;
    'GroundTerm ; 'GroundTermList ; 'Header ; 'Hook ; 'HookList ; 'Import ;
    'ImportList ; 'Kind ; 'KindSet ; 'MatchPair ; 'MatchPair? ; 'MembAx ;
    'MembAxSet ; 'Module ; 'ModuleExpression ; 'Nat ; 'NatList ; 'NeCTermList ;
    'NeGroundTermList ; 'NeHookList ; 'NeKindSet ; 'NeNatList ;
    'NeParameterDeclList ; 'NeParameterList ; 'NeQidList ; 'NeQidSet ;
    'NeSortSet ; 'NeTermList ; 'NeTypeList ; 'NeTypeSet ; 'NzNat ; 'OpDecl ;
    'OpDeclSet ; 'OpMapping ; 'OpMappingSet ; 'ParameterDecl ;
    'ParameterDeclList ; 'ParameterList ; 'PrintOption ; 'PrintOptionSet ; 'Qid
    ; 'QidList ; 'QidSet ; 'Renaming ; 'RenamingSet ; 'Result4Tuple ;
    'Result4Tuple? ; 'ResultPair ; 'ResultPair? ; 'ResultTriple ;
    'ResultTriple? ; 'Rule ; 'RuleSet ; 'SModule ; 'STheory ; 'Sort ;
    'SortMapping ; 'SortMappingSet ; 'SortSet ; 'String ; 'SubsortDecl ;
    'SubsortDeclSet ; 'Substitution ; 'Substitution? ; 'Term ; 'TermList ;
    'TermQid ; 'Trace ; 'Trace? ; 'TraceStep ; 'Type ; 'Type? ; 'TypeList ;
    'TypeListSet ; 'TypeSet ; 'UnificandPair ; 'UnificationPair ;
    'UnificationPair? ; 'UnificationProblem ; 'UnificationTriple ;
    'UnificationTriple? ; 'Variable ; 'View ; 'Zero .
  subsort '@Attr@ < '@AttrList@ .
  subsort '@Hook@ < '@HookList@ .
  subsort '@Kind@ < '@Type@ .
  subsort '@Map@ < '@MapList@ .
  subsort '@Sort@ < '@SortList@ .
  subsort '@Sort@ < '@Type@ .
  subsort '@SortList@ < '@TypeList@ .
  subsort '@SortToken@ < '@Sort@ .
  subsort '@Token@ < '@ModExp@ .
  subsort '@Type@ < '@TypeList@ .
  subsort '@ViewToken@ < '@ViewExp@ .
  subsort 'Assignment < 'Substitution .
  subsort 'Attr < 'AttrSet .
  subsort 'Char < 'String .
  subsort 'Constant < 'GroundTerm .
  subsort 'Constant < 'TermQid .
  subsort 'Context < 'NeCTermList .
  subsort 'EmptyCommaList < 'GroundTermList .
  subsort 'EmptyCommaList < 'ParameterList .
  subsort 'EmptyTypeSet < 'KindSet .
  subsort 'EmptyTypeSet < 'SortSet .
  subsort 'EqCondition < 'Condition .
  subsort 'Equation < 'EquationSet .
  subsort 'FModule < 'SModule .
  subsort 'FTheory < 'STheory .
  subsort 'GroundTerm < 'NeGroundTermList .
  subsort 'GroundTerm < 'Term .
  subsort 'GroundTermList < 'TermList .
  subsort 'Hook < 'NeHookList .
  subsort 'Import < 'ImportList .
  subsort 'Kind < 'NeKindSet .
  subsort 'Kind < 'Type .
  subsort 'KindSet < 'TypeSet .
  subsort 'MatchPair < 'MatchPair? .
  subsort 'MembAx < 'MembAxSet .
  subsort 'Nat < 'Bound .
  subsort 'Nat < 'FindResult .
  subsort 'Nat < 'NeNatList .
  subsort 'NeCTermList < 'GTermList .
  subsort 'NeGroundTermList < 'GroundTermList .
  subsort 'NeGroundTermList < 'NeTermList .
  subsort 'NeHookList < 'HookList .
  subsort 'NeKindSet < 'KindSet .
  subsort 'NeKindSet < 'NeTypeSet .
  subsort 'NeNatList < 'NatList .
  subsort 'NeParameterDeclList < 'ParameterDeclList .
  subsort 'NeParameterList < 'ParameterList .
  subsort 'NeQidList < 'QidList .
  subsort 'NeQidSet < 'QidSet .
  subsort 'NeSortSet < 'NeTypeSet .
  subsort 'NeSortSet < 'SortSet .
  subsort 'NeTermList < 'TermList .
  subsort 'NeTypeList < 'NeQidList .
  subsort 'NeTypeList < 'TypeList .
  subsort 'NeTypeSet < 'NeQidSet .
  subsort 'NeTypeSet < 'TypeSet .
  subsort 'NzNat < 'Nat .
  subsort 'OpDecl < 'OpDeclSet .
  subsort 'OpMapping < 'OpMappingSet .
  subsort 'ParameterDecl < 'NeParameterDeclList .
  subsort 'PrintOption < 'PrintOptionSet .
  subsort 'Qid < 'Header .
  subsort 'Qid < 'ModuleExpression .
  subsort 'Qid < 'NeQidList .
  subsort 'Qid < 'NeQidSet .
  subsort 'Renaming < 'RenamingSet .
  subsort 'Result4Tuple < 'Result4Tuple? .
  subsort 'ResultPair < 'ResultPair? .
  subsort 'ResultTriple < 'ResultTriple? .
  subsort 'Rule < 'RuleSet .
  subsort 'SModule < 'Module .
  subsort 'STheory < 'Module .
  subsort 'Sort < 'NeParameterList .
  subsort 'Sort < 'NeSortSet .
  subsort 'Sort < 'Type .
  subsort 'SortMapping < 'SortMappingSet .
  subsort 'SortSet < 'TypeSet .
  subsort 'SubsortDecl < 'SubsortDeclSet .
  subsort 'Substitution < 'Substitution? .
  subsort 'Term < 'NeTermList .
  subsort 'TermList < 'GTermList .
  subsort 'TermQid < 'Qid .
  subsort 'TermQid < 'Term .
  subsort 'Trace < 'Trace? .
  subsort 'TraceStep < 'Trace .
  subsort 'Type < 'NeTypeList .
  subsort 'Type < 'NeTypeSet .
  subsort 'Type < 'Qid .
  subsort 'Type < 'Type? .
  subsort 'TypeList < 'QidList .
  subsort 'TypeList < 'TypeListSet .
  subsort 'TypeSet < 'QidSet .
  subsort 'TypeSet < 'TypeListSet .
  subsort 'UnificandPair < 'UnificationProblem .
  subsort 'UnificationPair < 'UnificationPair? .
  subsort 'UnificationTriple < 'UnificationTriple? .
  subsort 'Variable < 'TermQid .
  subsort 'Zero < 'Nat .
  op '$card : 'QidSet 'Nat -> 'Nat [none] .
  op '$diff : 'QidSet 'QidSet 'QidSet -> 'QidSet [none] .
  op '$intersect : 'QidSet 'QidSet 'QidSet -> 'QidSet [none] .
  op '$reverse : 'NatList 'NatList -> 'NatList [none] .
  op '$reverse : 'QidList 'QidList -> 'QidList [none] .
  op '$size : 'NatList 'Nat -> 'Nat [none] .
  op '$size : 'QidList 'Nat -> 'Nat [none] .
  op '0 : nil -> 'Zero [ctor] .
  op '<Qids> : nil -> 'Constant [special(
    id-hook('QuotedIdentifierSymbol,'constantQid))] .
  op '<Qids> : nil -> 'Kind [special(
    id-hook('QuotedIdentifierSymbol,'kindQid))] .
  op '<Qids> : nil -> 'Qid [special(
    id-hook('QuotedIdentifierSymbol,nil))] .
  op '<Qids> : nil -> 'Sort [special(
    id-hook('QuotedIdentifierSymbol,'sortQid))] .
  op '<Qids> : nil -> 'Variable [special(
    id-hook('QuotedIdentifierSymbol,'variableQid))] .
  op '<Strings> : nil -> 'Char [special(
    id-hook('StringSymbol,nil))] .
  op '<Strings> : nil -> 'String [special(
    id-hook('StringSymbol,nil))] .
  op 'POWER`[_`] : '@Token@ -> '@ModExp@ [none] .
  op 'TUPLE`[_`] : '@Token@ -> '@ModExp@ [none] .
  op '_&_ : 'Nat 'Nat -> 'Nat [assoc comm prec(53)special(
    id-hook('ACU_NumberOpSymbol,'&)
    op-hook('succSymbol,'s_,'Nat,'NzNat))] .
  op '_*_ : 'Nat 'Nat -> 'Nat [assoc comm prec(31)special(
    id-hook('ACU_NumberOpSymbol,'*)
    op-hook('succSymbol,'s_,'Nat,'NzNat))] .
  op '_*_ : 'NzNat 'NzNat -> 'NzNat [assoc comm prec(31)special(
    id-hook('ACU_NumberOpSymbol,'*)
    op-hook('succSymbol,'s_,'Nat,'NzNat))] .
  op '_*`(_`) : '@ModExp@ '@MapList@ -> '@ModExp@ [none] .
  op '_*`(_`) : 'ModuleExpression 'RenamingSet -> 'ModuleExpression [ctor prec(
    39)format('d 'd 's 'n++i 'n--i 'd)] .
  op '_+_ : '@ModExp@ '@ModExp@ -> '@ModExp@ [assoc prec(42)] .
  op '_+_ : 'ModuleExpression 'ModuleExpression -> 'ModuleExpression [assoc
    comm ctor] .
  op '_+_ : 'Nat 'Nat -> 'Nat [assoc comm prec(33)special(
    id-hook('ACU_NumberOpSymbol,'+)
    op-hook('succSymbol,'s_,'Nat,'NzNat))] .
  op '_+_ : 'NzNat 'Nat -> 'NzNat [assoc comm prec(33)special(
    id-hook('ACU_NumberOpSymbol,'+)
    op-hook('succSymbol,'s_,'Nat,'NzNat))] .
  op '_+_ : 'String 'String -> 'String [prec(33)gather('E 'e)special(
    id-hook('StringOpSymbol,'+)
    op-hook('stringSymbol,'<Strings>,nil,'Char))] .
  op '_/\_ : 'Condition 'Condition -> 'Condition [assoc ctor id(
    'nil.EqCondition)prec(73)] .
  op '_/\_ : 'EqCondition 'EqCondition -> 'EqCondition [assoc ctor id(
    'nil.EqCondition)prec(73)] .
  op '_/\_ : 'UnificationProblem 'UnificationProblem -> 'UnificationProblem [
    assoc comm ctor prec(73)] .
  op '_::_ : 'Sort 'ModuleExpression -> 'ParameterDecl [none] .
  op '_:=_ : 'Term 'Term -> 'EqCondition [ctor prec(71)] .
  op '_:_ : 'Term 'Sort -> 'EqCondition [ctor prec(71)] .
  op '_;_ : 'EmptyTypeSet 'EmptyTypeSet -> 'EmptyTypeSet [assoc comm ctor id(
    'none.EmptyTypeSet)prec(43)] .
  op '_;_ : 'KindSet 'KindSet -> 'KindSet [assoc comm ctor id(
    'none.EmptyTypeSet)prec(43)] .
  op '_;_ : 'NeKindSet 'KindSet -> 'NeKindSet [assoc comm ctor id(
    'none.EmptyTypeSet)prec(43)] .
  op '_;_ : 'NeQidSet 'QidSet -> 'NeQidSet [assoc comm ctor id(
    'none.QidSet)prec(43)] .
  op '_;_ : 'NeSortSet 'SortSet -> 'NeSortSet [assoc comm ctor id(
    'none.EmptyTypeSet)prec(43)] .
  op '_;_ : 'NeTypeSet 'TypeSet -> 'NeTypeSet [assoc comm ctor id(
    'none.EmptyTypeSet)prec(43)] .
  op '_;_ : 'QidSet 'QidSet -> 'QidSet [assoc comm ctor id('none.QidSet)prec(
    43)] .
  op '_;_ : 'SortSet 'SortSet -> 'SortSet [assoc comm ctor id(
    'none.EmptyTypeSet)prec(43)] .
  op '_;_ : 'Substitution 'Substitution -> 'Substitution [assoc comm ctor id(
    'none.Substitution)prec(65)] .
  op '_;_ : 'TypeListSet 'TypeListSet -> 'TypeListSet [assoc comm ctor id(
    'none.EmptyTypeSet)prec(43)] .
  op '_;_ : 'TypeSet 'TypeSet -> 'TypeSet [assoc comm ctor id(
    'none.EmptyTypeSet)prec(43)] .
  op '_<-_ : 'Variable 'Term -> 'Assignment [ctor prec(63)format('nt 'd 'd 'd)]
    .
  op '_<<_ : 'Nat 'Nat -> 'Nat [prec(35)gather('E 'e)special(
    id-hook('NumberOpSymbol,'<<)
    op-hook('succSymbol,'s_,'Nat,'NzNat))] .
  op '_<=_ : 'Nat 'Nat -> 'Bool [prec(37)special(
    id-hook('NumberOpSymbol,'<=)
    op-hook('succSymbol,'s_,'Nat,'NzNat)
    term-hook('trueTerm,'true.Bool)
    term-hook('falseTerm,'false.Bool))] .
  op '_<=_ : 'String 'String -> 'Bool [prec(37)special(
    id-hook('StringOpSymbol,'<=)
    op-hook('stringSymbol,'<Strings>,nil,'Char)
    term-hook('trueTerm,'true.Bool)
    term-hook('falseTerm,'false.Bool))] .
  op '_<_ : 'Nat 'Nat -> 'Bool [prec(37)special(
    id-hook('NumberOpSymbol,'<)
    op-hook('succSymbol,'s_,'Nat,'NzNat)
    term-hook('trueTerm,'true.Bool)
    term-hook('falseTerm,'false.Bool))] .
  op '_<_ : 'String 'String -> 'Bool [prec(37)special(
    id-hook('StringOpSymbol,'<)
    op-hook('stringSymbol,'<Strings>,nil,'Char)
    term-hook('trueTerm,'true.Bool)
    term-hook('falseTerm,'false.Bool))] .
  op '_=/=_ : 'Universal 'Universal -> 'Bool [prec(51)poly(1 2)special(
    id-hook('EqualitySymbol,nil)
    term-hook('equalTerm,'false.Bool)
    term-hook('notEqualTerm,'true.Bool))] .
  op '_==_ : 'Universal 'Universal -> 'Bool [prec(51)poly(1 2)special(
    id-hook('EqualitySymbol,nil)
    term-hook('equalTerm,'true.Bool)
    term-hook('notEqualTerm,'false.Bool))] .
  op '_=>_ : 'Term 'Term -> 'Condition [ctor prec(71)] .
  op '_=?_ : 'Term 'Term -> 'UnificandPair [ctor prec(71)] .
  op '_=_ : 'Term 'Term -> 'EqCondition [ctor prec(71)] .
  op '_>=_ : 'Nat 'Nat -> 'Bool [prec(37)special(
    id-hook('NumberOpSymbol,'>=)
    op-hook('succSymbol,'s_,'Nat,'NzNat)
    term-hook('trueTerm,'true.Bool)
    term-hook('falseTerm,'false.Bool))] .
  op '_>=_ : 'String 'String -> 'Bool [prec(37)special(
    id-hook('StringOpSymbol,'>=)
    op-hook('stringSymbol,'<Strings>,nil,'Char)
    term-hook('trueTerm,'true.Bool)
    term-hook('falseTerm,'false.Bool))] .
  op '_>>_ : 'Nat 'Nat -> 'Nat [prec(35)gather('E 'e)special(
    id-hook('NumberOpSymbol,'>>)
    op-hook('succSymbol,'s_,'Nat,'NzNat))] .
  op '_>_ : 'Nat 'Nat -> 'Bool [prec(37)special(
    id-hook('NumberOpSymbol,'>)
    op-hook('succSymbol,'s_,'Nat,'NzNat)
    term-hook('trueTerm,'true.Bool)
    term-hook('falseTerm,'false.Bool))] .
  op '_>_ : 'String 'String -> 'Bool [prec(37)special(
    id-hook('StringOpSymbol,'>)
    op-hook('stringSymbol,'<Strings>,nil,'Char)
    term-hook('trueTerm,'true.Bool)
    term-hook('falseTerm,'false.Bool))] .
  op '_\_ : 'QidSet 'QidSet -> 'QidSet [gather('E 'e)] .
  op '_^_ : 'Nat 'Nat -> 'Nat [prec(29)gather('E 'e)special(
    id-hook('NumberOpSymbol,'^)
    op-hook('succSymbol,'s_,'Nat,'NzNat))] .
  op '_^_ : 'NzNat 'Nat -> 'NzNat [prec(29)gather('E 'e)special(
    id-hook('NumberOpSymbol,'^)
    op-hook('succSymbol,'s_,'Nat,'NzNat))] .
  op '__ : '@AttrList@ '@AttrList@ -> '@AttrList@ [assoc] .
  op '__ : '@HookList@ '@HookList@ -> '@HookList@ [assoc] .
  op '__ : '@SortList@ '@SortList@ -> '@SortList@ [assoc] .
  op '__ : '@TypeList@ '@TypeList@ -> '@TypeList@ [assoc] .
  op '__ : 'AttrSet 'AttrSet -> 'AttrSet [assoc comm ctor id('none.AttrSet)] .
  op '__ : 'EquationSet 'EquationSet -> 'EquationSet [assoc comm ctor id(
    'none.EquationSet)format('d 'ni 'd)] .
  op '__ : 'HookList 'HookList -> 'HookList [assoc ctor id('nil.HookList)] .
  op '__ : 'HookList 'NeHookList -> 'NeHookList [assoc ctor id('nil.HookList)]
    .
  op '__ : 'ImportList 'ImportList -> 'ImportList [assoc ctor id(
    'nil.ImportList)format('d 'ni 'd)] .
  op '__ : 'MembAxSet 'MembAxSet -> 'MembAxSet [assoc comm ctor id(
    'none.MembAxSet)format('d 'ni 'd)] .
  op '__ : 'NatList 'NatList -> 'NatList [assoc ctor id('nil.NatList)prec(25)]
    .
  op '__ : 'NatList 'NeNatList -> 'NeNatList [assoc ctor id('nil.NatList)prec(
    25)] .
  op '__ : 'NeHookList 'HookList -> 'NeHookList [assoc ctor id('nil.HookList)]
    .
  op '__ : 'NeNatList 'NatList -> 'NeNatList [assoc ctor id('nil.NatList)prec(
    25)] .
  op '__ : 'NeQidList 'QidList -> 'NeQidList [assoc ctor id('nil.QidList)prec(
    25)] .
  op '__ : 'NeTypeList 'TypeList -> 'NeTypeList [assoc ctor id(
    'nil.TypeList)prec(25)] .
  op '__ : 'OpDeclSet 'OpDeclSet -> 'OpDeclSet [assoc comm ctor id(
    'none.OpDeclSet)format('d 'ni 'd)] .
  op '__ : 'OpMappingSet 'OpMappingSet -> 'OpMappingSet [assoc comm ctor id(
    'none.OpMappingSet)format('d 'ni 'd)] .
  op '__ : 'PrintOptionSet 'PrintOptionSet -> 'PrintOptionSet [assoc comm ctor
    id('none.PrintOptionSet)] .
  op '__ : 'QidList 'NeQidList -> 'NeQidList [assoc ctor id('nil.QidList)prec(
    25)] .
  op '__ : 'QidList 'QidList -> 'QidList [assoc ctor id('nil.QidList)prec(25)]
    .
  op '__ : 'RuleSet 'RuleSet -> 'RuleSet [assoc comm ctor id(
    'none.RuleSet)format('d 'ni 'd)] .
  op '__ : 'SortMappingSet 'SortMappingSet -> 'SortMappingSet [assoc comm ctor
    id('none.SortMappingSet)format('d 'ni 'd)] .
  op '__ : 'SubsortDeclSet 'SubsortDeclSet -> 'SubsortDeclSet [assoc comm ctor
    id('none.SubsortDeclSet)format('d 'ni 'd)] .
  op '__ : 'Trace 'Trace -> 'Trace [assoc ctor id('nil.Trace)format('d 'n 'd)]
    .
  op '__ : 'TypeList 'NeTypeList -> 'NeTypeList [assoc ctor id(
    'nil.TypeList)prec(25)] .
  op '__ : 'TypeList 'TypeList -> 'TypeList [assoc ctor id('nil.TypeList)prec(
    25)] .
  op '_`,_ : '@MapList@ '@MapList@ -> '@MapList@ [assoc prec(42)] .
  op '_`,_ : '@ViewExp@ '@ViewExp@ -> '@ViewExp@ [assoc] .
  op '_`,_ : 'EmptyCommaList 'EmptyCommaList -> 'EmptyCommaList [assoc ctor id(
    'empty.EmptyCommaList)prec(121)gather('e 'E)] .
  op '_`,_ : 'GTermList 'GTermList -> 'GTermList [assoc ctor id(
    'empty.GroundTermList)prec(121)gather('e 'E)] .
  op '_`,_ : 'GroundTermList 'GroundTermList -> 'GroundTermList [assoc ctor id(
    'empty.GroundTermList)prec(121)gather('e 'E)] .
  op '_`,_ : 'GroundTermList 'NeGroundTermList -> 'NeGroundTermList [assoc ctor
    id('empty.GroundTermList)prec(121)gather('e 'E)] .
  op '_`,_ : 'NeCTermList 'TermList -> 'NeCTermList [assoc ctor id(
    'empty.GroundTermList)prec(121)gather('e 'E)] .
  op '_`,_ : 'NeGroundTermList 'GroundTermList -> 'NeGroundTermList [assoc ctor
    id('empty.GroundTermList)prec(121)gather('e 'E)] .
  op '_`,_ : 'NeParameterDeclList 'ParameterDeclList -> 'NeParameterDeclList [
    assoc ctor id('nil.ParameterDeclList)prec(121)] .
  op '_`,_ : 'NeParameterList 'ParameterList -> 'NeParameterList [assoc ctor
    id('empty.EmptyCommaList)prec(121)gather('e 'E)] .
  op '_`,_ : 'NeTermList 'TermList -> 'NeTermList [assoc ctor id(
    'empty.GroundTermList)prec(121)gather('e 'E)] .
  op '_`,_ : 'ParameterDeclList 'NeParameterDeclList -> 'NeParameterDeclList [
    assoc ctor id('nil.ParameterDeclList)prec(121)] .
  op '_`,_ : 'ParameterDeclList 'ParameterDeclList -> 'ParameterDeclList [assoc
    ctor id('nil.ParameterDeclList)prec(121)] .
  op '_`,_ : 'ParameterList 'NeParameterList -> 'NeParameterList [assoc ctor
    id('empty.EmptyCommaList)prec(121)gather('e 'E)] .
  op '_`,_ : 'ParameterList 'ParameterList -> 'ParameterList [assoc ctor id(
    'empty.EmptyCommaList)prec(121)gather('e 'E)] .
  op '_`,_ : 'RenamingSet 'RenamingSet -> 'RenamingSet [assoc comm ctor prec(
    43)format('d 'd 'ni 'd)] .
  op '_`,_ : 'TermList 'NeCTermList -> 'NeCTermList [assoc ctor id(
    'empty.GroundTermList)prec(121)gather('e 'E)] .
  op '_`,_ : 'TermList 'NeTermList -> 'NeTermList [assoc ctor id(
    'empty.GroundTermList)prec(121)gather('e 'E)] .
  op '_`,_ : 'TermList 'TermList -> 'TermList [assoc ctor id(
    'empty.GroundTermList)prec(121)gather('e 'E)] .
  op '_`[_`] : 'Qid 'NeCTermList -> 'Context [ctor] .
  op '_`[_`] : 'Qid 'NeGroundTermList -> 'GroundTerm [ctor] .
  op '_`[_`] : 'Qid 'NeTermList -> 'Term [ctor] .
  op '_`{_`} : '@ModExp@ '@ViewExp@ -> '@ModExp@ [none] .
  op '_`{_`} : '@Sort@ '@ViewExp@ -> '@Sort@ [prec(40)] .
  op '_`{_`} : '@ViewExp@ '@ViewExp@ -> '@ViewExp@ [prec(40)] .
  op '_`{_`} : 'ModuleExpression 'ParameterList -> 'ModuleExpression [ctor
    prec(37)] .
  op '_`{_`} : 'Qid 'ParameterDeclList -> 'Header [ctor] .
  op '_and-then_ : 'Bool 'Bool -> 'Bool [strat(1 0)prec(55)gather('e 'E)] .
  op '_and_ : 'Bool 'Bool -> 'Bool [assoc comm prec(55)] .
  op '_divides_ : 'NzNat 'Nat -> 'Bool [prec(51)special(
    id-hook('NumberOpSymbol,'divides)
    op-hook('succSymbol,'s_,'Nat,'NzNat)
    term-hook('trueTerm,'true.Bool)
    term-hook('falseTerm,'false.Bool))] .
  op '_implies_ : 'Bool 'Bool -> 'Bool [prec(61)gather('e 'E)] .
  op '_in_ : 'Qid 'QidSet -> 'Bool [none] .
  op '_or-else_ : 'Bool 'Bool -> 'Bool [strat(1 0)prec(59)gather('e 'E)] .
  op '_or_ : 'Bool 'Bool -> 'Bool [assoc comm prec(59)] .
  op '_psubset_ : 'QidSet 'QidSet -> 'Bool [none] .
  op '_quo_ : 'Nat 'NzNat -> 'Nat [prec(31)gather('E 'e)special(
    id-hook('NumberOpSymbol,'quo)
    op-hook('succSymbol,'s_,'Nat,'NzNat))] .
  op '_rem_ : 'Nat 'NzNat -> 'Nat [prec(31)gather('E 'e)special(
    id-hook('NumberOpSymbol,'rem)
    op-hook('succSymbol,'s_,'Nat,'NzNat))] .
  op '_subset_ : 'QidSet 'QidSet -> 'Bool [none] .
  op '_xor_ : 'Bool 'Bool -> 'Bool [assoc comm prec(57)] .
  op '_xor_ : 'Nat 'Nat -> 'Nat [assoc comm prec(55)special(
    id-hook('ACU_NumberOpSymbol,'xor)
    op-hook('succSymbol,'s_,'Nat,'NzNat))] .
  op '_|_ : 'Nat 'Nat -> 'Nat [assoc comm prec(57)special(
    id-hook('ACU_NumberOpSymbol,'|)
    op-hook('succSymbol,'s_,'Nat,'NzNat))] .
  op '_|_ : 'NzNat 'Nat -> 'NzNat [assoc comm prec(57)special(
    id-hook('ACU_NumberOpSymbol,'|)
    op-hook('succSymbol,'s_,'Nat,'NzNat))] .
  op '`[_`] : '@Sort@ -> '@Kind@ [none] .
  op '`[_`] : '@Token@ -> 'Module [none] .
  op '`[_`] : 'Qid -> 'Module [none] .
  op '`[`] : nil -> 'Context [ctor] .
  op '`{_`,_`,_`,_`} : 'Term 'Type 'Substitution 'Context -> 'Result4Tuple [
    ctor] .
  op '`{_`,_`,_`} : 'Substitution 'Substitution 'Nat -> 'UnificationTriple [
    ctor] .
  op '`{_`,_`,_`} : 'Term 'Type 'Rule -> 'TraceStep [ctor] .
  op '`{_`,_`,_`} : 'Term 'Type 'Substitution -> 'ResultTriple [ctor] .
  op '`{_`,_`} : 'Substitution 'Context -> 'MatchPair [ctor] .
  op '`{_`,_`} : 'Substitution 'Nat -> 'UnificationPair [ctor] .
  op '`{_`,_`} : 'Term 'Type -> 'ResultPair [ctor] .
  op 'ambiguity : 'ResultPair 'ResultPair -> 'ResultPair? [ctor] .
  op 'anyType : nil -> 'Type? [ctor] .
  op 'append : 'NatList 'NatList -> 'NatList [none] .
  op 'append : 'NatList 'NeNatList -> 'NeNatList [none] .
  op 'append : 'NeNatList 'NatList -> 'NeNatList [none] .
  op 'append : 'NeQidList 'QidList -> 'NeQidList [none] .
  op 'append : 'QidList 'NeQidList -> 'NeQidList [none] .
  op 'append : 'QidList 'QidList -> 'QidList [none] .
  op 'ascii : 'Char -> 'Nat [special(
    id-hook('StringOpSymbol,'ascii)
    op-hook('stringSymbol,'<Strings>,nil,'Char)
    op-hook('succSymbol,'s_,'Nat,'NzNat))] .
  op 'assoc : nil -> '@Attr@ [none] .
  op 'assoc : nil -> 'Attr [ctor] .
  op 'associative : nil -> '@Attr@ [none] .
  op 'attr_._to_ : '@Sort@ '@Token@ '@Token@ -> '@Map@ [none] .
  op 'bubble : 'QidList -> '@Bubble@ [special(
    id-hook('Bubble,'1 '-1 '`( '`))
    op-hook('qidListSymbol,'__,'QidList 'QidList,'QidList)
    op-hook('qidSymbol,'<Qids>,nil,'Qid))] .
  op 'ceq_=_if_`[_`]. : 'Term 'Term 'EqCondition 'AttrSet -> 'Equation [ctor
    format('d 'd 'd 'd 'd 'd 's 'd 'd 's 'd)] .
  op 'char : '`[FindResult`] -> '`[String`] [special(
    id-hook('StringOpSymbol,'char)
    op-hook('stringSymbol,'<Strings>,nil,'Char)
    op-hook('succSymbol,'s_,'Nat,'NzNat))] .
  op 'class_to_ : '@Sort@ '@Sort@ -> '@Map@ [none] .
  op 'cmb_:_if_`[_`]. : 'Term 'Sort 'EqCondition 'AttrSet -> 'MembAx [ctor
    format('d 'd 'd 'd 'd 'd 's 'd 'd 's 'd)] .
  op 'comm : nil -> '@Attr@ [none] .
  op 'comm : nil -> 'Attr [ctor] .
  op 'commutative : nil -> '@Attr@ [none] .
  op 'completeName : '`[Module`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] -> '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] [special(
    id-hook('MetaLevelOpSymbol,'metaCompleteName)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'config : nil -> '@Attr@ [none] .
  op 'config : nil -> 'Attr [ctor] .
  op 'constructor : nil -> '@Attr@ [none] .
  op 'crl_=>_if_`[_`]. : 'Term 'Term 'Condition 'AttrSet -> 'Rule [ctor format(
    'd 'd 'd 'd 'd 'd 's 'd 'd 's 'd)] .
  op 'ctor : nil -> '@Attr@ [none] .
  op 'ctor : nil -> 'Attr [ctor] .
  op 'delete : 'Qid 'QidSet -> 'QidSet [none] .
  op 'ditto : nil -> '@Attr@ [none] .
  op 'downTerm : 'Term 'Universal -> 'Universal [poly(2 0)special(
    id-hook('MetaLevelOpSymbol,'metaDownTerm)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'empty : nil -> 'EmptyCommaList [ctor] .
  op 'empty : nil -> 'GroundTermList [ctor] .
  op 'eq_=_`[_`]. : 'Term 'Term 'AttrSet -> 'Equation [ctor format('d 'd 'd 'd
    's 'd 'd 's 'd)] .
  op 'extending_. : 'ModuleExpression -> 'Import [ctor] .
  op 'failure : nil -> 'Result4Tuple? [ctor] .
  op 'failure : nil -> 'ResultPair? [ctor] .
  op 'failure : nil -> 'ResultTriple? [ctor] .
  op 'failure : nil -> 'Trace? [ctor] .
  op 'false : nil -> 'Bool [ctor special(
    id-hook('SystemFalse,nil))] .
  op 'find : 'String 'String 'Nat -> 'FindResult [special(
    id-hook('StringOpSymbol,'find)
    op-hook('stringSymbol,'<Strings>,nil,'Char)
    op-hook('succSymbol,'s_,'Nat,'NzNat)
    term-hook('notFoundTerm,'notFound.FindResult))] .
  op 'flat : nil -> 'PrintOption [ctor] .
  op 'fmod_is_sorts_.____endfm : 'Header 'ImportList 'SortSet 'SubsortDeclSet
    'OpDeclSet 'MembAxSet 'EquationSet -> 'FModule [ctor gather('& '& '& '& '&
    '& '&)format('d 'd 's 'n++i 'ni 'd 'd 'ni 'ni 'ni 'ni 'n--i 'd)] .
  op 'format : 'QidList -> 'Attr [ctor] .
  op 'format : nil -> 'PrintOption [ctor] .
  op 'format`(_`) : '@NeTokenList@ -> '@Attr@ [none] .
  op 'front : 'NeNatList -> 'NatList [none] .
  op 'front : 'NeQidList -> 'QidList [none] .
  op 'frozen : 'NeNatList -> 'Attr [ctor] .
  op 'frozen : nil -> '@Attr@ [none] .
  op 'frozen`(_`) : '@NeTokenList@ -> '@AttrList@ [none] .
  op 'fth_is_sorts_.____endfth : 'Qid 'ImportList 'SortSet 'SubsortDeclSet
    'OpDeclSet 'MembAxSet 'EquationSet -> 'FTheory [ctor gather('& '& '& '& '&
    '& '&)format('d 'd 'd 'n++i 'ni 'd 'd 'ni 'ni 'ni 'ni 'n--i 'd)] .
  op 'gather : 'QidList -> 'Attr [ctor] .
  op 'gather`(_`) : '@NeTokenList@ -> '@Attr@ [none] .
  op 'gathering`(_`) : '@NeTokenList@ -> '@Attr@ [none] .
  op 'gcd : 'Nat 'Nat -> 'Nat [assoc comm special(
    id-hook('ACU_NumberOpSymbol,'gcd)
    op-hook('succSymbol,'s_,'Nat,'NzNat))] .
  op 'gcd : 'NzNat 'Nat -> 'NzNat [assoc comm special(
    id-hook('ACU_NumberOpSymbol,'gcd)
    op-hook('succSymbol,'s_,'Nat,'NzNat))] .
  op 'getContext : 'MatchPair -> 'Context [none] .
  op 'getContext : 'Result4Tuple -> 'Context [none] .
  op 'getEqs : 'Module -> 'EquationSet [none] .
  op 'getFrom : 'View -> 'ModuleExpression [none] .
  op 'getImports : 'Module -> 'ImportList [none] .
  op 'getKind : '`[Module`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] -> '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] [special(
    id-hook('MetaLevelOpSymbol,'metaGetKind)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'getKinds : '`[Module`] -> '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] [special(
    id-hook('MetaLevelOpSymbol,'metaGetKinds)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'getMbs : 'Module -> 'MembAxSet [none] .
  op 'getName : 'Constant -> 'Qid [none] .
  op 'getName : 'Module -> 'Qid [none] .
  op 'getName : 'Variable -> 'Qid [none] .
  op 'getName : 'View -> 'Qid [none] .
  op 'getOpMappings : 'View -> 'OpMappingSet [none] .
  op 'getOps : 'Module -> 'OpDeclSet [none] .
  op 'getRls : 'Module -> 'RuleSet [none] .
  op 'getSortMappings : 'View -> 'SortMappingSet [none] .
  op 'getSorts : 'Module -> 'SortSet [none] .
  op 'getSubsorts : 'Module -> 'SubsortDeclSet [none] .
  op 'getSubstitution : 'MatchPair -> 'Substitution [none] .
  op 'getSubstitution : 'Result4Tuple -> 'Substitution [none] .
  op 'getSubstitution : 'ResultTriple -> 'Substitution [none] .
  op 'getTerm : 'Result4Tuple -> 'Term [none] .
  op 'getTerm : 'ResultPair -> 'Term [none] .
  op 'getTerm : 'ResultTriple -> 'Term [none] .
  op 'getTo : 'View -> 'ModuleExpression [none] .
  op 'getType : 'Constant -> 'Type [none] .
  op 'getType : 'Result4Tuple -> 'Type [none] .
  op 'getType : 'ResultPair -> 'Type [none] .
  op 'getType : 'ResultTriple -> 'Type [none] .
  op 'getType : 'Variable -> 'Type [none] .
  op 'glbSorts : '`[Module`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] -> '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] [
    special(
    id-hook('MetaLevelOpSymbol,'metaGlbSorts)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'head : 'NeNatList -> 'Nat [none] .
  op 'head : 'NeQidList -> 'Qid [none] .
  op 'id : 'Term -> 'Attr [ctor] .
  op 'id-hook : 'Qid 'QidList -> 'Hook [ctor format('nssss 'd)] .
  op 'id-hook_ : '@Token@ -> '@Hook@ [none] .
  op 'id-hook_`(_`) : '@Token@ '@NeTokenList@ -> '@Hook@ [none] .
  op 'id:_ : '@Bubble@ -> '@Attr@ [none] .
  op 'idem : nil -> '@Attr@ [none] .
  op 'idem : nil -> 'Attr [ctor] .
  op 'idempotent : nil -> '@Attr@ [none] .
  op 'identity:_ : '@Bubble@ -> '@Attr@ [none] .
  op 'if_then_else_fi : 'Bool 'Universal 'Universal -> 'Universal [poly(2 3
    0)special(
    id-hook('BranchSymbol,nil)
    term-hook('1,'true.Bool)
    term-hook('2,'false.Bool))] .
  op 'including_. : 'ModuleExpression -> 'Import [ctor] .
  op 'insert : 'Qid 'QidSet -> 'QidSet [none] .
  op 'intersection : 'QidSet 'QidSet -> 'QidSet [none] .
  op 'iter : nil -> '@Attr@ [none] .
  op 'iter : nil -> 'Attr [ctor] .
  op 'label : 'Qid -> 'Attr [ctor] .
  op 'label_to_ : '@Token@ '@Token@ -> '@Map@ [none] .
  op 'label_to_ : 'Qid 'Qid -> 'Renaming [ctor] .
  op 'last : 'NeNatList -> 'Nat [none] .
  op 'last : 'NeQidList -> 'Qid [none] .
  op 'lcm : 'Nat 'Nat -> 'Nat [assoc comm special(
    id-hook('ACU_NumberOpSymbol,'lcm)
    op-hook('succSymbol,'s_,'Nat,'NzNat))] .
  op 'lcm : 'NzNat 'NzNat -> 'NzNat [assoc comm special(
    id-hook('ACU_NumberOpSymbol,'lcm)
    op-hook('succSymbol,'s_,'Nat,'NzNat))] .
  op 'leastSort : '`[Module`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] -> '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] [special(
    id-hook('MetaLevelOpSymbol,'metaLeastSort)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'left-id : 'Term -> 'Attr [ctor] .
  op 'left`id:_ : '@Bubble@ -> '@Attr@ [none] .
  op 'left`identity:_ : '@Bubble@ -> '@Attr@ [none] .
  op 'length : 'String -> 'Nat [special(
    id-hook('StringOpSymbol,'length)
    op-hook('stringSymbol,'<Strings>,nil,'Char)
    op-hook('succSymbol,'s_,'Nat,'NzNat))] .
  op 'lesserSorts : '`[Module`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] -> '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] [special(
    id-hook('MetaLevelOpSymbol,'metaLesserSorts)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'max : 'Nat 'Nat -> 'Nat [assoc comm special(
    id-hook('ACU_NumberOpSymbol,'max)
    op-hook('succSymbol,'s_,'Nat,'NzNat))] .
  op 'max : 'NzNat 'Nat -> 'NzNat [assoc comm special(
    id-hook('ACU_NumberOpSymbol,'max)
    op-hook('succSymbol,'s_,'Nat,'NzNat))] .
  op 'maximalAritySet : '`[Module`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] -> '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] [special(
    id-hook('MetaLevelOpSymbol,'metaMaximalAritySet)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'maximalSorts : '`[Module`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] -> '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] [special(
    id-hook('MetaLevelOpSymbol,'metaMaximalSorts)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'mb_:_`[_`]. : 'Term 'Sort 'AttrSet -> 'MembAx [ctor format('d 'd 'd 'd 's
    'd 'd 's 'd)] .
  op 'memo : nil -> '@Attr@ [none] .
  op 'memo : nil -> 'Attr [ctor] .
  op 'memoization : nil -> '@Attr@ [none] .
  op 'message : nil -> '@Attr@ [none] .
  op 'metaApply : '`[Module`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[Substitution?`]
    '`[FindResult`,NatList`,Bound`] -> '`[ResultTriple?`] [special(
    id-hook('MetaLevelOpSymbol,'metaApply)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'metaDisjointUnify : '`[Module`] '`[UnificationProblem`]
    '`[FindResult`,NatList`,Bound`] '`[FindResult`,NatList`,Bound`] ->
    '`[UnificationTriple?`] [special(
    id-hook('MetaLevelOpSymbol,'metaDisjointUnify)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'metaFrewrite : '`[Module`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[FindResult`,NatList`,Bound`]
    '`[FindResult`,NatList`,Bound`] -> '`[ResultPair?`] [special(
    id-hook('MetaLevelOpSymbol,'metaFrewrite)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'metaMatch : '`[Module`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[Condition`]
    '`[FindResult`,NatList`,Bound`] -> '`[Substitution?`] [special(
    id-hook('MetaLevelOpSymbol,'metaMatch)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'metaNarrow : '`[Module`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`]
    '`[FindResult`,NatList`,Bound`] '`[Bool`] '`[FindResult`,NatList`,Bound`]
    -> '`[ResultPair?`] [special(
    id-hook('MetaLevelOpSymbol,'metaNarrow2)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'metaNarrow : '`[Module`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`]
    '`[FindResult`,NatList`,Bound`] '`[FindResult`,NatList`,Bound`] ->
    '`[ResultTriple?`] [special(
    id-hook('MetaLevelOpSymbol,'metaNarrow)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'metaNormalize : '`[Module`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] -> '`[ResultPair?`] [special(
    id-hook('MetaLevelOpSymbol,'metaNormalize)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'metaParse : '`[Module`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] -> '`[ResultPair?`] [
    special(
    id-hook('MetaLevelOpSymbol,'metaParse)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'metaPrettyPrint : '`[Module`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] -> '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] [none] .
  op 'metaPrettyPrint : '`[Module`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[PrintOptionSet`] -> '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] [special(
    id-hook('MetaLevelOpSymbol,'metaPrettyPrint)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'metaReduce : '`[Module`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] -> '`[ResultPair?`] [special(
    id-hook('MetaLevelOpSymbol,'metaReduce)
    op-hook('qidSymbol,'<Qids>,nil,'Qid)
    op-hook('metaTermSymbol,'_`[_`],'Qid 'NeGroundTermList,'GroundTerm)
    op-hook('metaArgSymbol,'_`,_,'NeGroundTermList 'GroundTermList,
    'NeGroundTermList)
    op-hook('assignmentSymbol,'_<-_,'Variable 'Term,'Assignment)
    op-hook('emptySubstitutionSymbol,'none,nil,'Substitution)
    op-hook('substitutionSymbol,'_;_,'Substitution 'Substitution,'Substitution)
    op-hook('holeSymbol,'`[`],nil,'Context)
    op-hook('headerSymbol,'_`{_`},'Qid 'ParameterDeclList,'Header)
    op-hook('parameterDeclSymbol,'_::_,'Sort 'ModuleExpression,'ParameterDecl)
    op-hook('parameterDeclListSymbol,'_`,_,'ParameterDeclList
    'ParameterDeclList,'ParameterDeclList)
    op-hook('protectingSymbol,'protecting_.,'ModuleExpression,'Import)
    op-hook('extendingSymbol,'extending_.,'ModuleExpression,'Import)
    op-hook('includingSymbol,'including_.,'ModuleExpression,'Import)
    op-hook('nilImportListSymbol,'nil,nil,'ImportList)
    op-hook('importListSymbol,'__,'ImportList 'ImportList,'ImportList)
    op-hook('emptySortSetSymbol,'none,nil,'QidSet)
    op-hook('sortSetSymbol,'_;_,'QidSet 'QidSet,'QidSet)
    op-hook('subsortSymbol,'subsort_<_.,'Sort 'Sort,'SubsortDecl)
    op-hook('emptySubsortDeclSetSymbol,'none,nil,'SubsortDeclSet)
    op-hook('subsortDeclSetSymbol,'__,'SubsortDeclSet 'SubsortDeclSet,
    'SubsortDeclSet)
    op-hook('nilQidListSymbol,'nil,nil,'QidList)
    op-hook('qidListSymbol,'__,'QidList 'QidList,'QidList)
    op-hook('succSymbol,'s_,'Nat,'NzNat)
    op-hook('natListSymbol,'__,'NatList 'NatList,'NatList)
    op-hook('unboundedSymbol,'unbounded,nil,'Bound)
    op-hook('stringSymbol,'<Strings>,nil,'Char)
    op-hook('sortRenamingSymbol,'sort_to_,'Qid 'Qid,'Renaming)
    op-hook('opRenamingSymbol,'op_to_`[_`],'Qid 'Qid 'AttrSet,'Renaming)
    op-hook('opRenamingSymbol2,'op_:_->_to_`[_`],'Qid 'TypeList 'Type 'Qid
    'AttrSet,'Renaming)
    op-hook('labelRenamingSymbol,'label_to_,'Qid 'Qid,'Renaming)
    op-hook('renamingSetSymbol,'_`,_,'RenamingSet 'RenamingSet,'RenamingSet)
    op-hook('sumSymbol,'_+_,'ModuleExpression 'ModuleExpression,
    'ModuleExpression)
    op-hook('renamingSymbol,'_*`(_`),'ModuleExpression 'RenamingSet,
    'ModuleExpression)
    op-hook('instantiationSymbol,'_`{_`},'ModuleExpression 'ParameterList,
    'ModuleExpression)
    op-hook('termHookSymbol,'term-hook,'Qid 'Term,'Hook)
    op-hook('hookListSymbol,'__,'HookList 'HookList,'HookList)
    op-hook('idHookSymbol,'id-hook,'Qid 'QidList,'Hook)
    op-hook('opHookSymbol,'op-hook,'Qid 'Qid 'QidList 'Qid,'Hook)
    op-hook('assocSymbol,'assoc,nil,'Attr)
    op-hook('commSymbol,'comm,nil,'Attr)
    op-hook('idemSymbol,'idem,nil,'Attr)
    op-hook('iterSymbol,'iter,nil,'Attr)
    op-hook('idSymbol,'id,'Term,'Attr)
    op-hook('leftIdSymbol,'left-id,'Term,'Attr)
    op-hook('rightIdSymbol,'right-id,'Term,'Attr)
    op-hook('stratSymbol,'strat,'NeNatList,'Attr)
    op-hook('memoSymbol,'memo,nil,'Attr)
    op-hook('precSymbol,'prec,'Nat,'Attr)
    op-hook('gatherSymbol,'gather,'QidList,'Attr)
    op-hook('formatSymbol,'format,'QidList,'Attr)
    op-hook('ctorSymbol,'ctor,nil,'Attr)
    op-hook('frozenSymbol,'frozen,'NeNatList,'Attr)
    op-hook('polySymbol,'poly,'NeNatList,'Attr)
    op-hook('configSymbol,'config,nil,'Attr)
    op-hook('objectSymbol,'object,nil,'Attr)
    op-hook('msgSymbol,'msg,nil,'Attr)
    op-hook('specialSymbol,'special,'NeHookList,'Attr)
    op-hook('labelSymbol,'label,'Qid,'Attr)
    op-hook('metadataSymbol,'metadata,'String,'Attr)
    op-hook('owiseSymbol,'owise,nil,'Attr)
    op-hook('nonexecSymbol,'nonexec,nil,'Attr)
    op-hook('printSymbol,'print,'QidList,'Attr)
    op-hook('emptyAttrSetSymbol,'none,nil,'AttrSet)
    op-hook('attrSetSymbol,'__,'AttrSet 'AttrSet,'AttrSet)
    op-hook('opDeclSymbol,'op_:_->_`[_`].,'Qid 'TypeList 'Type 'AttrSet,
    'OpDecl)
    op-hook('opDeclSetSymbol,'__,'OpDeclSet 'OpDeclSet,'OpDeclSet)
    op-hook('emptyOpDeclSetSymbol,'none,nil,'OpDeclSet)
    op-hook('noConditionSymbol,'nil,nil,'EqCondition)
    op-hook('equalityConditionSymbol,'_=_,'Term 'Term,'EqCondition)
    op-hook('sortTestConditionSymbol,'_:_,'Term 'Sort,'EqCondition)
    op-hook('matchConditionSymbol,'_:=_,'Term 'Term,'EqCondition)
    op-hook('rewriteConditionSymbol,'_=>_,'Term 'Term,'Condition)
    op-hook('conjunctionSymbol,'_/\_,'EqCondition 'EqCondition,'EqCondition)
    op-hook('mbSymbol,'mb_:_`[_`].,'Term 'Sort 'AttrSet,'MembAx)
    op-hook('cmbSymbol,'cmb_:_if_`[_`].,'Term 'Sort 'EqCondition 'AttrSet,
    'MembAx)
    op-hook('emptyMembAxSetSymbol,'none,nil,'MembAxSet)
    op-hook('membAxSetSymbol,'__,'MembAxSet 'MembAxSet,'MembAxSet)
    op-hook('eqSymbol,'eq_=_`[_`].,'Term 'Term 'AttrSet,'Equation)
    op-hook('ceqSymbol,'ceq_=_if_`[_`].,'Term 'Term 'EqCondition 'AttrSet,
    'Equation)
    op-hook('emptyEquationSetSymbol,'none,nil,'EquationSet)
    op-hook('equationSetSymbol,'__,'EquationSet 'EquationSet,'EquationSet)
    op-hook('rlSymbol,'rl_=>_`[_`].,'Term 'Term 'AttrSet,'Rule)
    op-hook('crlSymbol,'crl_=>_if_`[_`].,'Term 'Term 'Condition 'AttrSet,'Rule)
    op-hook('emptyRuleSetSymbol,'none,nil,'RuleSet)
    op-hook('ruleSetSymbol,'__,'RuleSet 'RuleSet,'RuleSet)
    op-hook('fmodSymbol,'fmod_is_sorts_.____endfm,'Header 'ImportList 'SortSet
    'SubsortDeclSet 'OpDeclSet 'MembAxSet 'EquationSet,'FModule)
    op-hook('fthSymbol,'fth_is_sorts_.____endfth,'Qid 'ImportList 'SortSet
    'SubsortDeclSet 'OpDeclSet 'MembAxSet 'EquationSet,'FTheory)
    op-hook('modSymbol,'mod_is_sorts_._____endm,'Header 'ImportList 'SortSet
    'SubsortDeclSet 'OpDeclSet 'MembAxSet 'EquationSet 'RuleSet,'SModule)
    op-hook('thSymbol,'th_is_sorts_._____endth,'Qid 'ImportList 'SortSet
    'SubsortDeclSet 'OpDeclSet 'MembAxSet 'EquationSet 'RuleSet,'STheory)
    op-hook('sortMappingSymbol,'sort_to_.,'Sort 'Sort,'SortMapping)
    op-hook('emptySortMappingSetSymbol,'none,nil,'SortMappingSet)
    op-hook('sortMappingSetSymbol,'__,'SortMappingSet 'SortMappingSet,
    'SortMappingSet)
    op-hook('opMappingSymbol,'op_to_.,'Qid 'Qid,'OpMapping)
    op-hook('opSpecificMappingSymbol,'op_:_->_to_.,'Qid 'TypeList 'Type 'Qid,
    'OpMapping)
    op-hook('opTermMappingSymbol,'op_to`term_.,'Term 'Term,'OpMapping)
    op-hook('emptyOpMappingSetSymbol,'none,nil,'OpMappingSet)
    op-hook('opMappingSetSymbol,'__,'OpMappingSet 'OpMappingSet,'OpMappingSet)
    op-hook('viewSymbol,'view_from_to_is__endv,'Header 'ModuleExpression
    'ModuleExpression 'SortMappingSet 'OpMappingSet,'View)
    op-hook('anyTypeSymbol,'anyType,nil,'Type?)
    op-hook('unificandPairSymbol,'_=?_,'Term 'Term,'UnificandPair)
    op-hook('unificationConjunctionSymbol,'_/\_,'UnificationProblem
    'UnificationProblem,'UnificationProblem)
    op-hook('resultPairSymbol,'`{_`,_`},'Term 'Type,'ResultPair)
    op-hook('resultTripleSymbol,'`{_`,_`,_`},'Term 'Type 'Substitution,
    'ResultTriple)
    op-hook('result4TupleSymbol,'`{_`,_`,_`,_`},'Term 'Type 'Substitution
    'Context,'Result4Tuple)
    op-hook('matchPairSymbol,'`{_`,_`},'Substitution 'Context,'MatchPair)
    op-hook('unificationPairSymbol,'`{_`,_`},'Substitution 'Nat,
    'UnificationPair)
    op-hook('unificationTripleSymbol,'`{_`,_`,_`},'Substitution 'Substitution
    'Nat,'UnificationTriple)
    op-hook('traceStepSymbol,'`{_`,_`,_`},'Term 'Type 'Rule,'TraceStep)
    op-hook('nilTraceSymbol,'nil,nil,'Trace)
    op-hook('traceSymbol,'__,'Trace 'Trace,'Trace)
    op-hook('noParseSymbol,'noParse,'Nat,'ResultPair?)
    op-hook('ambiguitySymbol,'ambiguity,'ResultPair 'ResultPair,'ResultPair?)
    op-hook('failure2Symbol,'failure,nil,'ResultPair?)
    op-hook('failure3Symbol,'failure,nil,'ResultTriple?)
    op-hook('failure4Symbol,'failure,nil,'Result4Tuple?)
    op-hook('noUnifierPairSymbol,'noUnifier,nil,'UnificationPair?)
    op-hook('noUnifierTripleSymbol,'noUnifier,nil,'UnificationTriple?)
    op-hook('noMatchSubstSymbol,'noMatch,nil,'Substitution?)
    op-hook('noMatchPairSymbol,'noMatch,nil,'MatchPair?)
    op-hook('failureTraceSymbol,'failure,nil,'Trace?)
    op-hook('mixfixSymbol,'mixfix,nil,'PrintOption)
    op-hook('withParensSymbol,'with-parens,nil,'PrintOption)
    op-hook('flatSymbol,'flat,nil,'PrintOption)
    op-hook('formatPrintOptionSymbol,'format,nil,'PrintOption)
    op-hook('numberSymbol,'number,nil,'PrintOption)
    op-hook('ratSymbol,'rat,nil,'PrintOption)
    op-hook('emptyPrintOptionSetSymbol,'none,nil,'PrintOptionSet)
    op-hook('printOptionSetSymbol,'__,'PrintOptionSet 'PrintOptionSet,
    'PrintOptionSet)
    term-hook('trueTerm,'true.Bool)
    term-hook('falseTerm,'false.Bool))] .
  op 'metaRewrite : '`[Module`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[FindResult`,NatList`,Bound`] ->
    '`[ResultPair?`] [special(
    id-hook('MetaLevelOpSymbol,'metaRewrite)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'metaSearch : '`[Module`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[Condition`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[FindResult`,NatList`,Bound`] '`[FindResult`,NatList`,Bound`] ->
    '`[ResultTriple?`] [special(
    id-hook('MetaLevelOpSymbol,'metaSearch)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'metaSearchPath : '`[Module`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[Condition`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[FindResult`,NatList`,Bound`] '`[FindResult`,NatList`,Bound`] ->
    '`[Trace?`] [special(
    id-hook('MetaLevelOpSymbol,'metaSearchPath)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'metaUnify : '`[Module`] '`[UnificationProblem`]
    '`[FindResult`,NatList`,Bound`] '`[FindResult`,NatList`,Bound`] ->
    '`[UnificationPair?`] [special(
    id-hook('MetaLevelOpSymbol,'metaUnify)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'metaXapply : '`[Module`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[Substitution?`]
    '`[FindResult`,NatList`,Bound`] '`[FindResult`,NatList`,Bound`]
    '`[FindResult`,NatList`,Bound`] -> '`[Result4Tuple?`] [special(
    id-hook('MetaLevelOpSymbol,'metaXapply)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'metaXmatch : '`[Module`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[Condition`]
    '`[FindResult`,NatList`,Bound`] '`[FindResult`,NatList`,Bound`]
    '`[FindResult`,NatList`,Bound`] -> '`[MatchPair?`] [special(
    id-hook('MetaLevelOpSymbol,'metaXmatch)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'metadata : 'String -> 'Attr [ctor] .
  op 'metadata_ : '@Token@ -> '@Attr@ [none] .
  op 'min : 'Nat 'Nat -> 'Nat [assoc comm special(
    id-hook('ACU_NumberOpSymbol,'min)
    op-hook('succSymbol,'s_,'Nat,'NzNat))] .
  op 'min : 'NzNat 'NzNat -> 'NzNat [assoc comm special(
    id-hook('ACU_NumberOpSymbol,'min)
    op-hook('succSymbol,'s_,'Nat,'NzNat))] .
  op 'minimalSorts : '`[Module`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] -> '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] [special(
    id-hook('MetaLevelOpSymbol,'metaMinimalSorts)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'mixfix : nil -> 'PrintOption [ctor] .
  op 'modExp : '`[Nat`] '`[Nat`] '`[Nat`] -> '`[Nat`] [special(
    id-hook('NumberOpSymbol,'modExp)
    op-hook('succSymbol,'s_,'Nat,'NzNat))] .
  op 'mod_is_sorts_._____endm : 'Header 'ImportList 'SortSet 'SubsortDeclSet
    'OpDeclSet 'MembAxSet 'EquationSet 'RuleSet -> 'SModule [ctor gather('& '&
    '& '& '& '& '& '&)format('d 'd 's 'n++i 'ni 'd 'd 'ni 'ni 'ni 'ni 'ni 'n--i
    'd)] .
  op 'msg : nil -> '@Attr@ [none] .
  op 'msg : nil -> 'Attr [ctor] .
  op 'msg_:_->_to_ : '@Token@ '@TypeList@ '@Type@ '@Token@ -> '@Map@ [none] .
  op 'msg_:`->_to_ : '@Token@ '@Type@ '@Token@ -> '@Map@ [none] .
  op 'msg_to_ : '@Token@ '@Token@ -> '@Map@ [none] .
  op 'neTokenList : 'QidList -> '@NeTokenList@ [special(
    id-hook('Bubble,'1 '-1 '`( '`))
    op-hook('qidListSymbol,'__,'QidList 'QidList,'QidList)
    op-hook('qidSymbol,'<Qids>,nil,'Qid)
    id-hook('Exclude,'.))] .
  op 'nil : nil -> 'EqCondition [ctor] .
  op 'nil : nil -> 'HookList [ctor] .
  op 'nil : nil -> 'ImportList [ctor] .
  op 'nil : nil -> 'NatList [ctor] .
  op 'nil : nil -> 'ParameterDeclList [ctor] .
  op 'nil : nil -> 'QidList [ctor] .
  op 'nil : nil -> 'Trace [ctor] .
  op 'nil : nil -> 'TypeList [ctor] .
  op 'noMatch : nil -> 'MatchPair? [ctor] .
  op 'noMatch : nil -> 'Substitution? [ctor] .
  op 'noParse : 'Nat -> 'ResultPair? [ctor] .
  op 'noUnifier : nil -> 'UnificationPair? [ctor] .
  op 'noUnifier : nil -> 'UnificationTriple? [ctor] .
  op 'none : nil -> 'AttrSet [ctor] .
  op 'none : nil -> 'EmptyTypeSet [ctor] .
  op 'none : nil -> 'EquationSet [ctor] .
  op 'none : nil -> 'MembAxSet [ctor] .
  op 'none : nil -> 'OpDeclSet [ctor] .
  op 'none : nil -> 'OpMappingSet [ctor] .
  op 'none : nil -> 'PrintOptionSet [ctor] .
  op 'none : nil -> 'QidSet [ctor] .
  op 'none : nil -> 'RuleSet [ctor] .
  op 'none : nil -> 'SortMappingSet [ctor] .
  op 'none : nil -> 'SubsortDeclSet [ctor] .
  op 'none : nil -> 'Substitution [ctor] .
  op 'nonexec : nil -> 'Attr [ctor] .
  op 'notFound : nil -> 'FindResult [ctor] .
  op 'not_ : 'Bool -> 'Bool [prec(53)] .
  op 'number : nil -> 'PrintOption [ctor] .
  op 'object : nil -> '@Attr@ [none] .
  op 'object : nil -> 'Attr [ctor] .
  op 'occurs : 'Nat 'NatList -> 'Bool [none] .
  op 'occurs : 'Qid 'QidList -> 'Bool [none] .
  op 'op-hook : 'Qid 'Qid 'QidList 'Qid -> 'Hook [ctor format('nssss 'd)] .
  op 'op-hook_`(_:_->_`) : '@Token@ '@Token@ '@NeTokenList@ '@Token@ -> '@Hook@
    [none] .
  op 'op-hook_`(_:_~>_`) : '@Token@ '@Token@ '@NeTokenList@ '@Token@ -> '@Hook@
    [none] .
  op 'op-hook_`(_:`->_`) : '@Token@ '@Token@ '@Token@ -> '@Hook@ [none] .
  op 'op-hook_`(_:`~>_`) : '@Token@ '@Token@ '@Token@ -> '@Hook@ [none] .
  op 'op_:_->_`[_`]. : 'Qid 'TypeList 'Type 'AttrSet -> 'OpDecl [ctor format('d
    'd 'd 'd 'd 'd 's 'd 'd 's 'd)] .
  op 'op_:_->_to_ : '@Token@ '@TypeList@ '@Type@ '@Token@ -> '@Map@ [none] .
  op 'op_:_->_to_. : 'Qid 'TypeList 'Type 'Qid -> 'OpMapping [ctor] .
  op 'op_:_->_to_`[_`] : '@Token@ '@TypeList@ '@Type@ '@Token@ '@AttrList@ ->
    '@Map@ [none] .
  op 'op_:_->_to_`[_`] : 'Qid 'TypeList 'Type 'Qid 'AttrSet -> 'Renaming [ctor
    format('d 'd 'd 'd 'd 'd 'd 'd 's 'd 'd 'd)] .
  op 'op_:_~>_to_ : '@Token@ '@TypeList@ '@Type@ '@Token@ -> '@Map@ [none] .
  op 'op_:_~>_to_`[_`] : '@Token@ '@TypeList@ '@Type@ '@Token@ '@AttrList@ ->
    '@Map@ [none] .
  op 'op_:`->_to_ : '@Token@ '@Type@ '@Token@ -> '@Map@ [none] .
  op 'op_:`->_to_`[_`] : '@Token@ '@Type@ '@Token@ '@AttrList@ -> '@Map@ [none]
    .
  op 'op_:`~>_to_ : '@Token@ '@Type@ '@Token@ -> '@Map@ [none] .
  op 'op_:`~>_to_`[_`] : '@Token@ '@Type@ '@Token@ '@AttrList@ -> '@Map@ [none]
    .
  op 'op_to_ : '@Token@ '@Token@ -> '@Map@ [none] .
  op 'op_to_. : 'Qid 'Qid -> 'OpMapping [ctor] .
  op 'op_to_`[_`] : '@Token@ '@Token@ '@AttrList@ -> '@Map@ [none] .
  op 'op_to_`[_`] : 'Qid 'Qid 'AttrSet -> 'Renaming [ctor format('d 'd 'd 'd 's
    'd 'd 'd)] .
  op 'op_to`term_. : 'Term 'Term -> 'OpMapping [ctor] .
  op 'owise : nil -> 'Attr [ctor] .
  op 'poly : 'NeNatList -> 'Attr [ctor] .
  op 'poly`(_`) : '@NeTokenList@ -> '@AttrList@ [none] .
  op 'prec : 'Nat -> 'Attr [ctor] .
  op 'prec_ : '@Token@ -> '@Attr@ [none] .
  op 'precedence_ : '@Token@ -> '@Attr@ [none] .
  op 'print : 'QidList -> 'Attr [ctor] .
  op 'protecting_. : 'ModuleExpression -> 'Import [ctor] .
  op 'qid : '`[String`] -> '`[Qid`] [special(
    id-hook('QuotedIdentifierOpSymbol,'qid)
    op-hook('quotedIdentifierSymbol,'<Qids>,nil,'Qid)
    op-hook('stringSymbol,'<Strings>,nil,'Char))] .
  op 'rat : nil -> 'PrintOption [ctor] .
  op 'reverse : 'NatList -> 'NatList [none] .
  op 'reverse : 'NeNatList -> 'NeNatList [none] .
  op 'reverse : 'NeQidList -> 'NeQidList [none] .
  op 'reverse : 'QidList -> 'QidList [none] .
  op 'rfind : 'String 'String 'Nat -> 'FindResult [special(
    id-hook('StringOpSymbol,'rfind)
    op-hook('stringSymbol,'<Strings>,nil,'Char)
    op-hook('succSymbol,'s_,'Nat,'NzNat)
    term-hook('notFoundTerm,'notFound.FindResult))] .
  op 'right-id : 'Term -> 'Attr [ctor] .
  op 'right`id:_ : '@Bubble@ -> '@Attr@ [none] .
  op 'right`identity:_ : '@Bubble@ -> '@Attr@ [none] .
  op 'rl_=>_`[_`]. : 'Term 'Term 'AttrSet -> 'Rule [ctor format('d 'd 'd 'd 's
    'd 'd 's 'd)] .
  op 's_ : 'Nat -> 'NzNat [iter ctor special(
    id-hook('SuccSymbol,nil)
    term-hook('zeroTerm,'0.Zero))] .
  op 'sameKind : '`[Module`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] -> '`[Bool`] [special(
    id-hook('MetaLevelOpSymbol,'metaSameKind)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'sd : 'Nat 'Nat -> 'Nat [comm special(
    id-hook('CUI_NumberOpSymbol,'sd)
    op-hook('succSymbol,'s_,'Nat,'NzNat))] .
  op 'size : 'NatList -> 'Nat [none] .
  op 'size : 'NeNatList -> 'NzNat [none] .
  op 'size : 'NeQidList -> 'NzNat [none] .
  op 'size : 'QidList -> 'Nat [none] .
  op 'sortLeq : '`[Module`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] -> '`[Bool`] [special(
    id-hook('MetaLevelOpSymbol,'metaSortLeq)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'sortToken : 'Qid -> '@SortToken@ [special(
    id-hook('Bubble,'1 '1)
    op-hook('qidSymbol,'<Qids>,nil,'Qid)
    id-hook('Exclude,'`[ '`] '< 'to '`, '. '`( '`) '`{ '`} ': 'ditto
    'precedence 'prec 'gather 'assoc 'associative 'comm 'commutative 'ctor
    'constructor 'id: 'strat 'strategy 'poly 'memo 'memoization 'iter 'frozen
    'config 'object 'msg 'metadata 'nonexec 'variant))] .
  op 'sort_to_ : '@Sort@ '@Sort@ -> '@Map@ [none] .
  op 'sort_to_ : 'Qid 'Qid -> 'Renaming [ctor] .
  op 'sort_to_. : 'Sort 'Sort -> 'SortMapping [ctor] .
  op 'special : 'NeHookList -> 'Attr [ctor] .
  op 'special`(_`) : '@HookList@ -> '@Attr@ [none] .
  op 'strat : 'NeNatList -> 'Attr [ctor] .
  op 'strat`(_`) : '@NeTokenList@ -> '@AttrList@ [none] .
  op 'strategy`(_`) : '@NeTokenList@ -> '@AttrList@ [none] .
  op 'string : 'Qid -> 'String [special(
    id-hook('QuotedIdentifierOpSymbol,'string)
    op-hook('quotedIdentifierSymbol,'<Qids>,nil,'Qid)
    op-hook('stringSymbol,'<Strings>,nil,'Char))] .
  op 'subsort_<_. : 'Sort 'Sort -> 'SubsortDecl [ctor] .
  op 'substr : 'String 'Nat 'Nat -> 'String [special(
    id-hook('StringOpSymbol,'substr)
    op-hook('stringSymbol,'<Strings>,nil,'Char)
    op-hook('succSymbol,'s_,'Nat,'NzNat))] .
  op 'tail : 'NeNatList -> 'NatList [none] .
  op 'tail : 'NeQidList -> 'QidList [none] .
  op 'term-hook : 'Qid 'Term -> 'Hook [ctor format('nssss 'd)] .
  op 'term-hook_`(_`) : '@Token@ '@Bubble@ -> '@Hook@ [none] .
  op 'th_is_sorts_._____endth : 'Qid 'ImportList 'SortSet 'SubsortDeclSet
    'OpDeclSet 'MembAxSet 'EquationSet 'RuleSet -> 'STheory [ctor gather('& '&
    '& '& '& '& '& '&)format('d 'd 'd 'n++i 'ni 'd 'd 'ni 'ni 'ni 'ni 'ni 'n--i
    'd)] .
  op 'token : 'Qid -> '@Token@ [special(
    id-hook('Bubble,'1 '1)
    op-hook('qidSymbol,'<Qids>,nil,'Qid))] .
  op 'true : nil -> 'Bool [ctor special(
    id-hook('SystemTrue,nil))] .
  op 'unbounded : nil -> 'Bound [ctor] .
  op 'union : 'NeQidSet 'QidSet -> 'NeQidSet [none] .
  op 'union : 'QidSet 'NeQidSet -> 'NeQidSet [none] .
  op 'union : 'QidSet 'QidSet -> 'QidSet [none] .
  op 'upEqs : '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[Bool`] -> '`[EquationSet`] [special(
    id-hook('MetaLevelOpSymbol,'metaUpEqs)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'upImports : '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] -> '`[ImportList`] [special(
    id-hook('MetaLevelOpSymbol,'metaUpImports)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'upMbs : '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[Bool`] -> '`[MembAxSet`] [special(
    id-hook('MetaLevelOpSymbol,'metaUpMbs)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'upModule : '@ModExp@ -> 'Module [none] .
  op 'upModule : '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[Bool`] -> '`[Module`] [special(
    id-hook('MetaLevelOpSymbol,'metaUpModule)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'upOpDecls : '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[Bool`] -> '`[OpDeclSet`] [special(
    id-hook('MetaLevelOpSymbol,'metaUpOpDecls)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'upRls : '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[Bool`] -> '`[RuleSet`] [special(
    id-hook('MetaLevelOpSymbol,'metaUpRls)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'upSorts : '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[Bool`] -> '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] [special(
    id-hook('MetaLevelOpSymbol,'metaUpSorts)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'upSubsortDecls : '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] '`[Bool`] -> '`[SubsortDeclSet`] [special(
    id-hook('MetaLevelOpSymbol,'metaUpSubsortDecls)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'upTerm : 'Universal -> 'Term [poly(1)special(
    id-hook('MetaLevelOpSymbol,'metaUpTerm)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'upTerm : '@ModExp@ '@Bubble@ -> 'Term [none] .
  op 'upView : '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] -> '`[View`] [special(
    id-hook('MetaLevelOpSymbol,'metaUpView)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'viewToken : 'Qid -> '@ViewToken@ [special(
    id-hook('Bubble,'1 '1)
    op-hook('qidSymbol,'<Qids>,nil,'Qid))] .
  op 'view_from_to_is__endv : 'Header 'ModuleExpression 'ModuleExpression
    'SortMappingSet 'OpMappingSet -> 'View [ctor gather('& '& '& '& '&)format(
    'd 'd 'd 'd 'd 'd 'd 'n++i 'ni 'n--i 'd)] .
  op 'wellFormed : 'Module -> 'Bool [special(
    id-hook('MetaLevelOpSymbol,'metaWellFormedModule)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'wellFormed : '`[Module`] '`[QidSet`,QidList`,TypeListSet`,GTermList`,ParameterList`,Type?`,ModuleExpression`,Header`] -> '`[Bool`] [special(
    id-hook('MetaLevelOpSymbol,'metaWellFormedTerm)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'wellFormed : '`[Module`] '`[Substitution?`] -> '`[Bool`] [special(
    id-hook('MetaLevelOpSymbol,'metaWellFormedSubstitution)
    op-hook('shareWith,'metaReduce,'Module 'QidSet,'ResultPair?))] .
  op 'with-parens : nil -> 'PrintOption [ctor] .
  op '|_| : 'NeQidSet -> 'NzNat [none] .
  op '|_| : 'QidSet -> 'Nat [none] .
  none
  eq '$card['none.QidSet,'C:Nat]= 'C:Nat [none] .
  eq '$card['_;_['E:Qid,'S:QidSet],'C:Nat]= '$card['S:QidSet,'_+_['C:Nat,'s_[
    '0.Zero]]] [owise] .
  eq '$card['_;_['N:NeQidSet,'N:NeQidSet,'S:QidSet],'C:Nat]= '$card['_;_[
    'N:NeQidSet,'S:QidSet],'C:Nat] [none] .
  eq '$diff['none.QidSet,'S':QidSet,'A:QidSet]= 'A:QidSet [none] .
  eq '$diff['_;_['E:Qid,'S:QidSet],'S':QidSet,'A:QidSet]= '$diff['S:QidSet,
    'S':QidSet,'if_then_else_fi['_in_['E:Qid,'S':QidSet],'A:QidSet,'_;_['E:Qid,
    'A:QidSet]]] [none] .
  eq '$intersect['none.QidSet,'S':QidSet,'A:QidSet]= 'A:QidSet [none] .
  eq '$intersect['_;_['E:Qid,'S:QidSet],'S':QidSet,'A:QidSet]= '$intersect[
    'S:QidSet,'S':QidSet,'if_then_else_fi['_in_['E:Qid,'S':QidSet],'_;_['E:Qid,
    'A:QidSet],'A:QidSet]] [none] .
  eq '$reverse['nil.NatList,'A:NatList]= 'A:NatList [none] .
  eq '$reverse['nil.QidList,'A:QidList]= 'A:QidList [none] .
  eq '$reverse['__['E:Nat,'L:NatList],'A:NatList]= '$reverse['L:NatList,'__[
    'E:Nat,'A:NatList]] [none] .
  eq '$reverse['__['E:Qid,'L:QidList],'A:QidList]= '$reverse['L:QidList,'__[
    'E:Qid,'A:QidList]] [none] .
  eq '$size['nil.NatList,'C:Nat]= 'C:Nat [none] .
  eq '$size['nil.QidList,'C:Nat]= 'C:Nat [none] .
  eq '$size['__['E:Nat,'L:NatList],'C:Nat]= '$size['L:NatList,'_+_['C:Nat,'s_[
    '0.Zero]]] [none] .
  eq '$size['__['E:Qid,'L:QidList],'C:Nat]= '$size['L:QidList,'_+_['C:Nat,'s_[
    '0.Zero]]] [none] .
  eq '_;_['A:Assignment,'A:Assignment]= 'A:Assignment [none] .
  eq '_;_['N:NeQidSet,'N:NeQidSet]= 'N:NeQidSet [none] .
  eq '_;_['T:TypeList,'T:TypeList]= 'T:TypeList [none] .
  eq '_\_['S:QidSet,'N:NeQidSet]= '$diff['S:QidSet,'N:NeQidSet,'none.QidSet] [
    none] .
  eq '_\_['S:QidSet,'none.QidSet]= 'S:QidSet [none] .
  eq '__['A:Attr,'A:Attr]= 'A:Attr [none] .
  eq '__['E:Equation,'E:Equation]= 'E:Equation [none] .
  eq '__['M:MembAx,'M:MembAx]= 'M:MembAx [none] .
  eq '__['O:OpDecl,'O:OpDecl]= 'O:OpDecl [none] .
  eq '__['O:OpMapping,'O:OpMapping]= 'O:OpMapping [none] .
  eq '__['R:Rule,'R:Rule]= 'R:Rule [none] .
  eq '__['S:SortMapping,'S:SortMapping]= 'S:SortMapping [none] .
  eq '__['S:SubsortDecl,'S:SubsortDecl]= 'S:SubsortDecl [none] .
  eq '_and-then_['false.Bool,'B:`[Bool`]]= 'false.Bool [none] .
  eq '_and-then_['true.Bool,'B:`[Bool`]]= 'B:`[Bool`] [none] .
  eq '_and_['A:Bool,'A:Bool]= 'A:Bool [none] .
  eq '_and_['A:Bool,'_xor_['B:Bool,'C:Bool]]= '_xor_['_and_['A:Bool,'B:Bool],
    '_and_['A:Bool,'C:Bool]] [none] .
  eq '_and_['false.Bool,'A:Bool]= 'false.Bool [none] .
  eq '_and_['true.Bool,'A:Bool]= 'A:Bool [none] .
  eq '_implies_['A:Bool,'B:Bool]= 'not_['_xor_['A:Bool,'_and_['A:Bool,
    'B:Bool]]] [none] .
  eq '_in_['E:Qid,'S:QidSet]= 'false.Bool [owise] .
  eq '_in_['E:Qid,'_;_['E:Qid,'S:QidSet]]= 'true.Bool [none] .
  eq '_or-else_['false.Bool,'B:`[Bool`]]= 'B:`[Bool`] [none] .
  eq '_or-else_['true.Bool,'B:`[Bool`]]= 'true.Bool [none] .
  eq '_or_['A:Bool,'B:Bool]= '_xor_['_and_['A:Bool,'B:Bool],'_xor_['A:Bool,
    'B:Bool]] [none] .
  eq '_psubset_['S:QidSet,'S':QidSet]= '_and-then_['_=/=_['S:QidSet,
    'S':QidSet],'_subset_['S:QidSet,'S':QidSet]] [none] .
  eq '_subset_['none.QidSet,'S':QidSet]= 'true.Bool [none] .
  eq '_subset_['_;_['E:Qid,'S:QidSet],'S':QidSet]= '_and-then_['_in_['E:Qid,
    'S':QidSet],'_subset_['S:QidSet,'S':QidSet]] [none] .
  eq '_xor_['A:Bool,'A:Bool]= 'false.Bool [none] .
  eq '_xor_['false.Bool,'A:Bool]= 'A:Bool [none] .
  eq '`[_`]['Q:Qid]= 'th_is_sorts_._____endth['Q:Qid,'including_.['Q:Qid],
    'none.EmptyTypeSet,'none.SubsortDeclSet,'none.OpDeclSet,'none.MembAxSet,
    'none.EquationSet,'none.RuleSet] [none] .
  eq 'append['A:NatList,'L:NatList]= '__['A:NatList,'L:NatList] [none] .
  eq 'append['A:QidList,'L:QidList]= '__['A:QidList,'L:QidList] [none] .
  eq 'delete['E:Qid,'S:QidSet]= 'S:QidSet [owise] .
  eq 'delete['E:Qid,'_;_['E:Qid,'S:QidSet]]= 'delete['E:Qid,'S:QidSet] [none] .
  eq 'front['__['L:NatList,'E:Nat]]= 'L:NatList [none] .
  eq 'front['__['L:QidList,'E:Qid]]= 'L:QidList [none] .
  eq 'getContext['`{_`,_`,_`,_`}['T:Term,'T:Type,'S:Substitution,'C:Context]]=
    'C:Context [none] .
  eq 'getContext['`{_`,_`}['S:Substitution,'C:Context]]= 'C:Context [none] .
  eq 'getEqs['fmod_is_sorts_.____endfm['H:Header,'IL:ImportList,'SS:SortSet,
    'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,'EQS:EquationSet]]=
    'EQS:EquationSet [none] .
  eq 'getEqs['fth_is_sorts_.____endfth['Q:Qid,'IL:ImportList,'SS:SortSet,
    'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,'EQS:EquationSet]]=
    'EQS:EquationSet [none] .
  eq 'getEqs['mod_is_sorts_._____endm['H:Header,'IL:ImportList,'SS:SortSet,
    'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,'EQS:EquationSet,
    'RLS:RuleSet]]= 'EQS:EquationSet [none] .
  eq 'getEqs['th_is_sorts_._____endth['Q:Qid,'IL:ImportList,'SS:SortSet,
    'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,'EQS:EquationSet,
    'RLS:RuleSet]]= 'EQS:EquationSet [none] .
  eq 'getFrom['view_from_to_is__endv['Q:Qid,'ME:ModuleExpression,
    'ME':ModuleExpression,'SMS:SortMappingSet,'OMS:OpMappingSet]]=
    'ME:ModuleExpression [none] .
  eq 'getImports['fmod_is_sorts_.____endfm['H:Header,'IL:ImportList,
    'SS:SortSet,'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,
    'EQS:EquationSet]]= 'IL:ImportList [none] .
  eq 'getImports['fth_is_sorts_.____endfth['Q:Qid,'IL:ImportList,'SS:SortSet,
    'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,'EQS:EquationSet]]=
    'IL:ImportList [none] .
  eq 'getImports['mod_is_sorts_._____endm['H:Header,'IL:ImportList,'SS:SortSet,
    'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,'EQS:EquationSet,
    'RLS:RuleSet]]= 'IL:ImportList [none] .
  eq 'getImports['th_is_sorts_._____endth['Q:Qid,'IL:ImportList,'SS:SortSet,
    'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,'EQS:EquationSet,
    'RLS:RuleSet]]= 'IL:ImportList [none] .
  eq 'getMbs['fmod_is_sorts_.____endfm['H:Header,'IL:ImportList,'SS:SortSet,
    'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,'EQS:EquationSet]]=
    'MAS:MembAxSet [none] .
  eq 'getMbs['fth_is_sorts_.____endfth['Q:Qid,'IL:ImportList,'SS:SortSet,
    'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,'EQS:EquationSet]]=
    'MAS:MembAxSet [none] .
  eq 'getMbs['mod_is_sorts_._____endm['H:Header,'IL:ImportList,'SS:SortSet,
    'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,'EQS:EquationSet,
    'RLS:RuleSet]]= 'MAS:MembAxSet [none] .
  eq 'getMbs['th_is_sorts_._____endth['Q:Qid,'IL:ImportList,'SS:SortSet,
    'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,'EQS:EquationSet,
    'RLS:RuleSet]]= 'MAS:MembAxSet [none] .
  eq 'getName['C:Constant]= 'qid['substr['string['C:Constant],'0.Zero,'rfind[
    'string['C:Constant],'".".Char,'length['string['C:Constant]]]]] [none] .
  eq 'getName['V:Variable]= 'qid['substr['string['V:Variable],'0.Zero,'rfind[
    'string['V:Variable],'":".Char,'length['string['V:Variable]]]]] [none] .
  eq 'getName['fmod_is_sorts_.____endfm['Q:Qid,'IL:ImportList,'SS:SortSet,
    'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,'EQS:EquationSet]]=
    'Q:Qid [none] .
  eq 'getName['fmod_is_sorts_.____endfm['_`{_`}['Q:Qid,'PDL:ParameterDeclList],
    'IL:ImportList,'SS:SortSet,'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,
    'MAS:MembAxSet,'EQS:EquationSet]]= 'Q:Qid [none] .
  eq 'getName['fth_is_sorts_.____endfth['Q:Qid,'IL:ImportList,'SS:SortSet,
    'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,'EQS:EquationSet]]=
    'Q:Qid [none] .
  eq 'getName['mod_is_sorts_._____endm['Q:Qid,'IL:ImportList,'SS:SortSet,
    'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,'EQS:EquationSet,
    'RLS:RuleSet]]= 'Q:Qid [none] .
  eq 'getName['mod_is_sorts_._____endm['_`{_`}['Q:Qid,'PDL:ParameterDeclList],
    'IL:ImportList,'SS:SortSet,'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,
    'MAS:MembAxSet,'EQS:EquationSet,'RLS:RuleSet]]= 'Q:Qid [none] .
  eq 'getName['th_is_sorts_._____endth['Q:Qid,'IL:ImportList,'SS:SortSet,
    'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,'EQS:EquationSet,
    'RLS:RuleSet]]= 'Q:Qid [none] .
  eq 'getName['view_from_to_is__endv['Q:Qid,'ME:ModuleExpression,
    'ME':ModuleExpression,'SMS:SortMappingSet,'OMS:OpMappingSet]]= 'Q:Qid [
    none] .
  eq 'getOpMappings['view_from_to_is__endv['Q:Qid,'ME:ModuleExpression,
    'ME':ModuleExpression,'SMS:SortMappingSet,'OMS:OpMappingSet]]=
    'OMS:OpMappingSet [none] .
  eq 'getOps['fmod_is_sorts_.____endfm['H:Header,'IL:ImportList,'SS:SortSet,
    'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,'EQS:EquationSet]]=
    'OPDS:OpDeclSet [none] .
  eq 'getOps['fth_is_sorts_.____endfth['Q:Qid,'IL:ImportList,'SS:SortSet,
    'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,'EQS:EquationSet]]=
    'OPDS:OpDeclSet [none] .
  eq 'getOps['mod_is_sorts_._____endm['H:Header,'IL:ImportList,'SS:SortSet,
    'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,'EQS:EquationSet,
    'RLS:RuleSet]]= 'OPDS:OpDeclSet [none] .
  eq 'getOps['th_is_sorts_._____endth['Q:Qid,'IL:ImportList,'SS:SortSet,
    'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,'EQS:EquationSet,
    'RLS:RuleSet]]= 'OPDS:OpDeclSet [none] .
  eq 'getRls['fmod_is_sorts_.____endfm['H:Header,'IL:ImportList,'SS:SortSet,
    'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,'EQS:EquationSet]]=
    'none.RuleSet [none] .
  eq 'getRls['fth_is_sorts_.____endfth['Q:Qid,'IL:ImportList,'SS:SortSet,
    'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,'EQS:EquationSet]]=
    'none.RuleSet [none] .
  eq 'getRls['mod_is_sorts_._____endm['H:Header,'IL:ImportList,'SS:SortSet,
    'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,'EQS:EquationSet,
    'RLS:RuleSet]]= 'RLS:RuleSet [none] .
  eq 'getRls['th_is_sorts_._____endth['Q:Qid,'IL:ImportList,'SS:SortSet,
    'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,'EQS:EquationSet,
    'RLS:RuleSet]]= 'RLS:RuleSet [none] .
  eq 'getSortMappings['view_from_to_is__endv['Q:Qid,'ME:ModuleExpression,
    'ME':ModuleExpression,'SMS:SortMappingSet,'OMS:OpMappingSet]]=
    'SMS:SortMappingSet [none] .
  eq 'getSorts['fmod_is_sorts_.____endfm['H:Header,'IL:ImportList,'SS:SortSet,
    'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,'EQS:EquationSet]]=
    'SS:SortSet [none] .
  eq 'getSorts['fth_is_sorts_.____endfth['Q:Qid,'IL:ImportList,'SS:SortSet,
    'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,'EQS:EquationSet]]=
    'SS:SortSet [none] .
  eq 'getSorts['mod_is_sorts_._____endm['H:Header,'IL:ImportList,'SS:SortSet,
    'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,'EQS:EquationSet,
    'RLS:RuleSet]]= 'SS:SortSet [none] .
  eq 'getSorts['th_is_sorts_._____endth['Q:Qid,'IL:ImportList,'SS:SortSet,
    'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,'EQS:EquationSet,
    'RLS:RuleSet]]= 'SS:SortSet [none] .
  eq 'getSubsorts['fmod_is_sorts_.____endfm['H:Header,'IL:ImportList,
    'SS:SortSet,'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,
    'EQS:EquationSet]]= 'SSDS:SubsortDeclSet [none] .
  eq 'getSubsorts['fth_is_sorts_.____endfth['Q:Qid,'IL:ImportList,'SS:SortSet,
    'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,'EQS:EquationSet]]=
    'SSDS:SubsortDeclSet [none] .
  eq 'getSubsorts['mod_is_sorts_._____endm['H:Header,'IL:ImportList,
    'SS:SortSet,'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,
    'EQS:EquationSet,'RLS:RuleSet]]= 'SSDS:SubsortDeclSet [none] .
  eq 'getSubsorts['th_is_sorts_._____endth['Q:Qid,'IL:ImportList,'SS:SortSet,
    'SSDS:SubsortDeclSet,'OPDS:OpDeclSet,'MAS:MembAxSet,'EQS:EquationSet,
    'RLS:RuleSet]]= 'SSDS:SubsortDeclSet [none] .
  eq 'getSubstitution['`{_`,_`,_`,_`}['T:Term,'T:Type,'S:Substitution,
    'C:Context]]= 'S:Substitution [none] .
  eq 'getSubstitution['`{_`,_`,_`}['T:Term,'T:Type,'S:Substitution]]=
    'S:Substitution [none] .
  eq 'getSubstitution['`{_`,_`}['S:Substitution,'C:Context]]= 'S:Substitution [
    none] .
  eq 'getTerm['`{_`,_`,_`,_`}['T:Term,'T:Type,'S:Substitution,'C:Context]]=
    'T:Term [none] .
  eq 'getTerm['`{_`,_`,_`}['T:Term,'T:Type,'S:Substitution]]= 'T:Term [none] .
  eq 'getTerm['`{_`,_`}['T:Term,'T:Type]]= 'T:Term [none] .
  eq 'getTo['view_from_to_is__endv['Q:Qid,'ME:ModuleExpression,
    'ME':ModuleExpression,'SMS:SortMappingSet,'OMS:OpMappingSet]]=
    'ME':ModuleExpression [none] .
  eq 'getType['C:Constant]= 'qid['substr['string['C:Constant],'_+_['s_[
    '0.Zero],'rfind['string['C:Constant],'".".Char,'length['string[
    'C:Constant]]]],'length['string['C:Constant]]]] [none] .
  eq 'getType['V:Variable]= 'qid['substr['string['V:Variable],'_+_['s_[
    '0.Zero],'rfind['string['V:Variable],'":".Char,'length['string[
    'V:Variable]]]],'length['string['V:Variable]]]] [none] .
  eq 'getType['`{_`,_`,_`,_`}['T:Term,'T:Type,'S:Substitution,'C:Context]]=
    'T:Type [none] .
  eq 'getType['`{_`,_`,_`}['T:Term,'T:Type,'S:Substitution]]= 'T:Type [none] .
  eq 'getType['`{_`,_`}['T:Term,'T:Type]]= 'T:Type [none] .
  eq 'head['__['E:Nat,'L:NatList]]= 'E:Nat [none] .
  eq 'head['__['E:Qid,'L:QidList]]= 'E:Qid [none] .
  eq 'insert['E:Qid,'S:QidSet]= '_;_['E:Qid,'S:QidSet] [none] .
  eq 'intersection['S:QidSet,'N:NeQidSet]= '$intersect['S:QidSet,'N:NeQidSet,
    'none.QidSet] [none] .
  eq 'intersection['S:QidSet,'none.QidSet]= 'none.QidSet [none] .
  eq 'last['__['L:NatList,'E:Nat]]= 'E:Nat [none] .
  eq 'last['__['L:QidList,'E:Qid]]= 'E:Qid [none] .
  eq 'metaPrettyPrint['M:Module,'T:Term]= 'metaPrettyPrint['M:Module,'T:Term,
    '__['mixfix.PrintOption,'__['flat.PrintOption,'__['format.PrintOption,'__[
    'number.PrintOption,'rat.PrintOption]]]]] [none] .
  eq 'not_['A:Bool]= '_xor_['true.Bool,'A:Bool] [none] .
  eq 'occurs['E:Nat,'nil.NatList]= 'false.Bool [none] .
  eq 'occurs['E:Nat,'__['E':Nat,'L:NatList]]= 'if_then_else_fi['_==_['E:Nat,
    'E':Nat],'true.Bool,'occurs['E:Nat,'L:NatList]] [none] .
  eq 'occurs['E:Qid,'nil.QidList]= 'false.Bool [none] .
  eq 'occurs['E:Qid,'__['E':Qid,'L:QidList]]= 'if_then_else_fi['_==_['E:Qid,
    'E':Qid],'true.Bool,'occurs['E:Qid,'L:QidList]] [none] .
  eq 'reverse['L:NatList]= '$reverse['L:NatList,'nil.NatList] [none] .
  eq 'reverse['L:QidList]= '$reverse['L:QidList,'nil.QidList] [none] .
  eq 'size['L:NatList]= '$size['L:NatList,'0.Zero] [none] .
  eq 'size['L:QidList]= '$size['L:QidList,'0.Zero] [none] .
  eq 'tail['__['E:Nat,'L:NatList]]= 'L:NatList [none] .
  eq 'tail['__['E:Qid,'L:QidList]]= 'L:QidList [none] .
  eq 'union['S:QidSet,'S':QidSet]= '_;_['S:QidSet,'S':QidSet] [none] .
  eq '|_|['S:QidSet]= '$card['S:QidSet,'0.Zero] [none] .
endfm,'getTerm['metaReduce['fmod_is_sorts_.____endfm[''NAT-PLUS.Sort,
    'nil.ImportList,'_;_[''Bool.Sort,''Nat.Sort],'none.SubsortDeclSet,'__[
    'op_:_->_`[_`].[''0.Sort,'nil.TypeList,''Nat.Sort,'none.AttrSet],
    'op_:_->_`[_`].[''_+_.Sort,'__[''Nat.Sort,''Nat.Sort],''Nat.Sort,'__[
    'assoc.Attr,'comm.Attr,'id[''0.Nat.Constant]]],'op_:_->_`[_`].[
    ''_=/=_.Sort,'__[''Universal.Sort,''Universal.Sort],''Bool.Sort,'__['prec[
    's_^51['0.Zero]],'poly['__['s_['0.Zero],'s_^2['0.Zero]]],'special['__[
    'id-hook[''EqualitySymbol.Sort,'nil.TypeList],'term-hook[''equalTerm.Sort,
    ''false.Bool.Constant],'term-hook[''notEqualTerm.Sort,
    ''true.Bool.Constant]]]]],'op_:_->_`[_`].[''_==_.Sort,'__[''Universal.Sort,
    ''Universal.Sort],''Bool.Sort,'__['prec['s_^51['0.Zero]],'poly['__['s_[
    '0.Zero],'s_^2['0.Zero]]],'special['__['id-hook[''EqualitySymbol.Sort,
    'nil.TypeList],'term-hook[''equalTerm.Sort,''true.Bool.Constant],
    'term-hook[''notEqualTerm.Sort,''false.Bool.Constant]]]]],'op_:_->_`[_`].[
    ''_and_.Sort,'__[''Bool.Sort,''Bool.Sort],''Bool.Sort,'__['assoc.Attr,
    'comm.Attr,'prec['s_^55['0.Zero]]]],'op_:_->_`[_`].[''_implies_.Sort,'__[
    ''Bool.Sort,''Bool.Sort],''Bool.Sort,'__['prec['s_^61['0.Zero]],'gather[
    '__[''e.Sort,''E.Sort]]]],'op_:_->_`[_`].[''_or_.Sort,'__[''Bool.Sort,
    ''Bool.Sort],''Bool.Sort,'__['assoc.Attr,'comm.Attr,'prec['s_^59[
    '0.Zero]]]],'op_:_->_`[_`].[''_xor_.Sort,'__[''Bool.Sort,''Bool.Sort],
    ''Bool.Sort,'__['assoc.Attr,'comm.Attr,'prec['s_^57['0.Zero]]]],
    'op_:_->_`[_`].[''false.Sort,'nil.TypeList,''Bool.Sort,'__['ctor.Attr,
    'special['id-hook[''SystemFalse.Sort,'nil.TypeList]]]],'op_:_->_`[_`].[
    ''if_then_else_fi.Sort,'__[''Bool.Sort,''Universal.Sort,''Universal.Sort],
    ''Universal.Sort,'__['poly['__['s_^2['0.Zero],'s_^3['0.Zero],'0.Zero]],
    'special['__['id-hook[''BranchSymbol.Sort,'nil.TypeList],'term-hook[
    ''1.Sort,''true.Bool.Constant],'term-hook[''2.Sort,
    ''false.Bool.Constant]]]]],'op_:_->_`[_`].[''not_.Sort,''Bool.Sort,
    ''Bool.Sort,'prec['s_^53['0.Zero]]],'op_:_->_`[_`].[''s_.Sort,''Nat.Sort,
    ''Nat.Sort,'none.AttrSet],'op_:_->_`[_`].[''true.Sort,'nil.TypeList,
    ''Bool.Sort,'__['ctor.Attr,'special['id-hook[''SystemTrue.Sort,
    'nil.TypeList]]]]],'none.MembAxSet,'__['eq_=_`[_`].['_`[_`][''_+_.Sort,
    '_`,_['_`[_`][''s_.Sort,''N:Nat.Variable],'_`[_`][''s_.Sort,
    ''M:Nat.Variable]]],'_`[_`][''s_.Sort,'_`[_`][''s_.Sort,'_`[_`][''_+_.Sort,
    '_`,_[''N:Nat.Variable,''M:Nat.Variable]]]],'none.AttrSet],'eq_=_`[_`].[
    '_`[_`][''_and_.Sort,'_`,_[''A:Bool.Variable,''A:Bool.Variable]],
    ''A:Bool.Variable,'none.AttrSet],'eq_=_`[_`].['_`[_`][''_and_.Sort,'_`,_[
    ''A:Bool.Variable,'_`[_`][''_xor_.Sort,'_`,_[''B:Bool.Variable,
    ''C:Bool.Variable]]]],'_`[_`][''_xor_.Sort,'_`,_['_`[_`][''_and_.Sort,
    '_`,_[''A:Bool.Variable,''B:Bool.Variable]],'_`[_`][''_and_.Sort,'_`,_[
    ''A:Bool.Variable,''C:Bool.Variable]]]],'none.AttrSet],'eq_=_`[_`].[
    '_`[_`][''_and_.Sort,'_`,_[''false.Bool.Constant,''A:Bool.Variable]],
    ''false.Bool.Constant,'none.AttrSet],'eq_=_`[_`].['_`[_`][''_and_.Sort,
    '_`,_[''true.Bool.Constant,''A:Bool.Variable]],''A:Bool.Variable,
    'none.AttrSet],'eq_=_`[_`].['_`[_`][''_implies_.Sort,'_`,_[
    ''A:Bool.Variable,''B:Bool.Variable]],'_`[_`][''not_.Sort,'_`[_`][
    ''_xor_.Sort,'_`,_[''A:Bool.Variable,'_`[_`][''_and_.Sort,'_`,_[
    ''A:Bool.Variable,''B:Bool.Variable]]]]],'none.AttrSet],'eq_=_`[_`].[
    '_`[_`][''_or_.Sort,'_`,_[''A:Bool.Variable,''B:Bool.Variable]],'_`[_`][
    ''_xor_.Sort,'_`,_['_`[_`][''_and_.Sort,'_`,_[''A:Bool.Variable,
    ''B:Bool.Variable]],'_`[_`][''_xor_.Sort,'_`,_[''A:Bool.Variable,
    ''B:Bool.Variable]]]],'none.AttrSet],'eq_=_`[_`].['_`[_`][''_xor_.Sort,
    '_`,_[''A:Bool.Variable,''A:Bool.Variable]],''false.Bool.Constant,
    'none.AttrSet],'eq_=_`[_`].['_`[_`][''_xor_.Sort,'_`,_[
    ''false.Bool.Constant,''A:Bool.Variable]],''A:Bool.Variable,'none.AttrSet],
    'eq_=_`[_`].['_`[_`][''not_.Sort,''A:Bool.Variable],'_`[_`][''_xor_.Sort,
    '_`,_[''true.Bool.Constant,''A:Bool.Variable]],'none.AttrSet]]],'_`[_`][
    ''_+_.Sort,'_`,_[''0.Nat.Constant,'_`[_`][''s_.Sort,''0.Nat.Constant]]]]]))
result GroundTerm :
  '_`[_`][''s_.Sort,''0.Nat.Constant]

result Nat :
  s 0

result Nat :
  s 0

Introduced module OO-STACK

Introduced theory CELL

Introduced module OO-STACK2

omod OO-STACK2 * (sort Int to Integer, msg _elt_ to element, class Node`{X`} to
    Node`{X`}, class Stack`{X`} to Stack`{X`}, attr Stack`{X`} . first to head)
    {X :: CELL} is
  protecting QID .
  protecting INT * (sort Int to Integer) .
  including CONFIGURATION+ .
  including CONFIGURATION .
  including BOOL .
  subsort Qid < Oid .
  class Node{X}| next : Oid, node : Oid .
  class Stack{X}| head : Oid .
  op null : -> Oid .
  op o : Oid Integer -> Oid .
  msg _pop : Oid -> Msg .
  msg _push_ : Oid Oid -> Msg .
  msg _top_ : Oid Oid -> Msg .
  msg element : Oid X$Elt -> Msg .
  rl < O:Oid : Stack{X}| head : O':Oid > < O':Oid : Node{X}| next : O'':Oid >
    O:Oid pop
    => < O:Oid : Stack{X}| head : O'':Oid > [label pop] .
  rl < O:Oid : Stack{X}| head : O':Oid > < O':Oid : Node{X}| node : O'':Oid > <
    O'':Oid : X$Cell | contents : E:X$Elt > O:Oid top O''':Oid
    => < O:Oid : Stack{X}| none > < O':Oid : Node{X}| none > < O'':Oid : X$Cell
    | none > element(O''':Oid,E:X$Elt) [label top] .
  rl < O:Oid : Stack{X}| head : null > O:Oid push O':Oid
    => < O:Oid : Stack{X}| head : o(O:Oid,0)> < o(O:Oid,0): Node{X}| next :
    null,node : O':Oid > [label push2] .
  rl < O:Oid : Stack{X}| head : o(O:Oid,N:Integer)> O:Oid push O':Oid
    => < O:Oid : Stack{X}| head : o(O:Oid,N:Integer + 1)> < o(O:Oid,N:Integer +
    1): Node{X}| next : o(O:Oid,N:Integer),node : O':Oid > [label push1] .
endom

Advisory: Module CELL redefined.
Introduced theory CELL

Advisory: Module ACCOUNT redefined.
Introduced module ACCOUNT

rewrite in ACCOUNT :
  < 'A-06238 : Account | bal : 2000 > debit('A-06238,1000)
result Object :
  < 'A-06238 : Account | bal : 1000 >

Introduced view Account

rewrite in OO-STACK2`{Account`}*`(sort`Int`to`Integer`,msg_elt_to`element`,class`Account`to`Account`,class`Node`{Account`}to`Node`{Account`}`,class`Stack`{Account`}to`Stack`{Account`}`,attr`Account`.`bal`to`balance`,attr`Stack`{Account`}.`first`to`head`) :
  < 'stack : Stack{Account}| head : null > < 'A-73728 : Account | balance :
    5000 > < 'A-06238 : Account | balance : 2000 > < 'A-28381 : Account |
    balance : 15000 >('stack push 'A-73728)('stack push 'A-06238)('stack push
    'A-28381)('stack top 'A-06238)'stack pop
result Configuration :
  element('A-06238,15000)< 'A-06238 : Account | balance : 2000 > < 'A-28381 :
    Account | balance : 15000 > < 'A-73728 : Account | balance : 5000 > <
    'stack : Stack{Account}| head : o('stack,1)> < o('stack,0): Node{Account}|
    next : null,node : 'A-06238 > < o('stack,1): Node{Account}| next : o(
    'stack,0),node : 'A-73728 >

Introduced module PATH

reduce in PATH :
  b ;(c ; d)
result Path :
  b ;(c ; d)

reduce in PATH :
  length(b ;(c ; d))
result NzNat :
  3

reduce in PATH :
  a ;(b ; c)
result [Path] :
  a ;(b ; c)

reduce in PATH :
  source(a ;(b ; c))
result [Node] :
  source(a ;(b ; c))

reduce in PATH :
  target((a ; b); c)
result [Node] :
  target((a ; b); c)

reduce in PATH :
  length(a ;(b ; c))
result [Nat] :
  length(a ;(b ; c))

*********** trial #1
ceq length(E:Edge ; P:Path) = length(P:Path) + 1 if E:Edge ; P:Path : Path .
*********** solving condition fragment
E:Edge ; P:Path : Path
*********** success for condition fragment
E:Edge ; P:Path : Path
*********** success #1
*********** equation
ceq length(E:Edge ; P:Path) = length(P:Path) + 1 if E:Edge ; P:Path : Path .
length(b ; c)
--->
length(c) + 1
*********** equation
eq length(E:Edge) = 1 .
length(c)
--->
1
*********** equation
(built-in equation for symbol _+_)
1 + 1
--->
2
reduce in PATH :
  length(b ; c)
result NzNat :
  2


        Full Maude 2.6.1 March 20th 2012

reduce in PATH :
  b ;(c ; d)
result Path :
  b ;(c ; d)

Introduced module PERSON-RECORD

reduce in PERSON-RECORD :
  fullName(("John","Smith","Maude Ave"))
result String :
  "John Smith"

Introduced module SET-KIND

Introduced module MAYBE

Error: View Tuple not in database.
Error: View Tuple not in database.
Error: Module SET-KIND{Tuple{X,Y}} not in database.
Introduced module PFUN

==========================================
reduce in QID-RAT-POLY : (1/2 ++ (1/7 'U ^ 2)) (2/3 ('X ^ 2) 'Y ^ 3) ++ (7/5 (
    'Y ^ 2) 'Z ^ 5) .
result Poly{RingToRat,Qid}: (1/3 ('X ^ 2) 'Y ^ 3) ++ (1/5 ('U ^ 2) ('Y ^ 2) 'Z
    ^ 5) ++ (2/21 ('U ^ 2) ('X ^ 2) 'Y ^ 3) ++ (7/10 ('Y ^ 2) 'Z ^ 5)
==========================================
reduce in QID-RAT-POLY : (1/7 'X ^ 2) ++ (2/3 'X ^ 2) .
result Poly{RingToRat,Qid}: 17/21 'X ^ 2

        Full Maude 2.6.1 March 20th 2012

Introduced view RingToRat

reduce in RAT-POLY{Qid}:
  ((2/3('X ^ 2)'Y ^ 3)++(7/5('Y ^ 2)'Z ^ 5))(1/7 'U ^ 2)++ 1/2
result Poly{RingToRat,Qid} :
  (1/3('X ^ 2)'Y ^ 3)++(1/5('U ^ 2)('Y ^ 2)'Z ^ 5)++(2/21('U ^ 2)('X ^ 2)'Y ^
    3)++(7/10('Y ^ 2)'Z ^ 5)

reduce in POWER`[10`]`{Nat`} :
  p5(0,1,2,3,4,5,6,7,8,9)
result NzNat :
  4


        Full Maude 2.6.1 March 20th 2012

Introduced view TOSET

Introduced view IntAsToset

reduce in SET-MAX{IntAsToset}:
  max(5,4,8,4,6,5)
result NzNat :
  8

Introduced module 8-PUZZLE

search in 8-PUZZLE : up left down right initial =>* C:Configuration .

Solution 1
C:Configuration --> <(1,1): Tile | value : 7 > <(1,2): Tile | value : 8 > <(1,
    3): Tile | value : 1 > <(2,1): Tile | value : 6 > <(2,2): Tile | value :
    blank > <(2,3): Tile | value : 2 > <(3,1): Tile | value : 5 > <(3,2): Tile
    | value : 4 > <(3,3): Tile | value : 3 >

No more solutions.

==========================================
reduce in DEADLOCK-FREEDOM : deadlock-free(upModule('ABSTRACT-BAKERY, true),
    'BState) .
result SModule: mod 'ABSTRACT-BAKERY is
  nil
  sorts 'BState ; 'Bool ; 'EConfig ; 'Mode ; 'Nat ; 'NzNat ; 'Universal ; 'Zero
    .
  subsort 'NzNat < 'Nat .
  subsort 'Zero < 'Nat .
  op '0 : nil -> 'Zero [ctor] .
  op '<_`,_`,_`,_> : 'Mode 'Nat 'Mode 'Nat -> 'BState [ctor] .
  op '_&_ : 'Nat 'Nat -> 'Nat [assoc comm prec(53) special(
    id-hook('ACU_NumberOpSymbol, '&) 
    op-hook('succSymbol, 's_, 'Nat, 'NzNat))] .
  op '_*_ : 'Nat 'Nat -> 'Nat [assoc comm prec(31) special(
    id-hook('ACU_NumberOpSymbol, '*) 
    op-hook('succSymbol, 's_, 'Nat, 'NzNat))] .
  op '_*_ : 'NzNat 'NzNat -> 'NzNat [assoc comm prec(31) special(
    id-hook('ACU_NumberOpSymbol, '*) 
    op-hook('succSymbol, 's_, 'Nat, 'NzNat))] .
  op '_+_ : 'Nat 'Nat -> 'Nat [assoc comm prec(33) special(
    id-hook('ACU_NumberOpSymbol, '+) 
    op-hook('succSymbol, 's_, 'Nat, 'NzNat))] .
  op '_+_ : 'NzNat 'Nat -> 'NzNat [assoc comm prec(33) special(
    id-hook('ACU_NumberOpSymbol, '+) 
    op-hook('succSymbol, 's_, 'Nat, 'NzNat))] .
  op '_<<_ : 'Nat 'Nat -> 'Nat [prec(35) gather('E 'e) special(
    id-hook('NumberOpSymbol, '<<) 
    op-hook('succSymbol, 's_, 'Nat, 'NzNat))] .
  op '_<=_ : 'Nat 'Nat -> 'Bool [prec(37) special(
    id-hook('NumberOpSymbol, '<=) 
    op-hook('succSymbol, 's_, 'Nat, 'NzNat) 
    term-hook('trueTerm, 'true.Bool) 
    term-hook('falseTerm, 'false.Bool))] .
  op '_<_ : 'Nat 'Nat -> 'Bool [prec(37) special(
    id-hook('NumberOpSymbol, '<) 
    op-hook('succSymbol, 's_, 'Nat, 'NzNat) 
    term-hook('trueTerm, 'true.Bool) 
    term-hook('falseTerm, 'false.Bool))] .
  op '_=/=_ : 'Universal 'Universal -> 'Bool [prec(51) poly(1 2) special(
    id-hook('EqualitySymbol, nil) 
    term-hook('equalTerm, 'false.Bool) 
    term-hook('notEqualTerm, 'true.Bool))] .
  op '_==_ : 'Universal 'Universal -> 'Bool [prec(51) poly(1 2) special(
    id-hook('EqualitySymbol, nil) 
    term-hook('equalTerm, 'true.Bool) 
    term-hook('notEqualTerm, 'false.Bool))] .
  op '_>=_ : 'Nat 'Nat -> 'Bool [prec(37) special(
    id-hook('NumberOpSymbol, '>=) 
    op-hook('succSymbol, 's_, 'Nat, 'NzNat) 
    term-hook('trueTerm, 'true.Bool) 
    term-hook('falseTerm, 'false.Bool))] .
  op '_>>_ : 'Nat 'Nat -> 'Nat [prec(35) gather('E 'e) special(
    id-hook('NumberOpSymbol, '>>) 
    op-hook('succSymbol, 's_, 'Nat, 'NzNat))] .
  op '_>_ : 'Nat 'Nat -> 'Bool [prec(37) special(
    id-hook('NumberOpSymbol, '>) 
    op-hook('succSymbol, 's_, 'Nat, 'NzNat) 
    term-hook('trueTerm, 'true.Bool) 
    term-hook('falseTerm, 'false.Bool))] .
  op '_^_ : 'Nat 'Nat -> 'Nat [prec(29) gather('E 'e) special(
    id-hook('NumberOpSymbol, '^) 
    op-hook('succSymbol, 's_, 'Nat, 'NzNat))] .
  op '_^_ : 'NzNat 'Nat -> 'NzNat [prec(29) gather('E 'e) special(
    id-hook('NumberOpSymbol, '^) 
    op-hook('succSymbol, 's_, 'Nat, 'NzNat))] .
  op '_and_ : 'Bool 'Bool -> 'Bool [assoc comm prec(55)] .
  op '_divides_ : 'NzNat 'Nat -> 'Bool [prec(51) special(
    id-hook('NumberOpSymbol, 'divides) 
    op-hook('succSymbol, 's_, 'Nat, 'NzNat) 
    term-hook('trueTerm, 'true.Bool) 
    term-hook('falseTerm, 'false.Bool))] .
  op '_implies_ : 'Bool 'Bool -> 'Bool [prec(61) gather('e 'E)] .
  op '_or_ : 'Bool 'Bool -> 'Bool [assoc comm prec(59)] .
  op '_quo_ : 'Nat 'NzNat -> 'Nat [prec(31) gather('E 'e) special(
    id-hook('NumberOpSymbol, 'quo) 
    op-hook('succSymbol, 's_, 'Nat, 'NzNat))] .
  op '_rem_ : 'Nat 'NzNat -> 'Nat [prec(31) gather('E 'e) special(
    id-hook('NumberOpSymbol, 'rem) 
    op-hook('succSymbol, 's_, 'Nat, 'NzNat))] .
  op '_xor_ : 'Bool 'Bool -> 'Bool [assoc comm prec(57)] .
  op '_xor_ : 'Nat 'Nat -> 'Nat [assoc comm prec(55) special(
    id-hook('ACU_NumberOpSymbol, 'xor) 
    op-hook('succSymbol, 's_, 'Nat, 'NzNat))] .
  op '_|_ : 'Nat 'Nat -> 'Nat [assoc comm prec(57) special(
    id-hook('ACU_NumberOpSymbol, '|) 
    op-hook('succSymbol, 's_, 'Nat, 'NzNat))] .
  op '_|_ : 'NzNat 'Nat -> 'NzNat [assoc comm prec(57) special(
    id-hook('ACU_NumberOpSymbol, '|) 
    op-hook('succSymbol, 's_, 'Nat, 'NzNat))] .
  op '`{_`} : 'BState -> 'EConfig [none] .
  op 'crit : nil -> 'Mode [ctor] .
  op 'enabled : 'Universal -> 'Bool [poly(1)] .
  op 'false : nil -> 'Bool [ctor special(
    id-hook('SystemFalse, nil))] .
  op 'gcd : 'Nat 'Nat -> 'Nat [assoc comm special(
    id-hook('ACU_NumberOpSymbol, 'gcd) 
    op-hook('succSymbol, 's_, 'Nat, 'NzNat))] .
  op 'gcd : 'NzNat 'Nat -> 'NzNat [assoc comm special(
    id-hook('ACU_NumberOpSymbol, 'gcd) 
    op-hook('succSymbol, 's_, 'Nat, 'NzNat))] .
  op 'if_then_else_fi : 'Bool 'Universal 'Universal -> 'Universal [poly(2 3 0)
    special(
    id-hook('BranchSymbol, nil) 
    term-hook('1, 'true.Bool) 
    term-hook('2, 'false.Bool))] .
  op 'initial : nil -> 'BState [none] .
  op 'lcm : 'Nat 'Nat -> 'Nat [assoc comm special(
    id-hook('ACU_NumberOpSymbol, 'lcm) 
    op-hook('succSymbol, 's_, 'Nat, 'NzNat))] .
  op 'lcm : 'NzNat 'NzNat -> 'NzNat [assoc comm special(
    id-hook('ACU_NumberOpSymbol, 'lcm) 
    op-hook('succSymbol, 's_, 'Nat, 'NzNat))] .
  op 'max : 'Nat 'Nat -> 'Nat [assoc comm special(
    id-hook('ACU_NumberOpSymbol, 'max) 
    op-hook('succSymbol, 's_, 'Nat, 'NzNat))] .
  op 'max : 'NzNat 'Nat -> 'NzNat [assoc comm special(
    id-hook('ACU_NumberOpSymbol, 'max) 
    op-hook('succSymbol, 's_, 'Nat, 'NzNat))] .
  op 'min : 'Nat 'Nat -> 'Nat [assoc comm special(
    id-hook('ACU_NumberOpSymbol, 'min) 
    op-hook('succSymbol, 's_, 'Nat, 'NzNat))] .
  op 'min : 'NzNat 'NzNat -> 'NzNat [assoc comm special(
    id-hook('ACU_NumberOpSymbol, 'min) 
    op-hook('succSymbol, 's_, 'Nat, 'NzNat))] .
  op 'modExp : '`[Nat`] '`[Nat`] '`[Nat`] -> '`[Nat`] [special(
    id-hook('NumberOpSymbol, 'modExp) 
    op-hook('succSymbol, 's_, 'Nat, 'NzNat))] .
  op 'not_ : 'Bool -> 'Bool [prec(53)] .
  op 's_ : 'Nat -> 'NzNat [iter ctor special(
    id-hook('SuccSymbol, nil) 
    term-hook('zeroTerm, '0.Zero))] .
  op 'sd : 'Nat 'Nat -> 'Nat [comm special(
    id-hook('CUI_NumberOpSymbol, 'sd) 
    op-hook('succSymbol, 's_, 'Nat, 'NzNat))] .
  op 'sleep : nil -> 'Mode [ctor] .
  op 'true : nil -> 'Bool [ctor special(
    id-hook('SystemTrue, nil))] .
  op 'wait : nil -> 'Mode [ctor] .
  none
  eq 'initial.BState = '<_`,_`,_`,_>['sleep.Mode,'0.Zero,'sleep.Mode,'0.Zero] [
    none] .
  eq '<_`,_`,_`,_>['P:Mode,'0.Zero,'Q:Mode,'s_^2['Y:Nat]] = '<_`,_`,_`,_>[
    'P:Mode,'0.Zero,'Q:Mode,'s_['0.Zero]] [none] .
  eq '<_`,_`,_`,_>['P:Mode,'s_['0.Zero],'Q:Mode,'s_^2['Y:Nat]] = '<_`,_`,_`,_>[
    'P:Mode,'s_['0.Zero],'Q:Mode,'s_['0.Zero]] [none] .
  eq '<_`,_`,_`,_>['P:Mode,'s_^2['0.Zero],'Q:Mode,'s_^2['Y:Nat]] =
    '<_`,_`,_`,_>['P:Mode,'s_['0.Zero],'Q:Mode,'s_['0.Zero]] [none] .
  eq '<_`,_`,_`,_>['P:Mode,'s_^2['X:Nat],'Q:Mode,'0.Zero] = '<_`,_`,_`,_>[
    'P:Mode,'s_['0.Zero],'Q:Mode,'0.Zero] [none] .
  eq '<_`,_`,_`,_>['P:Mode,'s_^3['X:Nat],'Q:Mode,'s_['0.Zero]] = '<_`,_`,_`,_>[
    'P:Mode,'s_^2['0.Zero],'Q:Mode,'s_['0.Zero]] [none] .
  eq '<_`,_`,_`,_>['P:Mode,'s_^3['X:Nat],'Q:Mode,'s_^2['0.Zero]] =
    '<_`,_`,_`,_>['P:Mode,'s_^2['0.Zero],'Q:Mode,'s_['0.Zero]] [none] .
  eq '<_`,_`,_`,_>['P:Mode,'s_^3['X:Nat],'Q:Mode,'s_^3['Y:Nat]] =
    '<_`,_`,_`,_>['P:Mode,'s_^2['X:Nat],'Q:Mode,'s_^2['Y:Nat]] [none] .
  eq '_and_['A:Bool,'A:Bool] = 'A:Bool [none] .
  eq '_and_['A:Bool,'_xor_['B:Bool,'C:Bool]] = '_xor_['_and_['A:Bool,'B:Bool],
    '_and_['A:Bool,'C:Bool]] [none] .
  eq '_and_['false.Bool,'A:Bool] = 'false.Bool [none] .
  eq '_and_['true.Bool,'A:Bool] = 'A:Bool [none] .
  eq '_implies_['A:Bool,'B:Bool] = 'not_['_xor_['A:Bool,'_and_['A:Bool,
    'B:Bool]]] [none] .
  eq '_or_['A:Bool,'B:Bool] = '_xor_['_and_['A:Bool,'B:Bool],'_xor_['A:Bool,
    'B:Bool]] [none] .
  eq '_xor_['A:Bool,'A:Bool] = 'false.Bool [none] .
  eq '_xor_['false.Bool,'A:Bool] = 'A:Bool [none] .
  eq 'enabled['<_`,_`,_`,_>['P:Mode,'0.Zero,'wait.Mode,'Y:Nat]] = 'true.Bool [
    none] .
  eq 'enabled['<_`,_`,_`,_>['P:Mode,'X:Nat,'crit.Mode,'Y:Nat]] = 'true.Bool [
    none] .
  eq 'enabled['<_`,_`,_`,_>['P:Mode,'X:Nat,'sleep.Mode,'Y:Nat]] = 'true.Bool [
    none] .
  eq 'enabled['<_`,_`,_`,_>['crit.Mode,'X:Nat,'Q:Mode,'Y:Nat]] = 'true.Bool [
    none] .
  eq 'enabled['<_`,_`,_`,_>['sleep.Mode,'X:Nat,'Q:Mode,'Y:Nat]] = 'true.Bool [
    none] .
  eq 'enabled['<_`,_`,_`,_>['wait.Mode,'X:Nat,'Q:Mode,'0.Zero]] = 'true.Bool [
    none] .
  eq 'not_['A:Bool] = '_xor_['true.Bool,'A:Bool] [none] .
  ceq 'enabled['<_`,_`,_`,_>['P:Mode,'X:Nat,'wait.Mode,'Y:Nat]] = 'true.Bool if
    '_<_['Y:Nat,'X:Nat] = 'true.Bool [none] .
  ceq 'enabled['<_`,_`,_`,_>['V0:Mode,'V1:Nat,'V2:Mode,'V3:Nat]] = 'true.Bool
    if 'enabled['V0:Mode] = 'true.Bool [none] .
  ceq 'enabled['<_`,_`,_`,_>['V0:Mode,'V1:Nat,'V2:Mode,'V3:Nat]] = 'true.Bool
    if 'enabled['V1:Nat] = 'true.Bool [none] .
  ceq 'enabled['<_`,_`,_`,_>['V0:Mode,'V1:Nat,'V2:Mode,'V3:Nat]] = 'true.Bool
    if 'enabled['V2:Mode] = 'true.Bool [none] .
  ceq 'enabled['<_`,_`,_`,_>['V0:Mode,'V1:Nat,'V2:Mode,'V3:Nat]] = 'true.Bool
    if 'enabled['V3:Nat] = 'true.Bool [none] .
  ceq 'enabled['<_`,_`,_`,_>['wait.Mode,'X:Nat,'Q:Mode,'Y:Nat]] = 'true.Bool if
    'not_['_<_['Y:Nat,'X:Nat]] = 'true.Bool [none] .
  ceq 'enabled['_&_['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V0:Nat] =
    'true.Bool [none] .
  ceq 'enabled['_&_['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V1:Nat] =
    'true.Bool [none] .
  ceq 'enabled['_*_['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V0:Nat] =
    'true.Bool [none] .
  ceq 'enabled['_*_['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V1:Nat] =
    'true.Bool [none] .
  ceq 'enabled['_*_['V0:NzNat,'V1:NzNat]] = 'true.Bool if 'enabled['V0:NzNat] =
    'true.Bool [none] .
  ceq 'enabled['_*_['V0:NzNat,'V1:NzNat]] = 'true.Bool if 'enabled['V1:NzNat] =
    'true.Bool [none] .
  ceq 'enabled['_+_['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V0:Nat] =
    'true.Bool [none] .
  ceq 'enabled['_+_['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V1:Nat] =
    'true.Bool [none] .
  ceq 'enabled['_+_['V0:NzNat,'V1:Nat]] = 'true.Bool if 'enabled['V0:NzNat] =
    'true.Bool [none] .
  ceq 'enabled['_+_['V0:NzNat,'V1:Nat]] = 'true.Bool if 'enabled['V1:Nat] =
    'true.Bool [none] .
  ceq 'enabled['_<<_['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V0:Nat] =
    'true.Bool [none] .
  ceq 'enabled['_<<_['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V1:Nat] =
    'true.Bool [none] .
  ceq 'enabled['_<=_['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V0:Nat] =
    'true.Bool [none] .
  ceq 'enabled['_<=_['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V1:Nat] =
    'true.Bool [none] .
  ceq 'enabled['_<_['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V0:Nat] =
    'true.Bool [none] .
  ceq 'enabled['_<_['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V1:Nat] =
    'true.Bool [none] .
  ceq 'enabled['_=/=_['V0:`[BState`],'V1:`[BState`]]] = 'true.Bool if 'enabled[
    'V0:`[BState`]] = 'true.Bool [none] .
  ceq 'enabled['_=/=_['V0:`[BState`],'V1:`[BState`]]] = 'true.Bool if 'enabled[
    'V1:`[BState`]] = 'true.Bool [none] .
  ceq 'enabled['_=/=_['V0:`[Bool`],'V1:`[Bool`]]] = 'true.Bool if 'enabled[
    'V0:`[Bool`]] = 'true.Bool [none] .
  ceq 'enabled['_=/=_['V0:`[Bool`],'V1:`[Bool`]]] = 'true.Bool if 'enabled[
    'V1:`[Bool`]] = 'true.Bool [none] .
  ceq 'enabled['_=/=_['V0:`[Mode`],'V1:`[Mode`]]] = 'true.Bool if 'enabled[
    'V0:`[Mode`]] = 'true.Bool [none] .
  ceq 'enabled['_=/=_['V0:`[Mode`],'V1:`[Mode`]]] = 'true.Bool if 'enabled[
    'V1:`[Mode`]] = 'true.Bool [none] .
  ceq 'enabled['_=/=_['V0:`[Nat`],'V1:`[Nat`]]] = 'true.Bool if 'enabled[
    'V0:`[Nat`]] = 'true.Bool [none] .
  ceq 'enabled['_=/=_['V0:`[Nat`],'V1:`[Nat`]]] = 'true.Bool if 'enabled[
    'V1:`[Nat`]] = 'true.Bool [none] .
  ceq 'enabled['_==_['V0:`[BState`],'V1:`[BState`]]] = 'true.Bool if 'enabled[
    'V0:`[BState`]] = 'true.Bool [none] .
  ceq 'enabled['_==_['V0:`[BState`],'V1:`[BState`]]] = 'true.Bool if 'enabled[
    'V1:`[BState`]] = 'true.Bool [none] .
  ceq 'enabled['_==_['V0:`[Bool`],'V1:`[Bool`]]] = 'true.Bool if 'enabled[
    'V0:`[Bool`]] = 'true.Bool [none] .
  ceq 'enabled['_==_['V0:`[Bool`],'V1:`[Bool`]]] = 'true.Bool if 'enabled[
    'V1:`[Bool`]] = 'true.Bool [none] .
  ceq 'enabled['_==_['V0:`[Mode`],'V1:`[Mode`]]] = 'true.Bool if 'enabled[
    'V0:`[Mode`]] = 'true.Bool [none] .
  ceq 'enabled['_==_['V0:`[Mode`],'V1:`[Mode`]]] = 'true.Bool if 'enabled[
    'V1:`[Mode`]] = 'true.Bool [none] .
  ceq 'enabled['_==_['V0:`[Nat`],'V1:`[Nat`]]] = 'true.Bool if 'enabled[
    'V0:`[Nat`]] = 'true.Bool [none] .
  ceq 'enabled['_==_['V0:`[Nat`],'V1:`[Nat`]]] = 'true.Bool if 'enabled[
    'V1:`[Nat`]] = 'true.Bool [none] .
  ceq 'enabled['_>=_['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V0:Nat] =
    'true.Bool [none] .
  ceq 'enabled['_>=_['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V1:Nat] =
    'true.Bool [none] .
  ceq 'enabled['_>>_['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V0:Nat] =
    'true.Bool [none] .
  ceq 'enabled['_>>_['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V1:Nat] =
    'true.Bool [none] .
  ceq 'enabled['_>_['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V0:Nat] =
    'true.Bool [none] .
  ceq 'enabled['_>_['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V1:Nat] =
    'true.Bool [none] .
  ceq 'enabled['_^_['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V0:Nat] =
    'true.Bool [none] .
  ceq 'enabled['_^_['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V1:Nat] =
    'true.Bool [none] .
  ceq 'enabled['_^_['V0:NzNat,'V1:Nat]] = 'true.Bool if 'enabled['V0:NzNat] =
    'true.Bool [none] .
  ceq 'enabled['_^_['V0:NzNat,'V1:Nat]] = 'true.Bool if 'enabled['V1:Nat] =
    'true.Bool [none] .
  ceq 'enabled['_and_['V0:Bool,'V1:Bool]] = 'true.Bool if 'enabled['V0:Bool] =
    'true.Bool [none] .
  ceq 'enabled['_and_['V0:Bool,'V1:Bool]] = 'true.Bool if 'enabled['V1:Bool] =
    'true.Bool [none] .
  ceq 'enabled['_divides_['V0:NzNat,'V1:Nat]] = 'true.Bool if 'enabled[
    'V0:NzNat] = 'true.Bool [none] .
  ceq 'enabled['_divides_['V0:NzNat,'V1:Nat]] = 'true.Bool if 'enabled['V1:Nat]
    = 'true.Bool [none] .
  ceq 'enabled['_implies_['V0:Bool,'V1:Bool]] = 'true.Bool if 'enabled[
    'V0:Bool] = 'true.Bool [none] .
  ceq 'enabled['_implies_['V0:Bool,'V1:Bool]] = 'true.Bool if 'enabled[
    'V1:Bool] = 'true.Bool [none] .
  ceq 'enabled['_or_['V0:Bool,'V1:Bool]] = 'true.Bool if 'enabled['V0:Bool] =
    'true.Bool [none] .
  ceq 'enabled['_or_['V0:Bool,'V1:Bool]] = 'true.Bool if 'enabled['V1:Bool] =
    'true.Bool [none] .
  ceq 'enabled['_quo_['V0:Nat,'V1:NzNat]] = 'true.Bool if 'enabled['V0:Nat] =
    'true.Bool [none] .
  ceq 'enabled['_quo_['V0:Nat,'V1:NzNat]] = 'true.Bool if 'enabled['V1:NzNat] =
    'true.Bool [none] .
  ceq 'enabled['_rem_['V0:Nat,'V1:NzNat]] = 'true.Bool if 'enabled['V0:Nat] =
    'true.Bool [none] .
  ceq 'enabled['_rem_['V0:Nat,'V1:NzNat]] = 'true.Bool if 'enabled['V1:NzNat] =
    'true.Bool [none] .
  ceq 'enabled['_xor_['V0:Bool,'V1:Bool]] = 'true.Bool if 'enabled['V0:Bool] =
    'true.Bool [none] .
  ceq 'enabled['_xor_['V0:Bool,'V1:Bool]] = 'true.Bool if 'enabled['V1:Bool] =
    'true.Bool [none] .
  ceq 'enabled['_xor_['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V0:Nat] =
    'true.Bool [none] .
  ceq 'enabled['_xor_['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V1:Nat] =
    'true.Bool [none] .
  ceq 'enabled['_|_['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V0:Nat] =
    'true.Bool [none] .
  ceq 'enabled['_|_['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V1:Nat] =
    'true.Bool [none] .
  ceq 'enabled['_|_['V0:NzNat,'V1:Nat]] = 'true.Bool if 'enabled['V0:NzNat] =
    'true.Bool [none] .
  ceq 'enabled['_|_['V0:NzNat,'V1:Nat]] = 'true.Bool if 'enabled['V1:Nat] =
    'true.Bool [none] .
  ceq 'enabled['gcd['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V0:Nat] =
    'true.Bool [none] .
  ceq 'enabled['gcd['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V1:Nat] =
    'true.Bool [none] .
  ceq 'enabled['gcd['V0:NzNat,'V1:Nat]] = 'true.Bool if 'enabled['V0:NzNat] =
    'true.Bool [none] .
  ceq 'enabled['gcd['V0:NzNat,'V1:Nat]] = 'true.Bool if 'enabled['V1:Nat] =
    'true.Bool [none] .
  ceq 'enabled['if_then_else_fi['V0:Bool,'V1:`[BState`],'V2:`[BState`]]] =
    'true.Bool if 'enabled['V0:Bool] = 'true.Bool [none] .
  ceq 'enabled['if_then_else_fi['V0:Bool,'V1:`[BState`],'V2:`[BState`]]] =
    'true.Bool if 'enabled['V1:`[BState`]] = 'true.Bool [none] .
  ceq 'enabled['if_then_else_fi['V0:Bool,'V1:`[BState`],'V2:`[BState`]]] =
    'true.Bool if 'enabled['V2:`[BState`]] = 'true.Bool [none] .
  ceq 'enabled['if_then_else_fi['V0:Bool,'V1:`[Bool`],'V2:`[Bool`]]] =
    'true.Bool if 'enabled['V0:Bool] = 'true.Bool [none] .
  ceq 'enabled['if_then_else_fi['V0:Bool,'V1:`[Bool`],'V2:`[Bool`]]] =
    'true.Bool if 'enabled['V1:`[Bool`]] = 'true.Bool [none] .
  ceq 'enabled['if_then_else_fi['V0:Bool,'V1:`[Bool`],'V2:`[Bool`]]] =
    'true.Bool if 'enabled['V2:`[Bool`]] = 'true.Bool [none] .
  ceq 'enabled['if_then_else_fi['V0:Bool,'V1:`[Mode`],'V2:`[Mode`]]] =
    'true.Bool if 'enabled['V0:Bool] = 'true.Bool [none] .
  ceq 'enabled['if_then_else_fi['V0:Bool,'V1:`[Mode`],'V2:`[Mode`]]] =
    'true.Bool if 'enabled['V1:`[Mode`]] = 'true.Bool [none] .
  ceq 'enabled['if_then_else_fi['V0:Bool,'V1:`[Mode`],'V2:`[Mode`]]] =
    'true.Bool if 'enabled['V2:`[Mode`]] = 'true.Bool [none] .
  ceq 'enabled['if_then_else_fi['V0:Bool,'V1:`[Nat`],'V2:`[Nat`]]] = 'true.Bool
    if 'enabled['V0:Bool] = 'true.Bool [none] .
  ceq 'enabled['if_then_else_fi['V0:Bool,'V1:`[Nat`],'V2:`[Nat`]]] = 'true.Bool
    if 'enabled['V1:`[Nat`]] = 'true.Bool [none] .
  ceq 'enabled['if_then_else_fi['V0:Bool,'V1:`[Nat`],'V2:`[Nat`]]] = 'true.Bool
    if 'enabled['V2:`[Nat`]] = 'true.Bool [none] .
  ceq 'enabled['lcm['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V0:Nat] =
    'true.Bool [none] .
  ceq 'enabled['lcm['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V1:Nat] =
    'true.Bool [none] .
  ceq 'enabled['lcm['V0:NzNat,'V1:NzNat]] = 'true.Bool if 'enabled['V0:NzNat] =
    'true.Bool [none] .
  ceq 'enabled['lcm['V0:NzNat,'V1:NzNat]] = 'true.Bool if 'enabled['V1:NzNat] =
    'true.Bool [none] .
  ceq 'enabled['max['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V0:Nat] =
    'true.Bool [none] .
  ceq 'enabled['max['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V1:Nat] =
    'true.Bool [none] .
  ceq 'enabled['max['V0:NzNat,'V1:Nat]] = 'true.Bool if 'enabled['V0:NzNat] =
    'true.Bool [none] .
  ceq 'enabled['max['V0:NzNat,'V1:Nat]] = 'true.Bool if 'enabled['V1:Nat] =
    'true.Bool [none] .
  ceq 'enabled['min['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V0:Nat] =
    'true.Bool [none] .
  ceq 'enabled['min['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V1:Nat] =
    'true.Bool [none] .
  ceq 'enabled['min['V0:NzNat,'V1:NzNat]] = 'true.Bool if 'enabled['V0:NzNat] =
    'true.Bool [none] .
  ceq 'enabled['min['V0:NzNat,'V1:NzNat]] = 'true.Bool if 'enabled['V1:NzNat] =
    'true.Bool [none] .
  ceq 'enabled['modExp['V0:`[Nat`],'V1:`[Nat`],'V2:`[Nat`]]] = 'true.Bool if
    'enabled['V0:`[Nat`]] = 'true.Bool [none] .
  ceq 'enabled['modExp['V0:`[Nat`],'V1:`[Nat`],'V2:`[Nat`]]] = 'true.Bool if
    'enabled['V1:`[Nat`]] = 'true.Bool [none] .
  ceq 'enabled['modExp['V0:`[Nat`],'V1:`[Nat`],'V2:`[Nat`]]] = 'true.Bool if
    'enabled['V2:`[Nat`]] = 'true.Bool [none] .
  ceq 'enabled['not_['V0:Bool]] = 'true.Bool if 'enabled['V0:Bool] = 'true.Bool
    [none] .
  ceq 'enabled['s_['V0:Nat]] = 'true.Bool if 'enabled['V0:Nat] = 'true.Bool [
    none] .
  ceq 'enabled['sd['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V0:Nat] =
    'true.Bool [none] .
  ceq 'enabled['sd['V0:Nat,'V1:Nat]] = 'true.Bool if 'enabled['V1:Nat] =
    'true.Bool [none] .
  rl '<_`,_`,_`,_>['P:Mode,'0.Zero,'wait.Mode,'Y:Nat] => '<_`,_`,_`,_>['P:Mode,
    '0.Zero,'crit.Mode,'Y:Nat] [label('p2_wait)] .
  rl '<_`,_`,_`,_>['P:Mode,'X:Nat,'crit.Mode,'Y:Nat] => '<_`,_`,_`,_>['P:Mode,
    'X:Nat,'sleep.Mode,'0.Zero] [label('p2_crit)] .
  rl '<_`,_`,_`,_>['P:Mode,'X:Nat,'sleep.Mode,'Y:Nat] => '<_`,_`,_`,_>['P:Mode,
    'X:Nat,'wait.Mode,'s_['X:Nat]] [label('p2_sleep)] .
  rl '<_`,_`,_`,_>['crit.Mode,'X:Nat,'Q:Mode,'Y:Nat] => '<_`,_`,_`,_>[
    'sleep.Mode,'0.Zero,'Q:Mode,'Y:Nat] [label('p1_crit)] .
  rl '<_`,_`,_`,_>['sleep.Mode,'X:Nat,'Q:Mode,'Y:Nat] => '<_`,_`,_`,_>[
    'wait.Mode,'s_['Y:Nat],'Q:Mode,'Y:Nat] [label('p1_sleep)] .
  rl '<_`,_`,_`,_>['wait.Mode,'X:Nat,'Q:Mode,'0.Zero] => '<_`,_`,_`,_>[
    'crit.Mode,'X:Nat,'Q:Mode,'0.Zero] [label('p1_wait)] .
  crl '<_`,_`,_`,_>['P:Mode,'X:Nat,'wait.Mode,'Y:Nat] => '<_`,_`,_`,_>['P:Mode,
    'X:Nat,'crit.Mode,'Y:Nat] if '_<_['Y:Nat,'X:Nat] = 'true.Bool [label(
    'p2_wait)] .
  crl '<_`,_`,_`,_>['wait.Mode,'X:Nat,'Q:Mode,'Y:Nat] => '<_`,_`,_`,_>[
    'crit.Mode,'X:Nat,'Q:Mode,'Y:Nat] if 'not_['_<_['Y:Nat,'X:Nat]] =
    'true.Bool [label('p1_wait)] .
  crl '`{_`}['V:BState] => '`{_`}['V:BState] if '_=/=_['enabled['V:BState],
    'true.Bool] = 'true.Bool [none] .
endm
    DEADLOCK-FREE mod. expr. available Oct. 28th 2008

rewrites: 613 in 4ms cpu (5ms real) (130536 rewrites/second)
    DEADLOCK-FREE mod. expr. available Oct. 28th 2008

rewrites: 4437 in 52ms cpu (81ms real) (84638 rewrites/second)
Introduced module DF-BAKERY

rewrites: 2932 in 32ms cpu (118ms real) (90079 rewrites/second)
Introduced module DF-ABSTRACT-BAKERY

rewrites: 591 in 4ms cpu (4ms real) (144959 rewrites/second)
Advisory: Module DF-BAKERY redefined.
Introduced module DF-BAKERY

rewrites: 3922 in 37ms cpu (51ms real) (103488 rewrites/second)
Introduced module DF-BAKERY-PREDS

rewrites: 3635 in 23ms cpu (24ms real) (155641 rewrites/second)
Introduced module DF-ABSTRACT-BAKERY-PREDS

rewrites: 3243 in 16ms cpu (17ms real) (192703 rewrites/second)
Introduced module DF-ABSTRACT-BAKERY-CHECK

rewrites: 1572 in 38ms cpu (45ms real) (41013 rewrites/second)
reduce in DF-ABSTRACT-BAKERY-CHECK :
  modelCheck({initial},[]~(1crit /\ 2crit))
result Bool :
  true

rewrites: 1116 in 8ms cpu (8ms real) (127179 rewrites/second)
reduce in DF-ABSTRACT-BAKERY-CHECK :
  modelCheck({initial},(1wait |-> 1crit)/\(2wait |-> 2crit))
result Bool :
  true

==========================================
reduce in LIST-CONS-TEST : reverse("one" : "two" : "three" : []) .
result NeList{String}: "three" : "two" : "one" : []
Advisory: redefining module TAOSET.
Advisory: redefining module SPOSET.
Advisory: redefining module POSET.
Advisory: redefining module TOSET.
==========================================
reduce in BIN-TREE-TEST : postorder((empty[1]empty)[2](empty[3]empty)) .
result NeList{Int}: 1 : 3 : 2 : []
    DEADLOCK-FREE mod. expr. available Oct. 28th 2008

Introduced module TREE-NODE

Introduced view Node

Introduced module LEFTIST-TREES

Introduced view IntAsToset

Introduced module LEFTIST-TREES-TEST

reduce in LEFTIST-TREES-TEST :
  insert(5,insert(4,empty))
result NeLTree{IntAsToset} :
  (empty[n(1,5)]empty)[n(1,4)]empty

reduce in LEFTIST-TREES-TEST :
  findMin(insert(5,deleteMin(insert(3,insert(-10,empty)))))
result NzNat :
  3

reduce in LEFTIST-TREES-TEST :
  deleteMin(insert(900,insert(-901,insert(902,insert(-903,insert(904,insert(
    -905,insert(906,insert(-907,insert(908,insert(-909,insert(910,insert(-910,
    insert(911,insert(-912,insert(913,insert(-914,empty)))))))))))))))))
result NeLTree{IntAsToset} :
  (((empty[n(1,908)]empty)[n(2,-907)](empty[n(1,906)]empty))[n(3,-909)](((
    empty[n(1,911)]empty)[n(2,-901)]((empty[n(1,904)]empty)[n(1,900)]empty))[n(
    2,-905)]((empty[n(1,913)]empty)[n(1,910)]empty)))[n(3,-912)]((empty[n(1,
    -903)]empty)[n(2,-910)](empty[n(1,902)]empty))

Advisory: View IntAsToset redefined.
Introduced view IntAsToset

Introduced view IntStringAsToset

Introduced module LEFTIST-TREES-TEST-PAIR

reduce in LEFTIST-TREES-TEST-PAIR :
  findMin(insert(< 4,"d" >,insert(< 8,"h" >,insert(< 1,"a" >,empty))))
result Priority-Pair{IntAsToset,String} :
  < 1,"a" >

reduce in LEFTIST-TREES-TEST-PAIR :
  findMin(insert(< 5,"e" >,deleteMin(insert(< 3,"c" >,insert(< -10,"zzz" >,
    empty)))))
result Priority-Pair{IntAsToset,String} :
  < 3,"c" >

Introduced module OO-BLOCKS-WORLD

search in OO-BLOCKS-WORLD : unstack('c,'a)stack('b,'c)stack('a,'b)initial =>*
    C:Configuration .

Solution 1
C:Configuration --> < 'a : Block | on : 'b,under : clear > < 'b : Block | on :
    'c,under : 'a > < 'c : Block | on : table,under : 'b >

No more solutions.

Introduced module OO-BLOCKS-WORLD-COLOR

rewrite in OO-BLOCKS-WORLD-COLOR :
  unstack('c,'a)< 'a : Block | color : red,under : 'c,on : table > < 'c : Block
    | color : blue,under : clear,on : 'a > < 'b : Block | color : yellow,under
    : clear,on : table >
result Configuration :
  < 'a : Block | color : red,on : table,under : clear > < 'b : Block | color :
    yellow,on : table,under : clear > < 'c : Block | color : blue,on : table,
    under : clear >

Introduced module SPREADSHEET

Introduced module SPREADSHEET-ASYNCH

Introduced module NARROWING-VENDING-MACHINE

search [,4] in NARROWING-VENDING-MACHINE : < M:Money > ~>* < a c > .

Solution 1
M:Money --> $ q q q

Solution 2
M:Money --> q q q q q q q

No more solutions.

search [,5] in NARROWING-VENDING-MACHINE : < M:Money > ~>! < MO':Money a c > .

Solution 1
M:Money --> $ $ ; MO':Money --> q

Solution 2
M:Money --> $ q q q q ; MO':Money --> q

Solution 3
M:Money --> q q q q q q q q ; MO':Money --> q

No more solutions.

reduce in META-NARROWING-SEARCH :
  metaNarrowSearch(mod 'NARROWING-VENDING-MACHINE is
  nil
  sorts 'Bool ; 'Coin ; 'Item ; 'Marking ; 'Money ; 'State .
  subsort 'Coin < 'Money .
  subsort 'Item < 'Marking .
  subsort 'Money < 'Marking .
  op '$ : nil -> 'Coin [format('r! 'o)] .
  op '<_> : 'Marking -> 'State [none] .
  op '_=/=_ : 'Universal 'Universal -> 'Bool [prec(51)poly(1 2)special(
    id-hook('EqualitySymbol,nil)
    term-hook('equalTerm,'false.Bool)
    term-hook('notEqualTerm,'true.Bool))] .
  op '_==_ : 'Universal 'Universal -> 'Bool [prec(51)poly(1 2)special(
    id-hook('EqualitySymbol,nil)
    term-hook('equalTerm,'true.Bool)
    term-hook('notEqualTerm,'false.Bool))] .
  op '__ : 'Marking 'Marking -> 'Marking [assoc comm] .
  op '__ : 'Money 'Money -> 'Money [assoc comm] .
  op '_and_ : 'Bool 'Bool -> 'Bool [assoc comm prec(55)] .
  op '_implies_ : 'Bool 'Bool -> 'Bool [prec(61)gather('e 'E)] .
  op '_or_ : 'Bool 'Bool -> 'Bool [assoc comm prec(59)] .
  op '_xor_ : 'Bool 'Bool -> 'Bool [assoc comm prec(57)] .
  op 'a : nil -> 'Item [format('b! 'o)] .
  op 'c : nil -> 'Item [format('b! 'o)] .
  op 'false : nil -> 'Bool [ctor special(
    id-hook('SystemFalse,nil))] .
  op 'if_then_else_fi : 'Bool 'Universal 'Universal -> 'Universal [poly(2 3
    0)special(
    id-hook('BranchSymbol,nil)
    term-hook('1,'true.Bool)
    term-hook('2,'false.Bool))] .
  op 'not_ : 'Bool -> 'Bool [prec(53)] .
  op 'q : nil -> 'Coin [format('r! 'o)] .
  op 'true : nil -> 'Bool [ctor special(
    id-hook('SystemTrue,nil))] .
  none
  eq '_and_['A:Bool,'A:Bool]= 'A:Bool [none] .
  eq '_and_['A:Bool,'_xor_['B:Bool,'C:Bool]]= '_xor_['_and_['A:Bool,'B:Bool],
    '_and_['A:Bool,'C:Bool]] [none] .
  eq '_and_['false.Bool,'A:Bool]= 'false.Bool [none] .
  eq '_and_['true.Bool,'A:Bool]= 'A:Bool [none] .
  eq '_implies_['A:Bool,'B:Bool]= 'not_['_xor_['A:Bool,'_and_['A:Bool,
    'B:Bool]]] [none] .
  eq '_or_['A:Bool,'B:Bool]= '_xor_['_and_['A:Bool,'B:Bool],'_xor_['A:Bool,
    'B:Bool]] [none] .
  eq '_xor_['A:Bool,'A:Bool]= 'false.Bool [none] .
  eq '_xor_['false.Bool,'A:Bool]= 'A:Bool [none] .
  eq 'not_['A:Bool]= '_xor_['true.Bool,'A:Bool] [none] .
  rl '<_>['$.Coin]=> '<_>['c.Item] [label('buy-c)] .
  rl '<_>['$.Coin]=> '<_>['__['a.Item,'q.Coin]] [label('buy-a)] .
  rl '<_>['__['M:Marking,'$.Coin]]=> '<_>['__['M:Marking,'c.Item]] [label(
    'buy-c)] .
  rl '<_>['__['M:Marking,'$.Coin]]=> '<_>['__['M:Marking,'__['a.Item,'q.Coin]]]
    [label('buy-a)] .
  rl '<_>['__['M:Marking,'__['q.Coin,'__['q.Coin,'__['q.Coin,'q.Coin]]]]]=>
    '<_>['__['M:Marking,'$.Coin]] [label('change)] .
  rl '<_>['__['q.Coin,'__['q.Coin,'__['q.Coin,'q.Coin]]]]=> '<_>['$.Coin] [
    label('change)] .
endm,'<_>['MO:Money],'<_>['__['a.Item,'c.Item]],none,'*,4,unbounded)
result ResultTripleSet :
  {'<_>['__['a.Item,'c.Item]],'State,
    '#1:Marking <- '__['q.Coin,'q.Coin,'q.Coin];
    '#3:Money <- '__['q.Coin,'q.Coin,'q.Coin];
    '#4:Marking <- 'a.Item ;
    '#6:Marking <- 'a.Item ;
    'MO:Money <- '__['$.Coin,'__['q.Coin,'q.Coin,'q.Coin]]}|
{'<_>['__['a.Item,'c.Item]],'State,
    '#1:Marking <- '__['q.Coin,'q.Coin,'q.Coin];
    '#3:Money <- '__['q.Coin,'q.Coin,'q.Coin];
    '#4:Marking <- '__['q.Coin,'q.Coin,'q.Coin];
    '#6:Money <- '__['q.Coin,'q.Coin,'q.Coin];
    '#7:Marking <- 'a.Item ;
    '#9:Marking <- 'a.Item ;
    'MO:Money <- '__['q.Coin,'q.Coin,'q.Coin,'q.Coin,'__['q.Coin,'q.Coin,
    'q.Coin]]}

Introduced module LAST-APPEND

search [1] in LAST-APPEND : last(0 : s(0): nil) ~>! Z:Nat .

Solution 1
Z:Nat --> s(0)

No more solutions.

Warning: Term X:Magma a is non-ground and unification for its top symbol is not
    currently supported.
Warning: Term a X:Magma is non-ground and unification for its top symbol is not
    currently supported.
Introduced module LEFTID-UNIFICATION-EXAMPLE

id-unify in LEFTID-UNIFICATION-EXAMPLE : X:Magma a =? Y:Magma a a .
No unifier
id-unify in LEFTID-UNIFICATION-EXAMPLE : a X:Magma =? a a Y:Magma .
No unifier
Introduced module RIGHTID-UNIFICATION-EXAMPLE

Warning: Term X:Magma a is non-ground and unification for its top symbol is not
    currently supported.
Warning: Term a X:Magma is non-ground and unification for its top symbol is not
    currently supported.
id-unify in RIGHTID-UNIFICATION-EXAMPLE : X:Magma a =? Y:Magma a a .
No unifier
id-unify in RIGHTID-UNIFICATION-EXAMPLE : a X:Magma =? a a Y:Magma .
No unifier
Introduced module ID-UNIFICATION-EXAMPLE

id-unify in ID-UNIFICATION-EXAMPLE : a a =? a a e .

Solution 1
empty substitution

No more solutions.

id-unify in ID-UNIFICATION-EXAMPLE : X:MSet =? a a e .

Solution 1
X:MSet --> a a

No more solutions.

id-unify in ID-UNIFICATION-EXAMPLE : a X:MSet =? a a Y:MSet .

Solution 1
#2:MSet --> Y:MSet ; X:MSet --> a Y:MSet

Solution 2
X:MSet --> a ; Y:MSet --> e

No more solutions.

reduce in META-NARROWING-SEARCH :
  metaACUUnify(mod 'ID-UNIFICATION-EXAMPLE is
  nil
  sorts 'Bool ; 'Elem ; 'MSet .
  subsort 'Elem < 'MSet .
  op '_=/=_ : 'Universal 'Universal -> 'Bool [prec(51)poly(1 2)special(
    id-hook('EqualitySymbol,nil)
    term-hook('equalTerm,'false.Bool)
    term-hook('notEqualTerm,'true.Bool))] .
  op '_==_ : 'Universal 'Universal -> 'Bool [prec(51)poly(1 2)special(
    id-hook('EqualitySymbol,nil)
    term-hook('equalTerm,'true.Bool)
    term-hook('notEqualTerm,'false.Bool))] .
  op '__ : 'MSet 'MSet -> 'MSet [assoc comm id('e.Elem)] .
  op '_and_ : 'Bool 'Bool -> 'Bool [assoc comm prec(55)] .
  op '_implies_ : 'Bool 'Bool -> 'Bool [prec(61)gather('e 'E)] .
  op '_or_ : 'Bool 'Bool -> 'Bool [assoc comm prec(59)] .
  op '_xor_ : 'Bool 'Bool -> 'Bool [assoc comm prec(57)] .
  op 'a : nil -> 'Elem [none] .
  op 'b : nil -> 'Elem [none] .
  op 'c : nil -> 'Elem [none] .
  op 'd : nil -> 'Elem [none] .
  op 'e : nil -> 'Elem [none] .
  op 'false : nil -> 'Bool [ctor special(
    id-hook('SystemFalse,nil))] .
  op 'if_then_else_fi : 'Bool 'Universal 'Universal -> 'Universal [poly(2 3
    0)special(
    id-hook('BranchSymbol,nil)
    term-hook('1,'true.Bool)
    term-hook('2,'false.Bool))] .
  op 'not_ : 'Bool -> 'Bool [prec(53)] .
  op 'true : nil -> 'Bool [ctor special(
    id-hook('SystemTrue,nil))] .
  none
  eq '_and_['A:Bool,'A:Bool]= 'A:Bool [none] .
  eq '_and_['A:Bool,'_xor_['B:Bool,'C:Bool]]= '_xor_['_and_['A:Bool,'B:Bool],
    '_and_['A:Bool,'C:Bool]] [none] .
  eq '_and_['false.Bool,'A:Bool]= 'false.Bool [none] .
  eq '_and_['true.Bool,'A:Bool]= 'A:Bool [none] .
  eq '_implies_['A:Bool,'B:Bool]= 'not_['_xor_['A:Bool,'_and_['A:Bool,
    'B:Bool]]] [none] .
  eq '_or_['A:Bool,'B:Bool]= '_xor_['_and_['A:Bool,'B:Bool],'_xor_['A:Bool,
    'B:Bool]] [none] .
  eq '_xor_['A:Bool,'A:Bool]= 'false.Bool [none] .
  eq '_xor_['false.Bool,'A:Bool]= 'A:Bool [none] .
  eq 'not_['A:Bool]= '_xor_['true.Bool,'A:Bool] [none] .
  none
endm,'__['a.Elem,'X:MSet],'__['__['a.Elem,'a.Elem],'Y:MSet])
result NeSubstitutionSet :
  (
    '#2:MSet <- 'Y:MSet ;
    'X:MSet <- '__['a.Elem,'Y:MSet])
|(
    'X:MSet <- 'a.Elem ;
    'Y:MSet <- 'e.Elem)

Introduced module LIST

Introduced view List`{String`}

Introduced module STRING-LIST-SET

reduce in STRING-LIST-SET :
  | "foo", "foo" "bar", "foo" "bar" "baz" |
result NzNat :
  3

Introduced view Tuple3

Introduced view List

Introduced module FOO

Introduced module BAR

fmod FOO{String,Nat,Nat}is
  including BOOL .
  protecting NAT .
  protecting LIST{Tuple3{String,Nat,Nat}}.
  protecting STRING .
  protecting NAT .
  protecting NAT .
  op foo : List{Tuple3`{String`,Nat`,Nat`}}-> Nat .
  eq foo(nil)
    = 0 .
  eq foo(E:Tuple{String,Nat,Nat}L:List{Tuple3{String,Nat,Nat}})
    = 1 + foo(L:List{Tuple3{String,Nat,Nat}}) .
endfm

reduce in BAR :
  foo(("uno",1,1)("dos",2,2)("tres",3,3)("cuatro",4,4))
result NzNat :
  4

==========================================
reduce in META-LEVEL : upModule('FOO, false) .
result FModule: fmod 'FOO is
  including 'BOOL .
  sorts 'Foo .
  none
  op 'f : nil -> 'Foo [none] .
  op 'g : nil -> 'Foo [none] .
  none
  eq 'f.Foo = 'g.Foo [none] .
endfm
    DEADLOCK-FREE mod. expr. available Oct. 28th 2008

The META-LEVEL has been set as current module.

Introduced module FOO

fmod FOO is
  including BOOL .
  sorts Foo .
  op f : -> Foo .
  op g : -> Foo .
  eq f
    = g .
endfm

reduce in FOO :
  f
result Foo :
  g

Introduced module CHANGE-NAME

Introduced module MY-NAT

fmod MY-NAT is
  sorts Bool Nat NzNat Zero .
  subsort NzNat < Nat .
  subsort Zero < Nat .
  op 0 : -> Zero
    [ctor] .
  op _&_ : Nat Nat -> Nat
    [assoc comm prec 53 special(id-hook ACU_NumberOpSymbol(&)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op _*_ : Nat Nat -> Nat
    [assoc comm prec 31 special(id-hook ACU_NumberOpSymbol(*)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op _*_ : NzNat NzNat -> NzNat
    [assoc comm prec 31 special(id-hook ACU_NumberOpSymbol(*)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op _+_ : Nat Nat -> Nat
    [assoc comm prec 33 special(id-hook ACU_NumberOpSymbol(+)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op _+_ : NzNat Nat -> NzNat
    [assoc comm prec 33 special(id-hook ACU_NumberOpSymbol(+)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op _<<_ : Nat Nat -> Nat
    [prec 35 gather(E e)special(id-hook NumberOpSymbol(<<)op-hook succSymbol(s_
    : Nat ~> NzNat))] .
  op _<=_ : Nat Nat -> Bool
    [prec 37 special(id-hook NumberOpSymbol(<=)op-hook succSymbol(s_ : Nat ~>
    NzNat)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _<_ : Nat Nat -> Bool
    [prec 37 special(id-hook NumberOpSymbol(<)op-hook succSymbol(s_ : Nat ~>
    NzNat)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _=/=_ : Universal Universal -> Bool
    [poly(1 2)prec 51 special(id-hook EqualitySymbol term-hook equalTerm(
    false)term-hook notEqualTerm(true))] .
  op _==_ : Universal Universal -> Bool
    [poly(1 2)prec 51 special(id-hook EqualitySymbol term-hook equalTerm(
    true)term-hook notEqualTerm(false))] .
  op _>=_ : Nat Nat -> Bool
    [prec 37 special(id-hook NumberOpSymbol(>=)op-hook succSymbol(s_ : Nat ~>
    NzNat)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _>>_ : Nat Nat -> Nat
    [prec 35 gather(E e)special(id-hook NumberOpSymbol(>>)op-hook succSymbol(s_
    : Nat ~> NzNat))] .
  op _>_ : Nat Nat -> Bool
    [prec 37 special(id-hook NumberOpSymbol(>)op-hook succSymbol(s_ : Nat ~>
    NzNat)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _^_ : Nat Nat -> Nat
    [prec 29 gather(E e)special(id-hook NumberOpSymbol(^)op-hook succSymbol(s_
    : Nat ~> NzNat))] .
  op _^_ : NzNat Nat -> NzNat
    [prec 29 gather(E e)special(id-hook NumberOpSymbol(^)op-hook succSymbol(s_
    : Nat ~> NzNat))] .
  op _and_ : Bool Bool -> Bool
    [assoc comm prec 55] .
  op _divides_ : NzNat Nat -> Bool
    [prec 51 special(id-hook NumberOpSymbol(divides)op-hook succSymbol(s_ : Nat
    ~> NzNat)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _implies_ : Bool Bool -> Bool
    [prec 61 gather(e E)] .
  op _or_ : Bool Bool -> Bool
    [assoc comm prec 59] .
  op _quo_ : Nat NzNat -> Nat
    [prec 31 gather(E e)special(id-hook NumberOpSymbol(quo)op-hook succSymbol(
    s_ : Nat ~> NzNat))] .
  op _rem_ : Nat NzNat -> Nat
    [prec 31 gather(E e)special(id-hook NumberOpSymbol(rem)op-hook succSymbol(
    s_ : Nat ~> NzNat))] .
  op _xor_ : Bool Bool -> Bool
    [assoc comm prec 57] .
  op _xor_ : Nat Nat -> Nat
    [assoc comm prec 55 special(id-hook ACU_NumberOpSymbol(xor)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op _|_ : Nat Nat -> Nat
    [assoc comm prec 57 special(id-hook ACU_NumberOpSymbol(|)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op _|_ : NzNat Nat -> NzNat
    [assoc comm prec 57 special(id-hook ACU_NumberOpSymbol(|)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op false : -> Bool
    [ctor special(id-hook SystemFalse)] .
  op gcd : Nat Nat -> Nat
    [assoc comm special(id-hook ACU_NumberOpSymbol(gcd)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op gcd : NzNat Nat -> NzNat
    [assoc comm special(id-hook ACU_NumberOpSymbol(gcd)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op if_then_else_fi : Bool Universal Universal -> Universal
    [poly(2 3 0)special(id-hook BranchSymbol term-hook 1(true)term-hook 2(
    false))] .
  op lcm : Nat Nat -> Nat
    [assoc comm special(id-hook ACU_NumberOpSymbol(lcm)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op lcm : NzNat NzNat -> NzNat
    [assoc comm special(id-hook ACU_NumberOpSymbol(lcm)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op max : Nat Nat -> Nat
    [assoc comm special(id-hook ACU_NumberOpSymbol(max)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op max : NzNat Nat -> NzNat
    [assoc comm special(id-hook ACU_NumberOpSymbol(max)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op min : Nat Nat -> Nat
    [assoc comm special(id-hook ACU_NumberOpSymbol(min)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op min : NzNat NzNat -> NzNat
    [assoc comm special(id-hook ACU_NumberOpSymbol(min)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op modExp :[Nat][Nat][Nat]->[Nat]
    [special(id-hook NumberOpSymbol(modExp)op-hook succSymbol(s_ : Nat ~>
    NzNat))] .
  op not_ : Bool -> Bool
    [prec 53] .
  op s_ : Nat -> NzNat
    [ctor iter special(id-hook SuccSymbol term-hook zeroTerm(0))] .
  op sd : Nat Nat -> Nat
    [comm special(id-hook CUI_NumberOpSymbol(sd)op-hook succSymbol(s_ : Nat ~>
    NzNat))] .
  op true : -> Bool
    [ctor special(id-hook SystemTrue)] .
  eq A:Bool and A:Bool
    = A:Bool .
  eq A:Bool and(B:Bool xor C:Bool)
    = A:Bool and B:Bool xor A:Bool and C:Bool .
  eq false and A:Bool
    = false .
  eq true and A:Bool
    = A:Bool .
  eq A:Bool implies B:Bool
    = not(A:Bool xor A:Bool and B:Bool) .
  eq A:Bool or B:Bool
    = A:Bool and B:Bool xor A:Bool xor B:Bool .
  eq A:Bool xor A:Bool
    = false .
  eq false xor A:Bool
    = A:Bool .
  eq not A:Bool
    = true xor A:Bool .
endfm

reduce in MY-NAT :
  2 + 3
result NzNat :
  5

Introduced module ACCOUNT

Advisory: Module CHANGE-NAME redefined.
Introduced module CHANGE-NAME

Introduced module MY-ACCOUNT

mod MY-ACCOUNT is
  sorts Account Attribute AttributeSet Bool Char Cid Configuration FindResult
    Int Msg Nat NzInt NzNat Object Oid Portal Qid String Zero .
  subsort Account < Cid .
  subsort Attribute < AttributeSet .
  subsort Char < String .
  subsort Msg < Configuration .
  subsort Nat < FindResult .
  subsort Nat < Int .
  subsort NzInt < Int .
  subsort NzNat < Nat .
  subsort NzNat < NzInt .
  subsort Object < Configuration .
  subsort Portal < Configuration .
  subsort Qid < Oid .
  subsort Zero < Nat .
  op <_:_|`> : Oid Cid -> Object .
  op Account : -> Account .
  op class : Object -> Cid .
  op -_ : Int -> Int
    [special(id-hook MinusSymbol op-hook succSymbol(s_ : Nat ~> NzNat)op-hook
    minusSymbol(-_ : NzNat ~> NzInt))] .
  op -_ : NzInt -> NzInt
    [special(id-hook MinusSymbol op-hook succSymbol(s_ : Nat ~> NzNat)op-hook
    minusSymbol(-_ : NzNat ~> NzInt))] .
  op -_ : NzNat -> NzInt
    [ctor special(id-hook MinusSymbol op-hook succSymbol(s_ : Nat ~>
    NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt))] .
  op 0 : -> Zero
    [ctor] .
  op <> : -> Portal
    [ctor] .
  op <Qids> : -> Qid
    [special(id-hook QuotedIdentifierSymbol)] .
  op <Strings> : -> Char
    [special(id-hook StringSymbol)] .
  op <Strings> : -> String
    [special(id-hook StringSymbol)] .
  op <_:_|_> : Oid Cid AttributeSet -> Object
    [ctor object] .
  op _&_ : Int Int -> Int
    [assoc comm prec 53 special(id-hook ACU_NumberOpSymbol(&)op-hook
    succSymbol(s_ : Nat ~> NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt))] .
  op _&_ : Nat Int -> Nat
    [assoc comm prec 53 special(id-hook ACU_NumberOpSymbol(&)op-hook
    succSymbol(s_ : Nat ~> NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt))] .
  op _&_ : Nat Nat -> Nat
    [assoc comm prec 53 special(id-hook ACU_NumberOpSymbol(&)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op _*_ : Int Int -> Int
    [assoc comm prec 31 special(id-hook ACU_NumberOpSymbol(*)op-hook
    succSymbol(s_ : Nat ~> NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt))] .
  op _*_ : Nat Nat -> Nat
    [assoc comm prec 31 special(id-hook ACU_NumberOpSymbol(*)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op _*_ : NzInt NzInt -> NzInt
    [assoc comm prec 31 special(id-hook ACU_NumberOpSymbol(*)op-hook
    succSymbol(s_ : Nat ~> NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt))] .
  op _*_ : NzNat NzNat -> NzNat
    [assoc comm prec 31 special(id-hook ACU_NumberOpSymbol(*)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op _+_ : Int Int -> Int
    [assoc comm prec 33 special(id-hook ACU_NumberOpSymbol(+)op-hook
    succSymbol(s_ : Nat ~> NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt))] .
  op _+_ : Nat Nat -> Nat
    [assoc comm prec 33 special(id-hook ACU_NumberOpSymbol(+)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op _+_ : NzNat Nat -> NzNat
    [assoc comm prec 33 special(id-hook ACU_NumberOpSymbol(+)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op _+_ : String String -> String
    [prec 33 gather(E e)special(id-hook StringOpSymbol(+)op-hook stringSymbol(
    <Strings> : ~> Char))] .
  op _-_ : Int Int -> Int
    [prec 33 gather(E e)special(id-hook NumberOpSymbol(-)op-hook succSymbol(s_
    : Nat ~> NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt))] .
  op _<<_ : Int Nat -> Int
    [prec 35 gather(E e)special(id-hook NumberOpSymbol(<<)op-hook succSymbol(s_
    : Nat ~> NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt))] .
  op _<<_ : Nat Nat -> Nat
    [prec 35 gather(E e)special(id-hook NumberOpSymbol(<<)op-hook succSymbol(s_
    : Nat ~> NzNat))] .
  op _<=_ : Int Int -> Bool
    [prec 37 special(id-hook NumberOpSymbol(<=)op-hook succSymbol(s_ : Nat ~>
    NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt)term-hook trueTerm(
    true)term-hook falseTerm(false))] .
  op _<=_ : Nat Nat -> Bool
    [prec 37 special(id-hook NumberOpSymbol(<=)op-hook succSymbol(s_ : Nat ~>
    NzNat)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _<=_ : String String -> Bool
    [prec 37 special(id-hook StringOpSymbol(<=)op-hook stringSymbol(<Strings> :
    ~> Char)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _<_ : Int Int -> Bool
    [prec 37 special(id-hook NumberOpSymbol(<)op-hook succSymbol(s_ : Nat ~>
    NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt)term-hook trueTerm(
    true)term-hook falseTerm(false))] .
  op _<_ : Nat Nat -> Bool
    [prec 37 special(id-hook NumberOpSymbol(<)op-hook succSymbol(s_ : Nat ~>
    NzNat)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _<_ : String String -> Bool
    [prec 37 special(id-hook StringOpSymbol(<)op-hook stringSymbol(<Strings> :
    ~> Char)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _=/=_ : Universal Universal -> Bool
    [poly(1 2)prec 51 special(id-hook EqualitySymbol term-hook equalTerm(
    false)term-hook notEqualTerm(true))] .
  op _==_ : Universal Universal -> Bool
    [poly(1 2)prec 51 special(id-hook EqualitySymbol term-hook equalTerm(
    true)term-hook notEqualTerm(false))] .
  op _>=_ : Int Int -> Bool
    [prec 37 special(id-hook NumberOpSymbol(>=)op-hook succSymbol(s_ : Nat ~>
    NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt)term-hook trueTerm(
    true)term-hook falseTerm(false))] .
  op _>=_ : Nat Nat -> Bool
    [prec 37 special(id-hook NumberOpSymbol(>=)op-hook succSymbol(s_ : Nat ~>
    NzNat)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _>=_ : String String -> Bool
    [prec 37 special(id-hook StringOpSymbol(>=)op-hook stringSymbol(<Strings> :
    ~> Char)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _>>_ : Int Nat -> Int
    [prec 35 gather(E e)special(id-hook NumberOpSymbol(>>)op-hook succSymbol(s_
    : Nat ~> NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt))] .
  op _>>_ : Nat Nat -> Nat
    [prec 35 gather(E e)special(id-hook NumberOpSymbol(>>)op-hook succSymbol(s_
    : Nat ~> NzNat))] .
  op _>_ : Int Int -> Bool
    [prec 37 special(id-hook NumberOpSymbol(>)op-hook succSymbol(s_ : Nat ~>
    NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt)term-hook trueTerm(
    true)term-hook falseTerm(false))] .
  op _>_ : Nat Nat -> Bool
    [prec 37 special(id-hook NumberOpSymbol(>)op-hook succSymbol(s_ : Nat ~>
    NzNat)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _>_ : String String -> Bool
    [prec 37 special(id-hook StringOpSymbol(>)op-hook stringSymbol(<Strings> :
    ~> Char)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _^_ : Int Nat -> Int
    [prec 29 gather(E e)special(id-hook NumberOpSymbol(^)op-hook succSymbol(s_
    : Nat ~> NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt))] .
  op _^_ : Nat Nat -> Nat
    [prec 29 gather(E e)special(id-hook NumberOpSymbol(^)op-hook succSymbol(s_
    : Nat ~> NzNat))] .
  op _^_ : NzInt Nat -> NzInt
    [prec 29 gather(E e)special(id-hook NumberOpSymbol(^)op-hook succSymbol(s_
    : Nat ~> NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt))] .
  op _^_ : NzNat Nat -> NzNat
    [prec 29 gather(E e)special(id-hook NumberOpSymbol(^)op-hook succSymbol(s_
    : Nat ~> NzNat))] .
  op __ : Configuration Configuration -> Configuration
    [assoc comm id:(none).Configuration ctor config] .
  op _`,_ : AttributeSet AttributeSet -> AttributeSet
    [assoc comm id:(none).AttributeSet ctor] .
  op _and_ : Bool Bool -> Bool
    [assoc comm prec 55] .
  op _divides_ : NzInt Int -> Bool
    [prec 51 special(id-hook NumberOpSymbol(divides)op-hook succSymbol(s_ : Nat
    ~> NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt)term-hook trueTerm(
    true)term-hook falseTerm(false))] .
  op _divides_ : NzNat Nat -> Bool
    [prec 51 special(id-hook NumberOpSymbol(divides)op-hook succSymbol(s_ : Nat
    ~> NzNat)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _implies_ : Bool Bool -> Bool
    [prec 61 gather(e E)] .
  op _or_ : Bool Bool -> Bool
    [assoc comm prec 59] .
  op _quo_ : Int NzInt -> Int
    [prec 31 gather(E e)special(id-hook NumberOpSymbol(quo)op-hook succSymbol(
    s_ : Nat ~> NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt))] .
  op _quo_ : Nat NzNat -> Nat
    [prec 31 gather(E e)special(id-hook NumberOpSymbol(quo)op-hook succSymbol(
    s_ : Nat ~> NzNat))] .
  op _rem_ : Int NzInt -> Int
    [prec 31 gather(E e)special(id-hook NumberOpSymbol(rem)op-hook succSymbol(
    s_ : Nat ~> NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt))] .
  op _rem_ : Nat NzNat -> Nat
    [prec 31 gather(E e)special(id-hook NumberOpSymbol(rem)op-hook succSymbol(
    s_ : Nat ~> NzNat))] .
  op _xor_ : Bool Bool -> Bool
    [assoc comm prec 57] .
  op _xor_ : Int Int -> Int
    [assoc comm prec 55 special(id-hook ACU_NumberOpSymbol(xor)op-hook
    succSymbol(s_ : Nat ~> NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt))] .
  op _xor_ : Nat Nat -> Nat
    [assoc comm prec 55 special(id-hook ACU_NumberOpSymbol(xor)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op _|_ : Int Int -> Int
    [assoc comm prec 57 special(id-hook ACU_NumberOpSymbol(|)op-hook
    succSymbol(s_ : Nat ~> NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt))] .
  op _|_ : Nat Nat -> Nat
    [assoc comm prec 57 special(id-hook ACU_NumberOpSymbol(|)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op _|_ : NzInt Int -> NzInt
    [assoc comm prec 57 special(id-hook ACU_NumberOpSymbol(|)op-hook
    succSymbol(s_ : Nat ~> NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt))] .
  op _|_ : NzNat Nat -> NzNat
    [assoc comm prec 57 special(id-hook ACU_NumberOpSymbol(|)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op abs : Int -> Nat
    [special(id-hook NumberOpSymbol(abs)op-hook succSymbol(s_ : Nat ~>
    NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt))] .
  op abs : NzInt -> NzNat
    [special(id-hook NumberOpSymbol(abs)op-hook succSymbol(s_ : Nat ~>
    NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt))] .
  op ascii : Char -> Nat
    [special(id-hook StringOpSymbol(ascii)op-hook stringSymbol(<Strings> : ~>
    Char)op-hook succSymbol(s_ : Nat ~> NzNat))] .
  op bal`:_ : Int -> Attribute
    [gather(&)] .
  op char :[FindResult]->[String]
    [special(id-hook StringOpSymbol(char)op-hook stringSymbol(<Strings> : ~>
    Char)op-hook succSymbol(s_ : Nat ~> NzNat))] .
  op credit : Oid Int -> Msg
    [msg] .
  op debit : Oid Int -> Msg
    [msg] .
  op false : -> Bool
    [ctor special(id-hook SystemFalse)] .
  op find : String String Nat -> FindResult
    [special(id-hook StringOpSymbol(find)op-hook stringSymbol(<Strings> : ~>
    Char)op-hook succSymbol(s_ : Nat ~> NzNat)term-hook notFoundTerm(
    notFound))] .
  op from_to_transfer_ : Oid Oid Int -> Msg
    [msg] .
  op gcd : Int Int -> Nat
    [assoc comm special(id-hook ACU_NumberOpSymbol(gcd)op-hook succSymbol(s_ :
    Nat ~> NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt))] .
  op gcd : Nat Nat -> Nat
    [assoc comm special(id-hook ACU_NumberOpSymbol(gcd)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op gcd : NzInt Int -> NzNat
    [assoc comm special(id-hook ACU_NumberOpSymbol(gcd)op-hook succSymbol(s_ :
    Nat ~> NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt))] .
  op gcd : NzNat Nat -> NzNat
    [assoc comm special(id-hook ACU_NumberOpSymbol(gcd)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op if_then_else_fi : Bool Universal Universal -> Universal
    [poly(2 3 0)special(id-hook BranchSymbol term-hook 1(true)term-hook 2(
    false))] .
  op lcm : Int Int -> Nat
    [assoc comm special(id-hook ACU_NumberOpSymbol(lcm)op-hook succSymbol(s_ :
    Nat ~> NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt))] .
  op lcm : Nat Nat -> Nat
    [assoc comm special(id-hook ACU_NumberOpSymbol(lcm)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op lcm : NzInt NzInt -> NzNat
    [assoc comm special(id-hook ACU_NumberOpSymbol(lcm)op-hook succSymbol(s_ :
    Nat ~> NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt))] .
  op lcm : NzNat NzNat -> NzNat
    [assoc comm special(id-hook ACU_NumberOpSymbol(lcm)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op length : String -> Nat
    [special(id-hook StringOpSymbol(length)op-hook stringSymbol(<Strings> : ~>
    Char)op-hook succSymbol(s_ : Nat ~> NzNat))] .
  op max : Int Int -> Int
    [assoc comm special(id-hook ACU_NumberOpSymbol(max)op-hook succSymbol(s_ :
    Nat ~> NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt))] .
  op max : Nat Int -> Nat
    [assoc comm special(id-hook ACU_NumberOpSymbol(max)op-hook succSymbol(s_ :
    Nat ~> NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt))] .
  op max : Nat Nat -> Nat
    [assoc comm special(id-hook ACU_NumberOpSymbol(max)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op max : NzInt NzInt -> NzInt
    [assoc comm special(id-hook ACU_NumberOpSymbol(max)op-hook succSymbol(s_ :
    Nat ~> NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt))] .
  op max : NzNat Int -> NzNat
    [assoc comm special(id-hook ACU_NumberOpSymbol(max)op-hook succSymbol(s_ :
    Nat ~> NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt))] .
  op max : NzNat Nat -> NzNat
    [assoc comm special(id-hook ACU_NumberOpSymbol(max)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op min : Int Int -> Int
    [assoc comm special(id-hook ACU_NumberOpSymbol(min)op-hook succSymbol(s_ :
    Nat ~> NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt))] .
  op min : Nat Nat -> Nat
    [assoc comm special(id-hook ACU_NumberOpSymbol(min)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op min : NzInt NzInt -> NzInt
    [assoc comm special(id-hook ACU_NumberOpSymbol(min)op-hook succSymbol(s_ :
    Nat ~> NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt))] .
  op min : NzNat NzNat -> NzNat
    [assoc comm special(id-hook ACU_NumberOpSymbol(min)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op modExp :[Nat][Nat][Nat]->[Nat]
    [special(id-hook NumberOpSymbol(modExp)op-hook succSymbol(s_ : Nat ~>
    NzNat))] .
  op none : -> AttributeSet
    [ctor] .
  op none : -> Configuration
    [ctor] .
  op notFound : -> FindResult
    [ctor] .
  op not_ : Bool -> Bool
    [prec 53] .
  op qid :[String]->[Qid]
    [special(id-hook QuotedIdentifierOpSymbol(qid)op-hook
    quotedIdentifierSymbol(<Qids> : ~> Qid)op-hook stringSymbol(<Strings> : ~>
    Char))] .
  op rfind : String String Nat -> FindResult
    [special(id-hook StringOpSymbol(rfind)op-hook stringSymbol(<Strings> : ~>
    Char)op-hook succSymbol(s_ : Nat ~> NzNat)term-hook notFoundTerm(
    notFound))] .
  op s_ : Nat -> NzNat
    [ctor iter special(id-hook SuccSymbol term-hook zeroTerm(0))] .
  op sd : Nat Nat -> Nat
    [comm special(id-hook CUI_NumberOpSymbol(sd)op-hook succSymbol(s_ : Nat ~>
    NzNat))] .
  op string : Qid -> String
    [special(id-hook QuotedIdentifierOpSymbol(string)op-hook
    quotedIdentifierSymbol(<Qids> : ~> Qid)op-hook stringSymbol(<Strings> : ~>
    Char))] .
  op substr : String Nat Nat -> String
    [special(id-hook StringOpSymbol(substr)op-hook stringSymbol(<Strings> : ~>
    Char)op-hook succSymbol(s_ : Nat ~> NzNat))] .
  op true : -> Bool
    [ctor special(id-hook SystemTrue)] .
  op ~_ : Int -> Int
    [special(id-hook NumberOpSymbol(~)op-hook succSymbol(s_ : Nat ~>
    NzNat)op-hook minusSymbol(-_ : NzNat ~> NzInt))] .
  eq A:Bool and A:Bool
    = A:Bool .
  eq A:Bool and(B:Bool xor C:Bool)
    = A:Bool and B:Bool xor A:Bool and C:Bool .
  eq false and A:Bool
    = false .
  eq true and A:Bool
    = A:Bool .
  eq A:Bool implies B:Bool
    = not(A:Bool xor A:Bool and B:Bool) .
  eq A:Bool or B:Bool
    = A:Bool and B:Bool xor A:Bool xor B:Bool .
  eq A:Bool xor A:Bool
    = false .
  eq false xor A:Bool
    = A:Bool .
  eq class(< O:Oid : C:Cid | A:AttributeSet >)
    = C:Cid .
  eq not A:Bool
    = true xor A:Bool .
  rl credit(A:Oid,M:Nat)< A:Oid : V#0:Account | bal : N:Int,none,
    V#1:AttributeSet >
    => < A:Oid : V#0:Account | bal :(N:Int + M:Nat),V#1:AttributeSet > [label
    credit] .
  crl debit(A:Oid,M:Nat)< A:Oid : V#2:Account | bal : N:Int,none,
    V#3:AttributeSet >
    => < A:Oid : V#2:Account | bal :(N:Int - M:Nat),V#3:AttributeSet >
    if N:Int >= M:Nat = true [label debit] .
  crl (from A:Oid to B:Oid transfer M:Nat)< A:Oid : V#4:Account | bal : N:Int,
    none,V#5:AttributeSet > < B:Oid : V#6:Account | bal : N':Int,none,
    V#7:AttributeSet >
    => < A:Oid : V#4:Account | bal :(N:Int - M:Nat),V#5:AttributeSet > < B:Oid
    : V#6:Account | bal :(N':Int + M:Nat),V#7:AttributeSet >
    if N:Int >= M:Nat = true [label transfer] .
endm

The UNIT has been set as current module.

Introduced module SAVING-ACCOUNT

The SAVING-ACCOUNT has been set as current module.

rewrite in SAVING-ACCOUNT :
  < 'A-73728 : SavingAccount | bal : 5000,rate : 3.0 > < 'A-06238 : Account |
    bal : 2000 > < 'A-28381 : SavingAccount | bal : 9000,rate : 3.0 > debit(
    'A-06238,1000)credit('A-73728,1300)credit('A-28381,200)
result Configuration :
  < 'A-06238 : Account | bal : 1000 > < 'A-28381 : SavingAccount | bal : 9200,
    rate : 3.0 > < 'A-73728 : SavingAccount | bal : 6300,rate : 3.0 >

omod SAVING-ACCOUNT is
  including BOOL .
  including CONFIGURATION .
  including CONFIGURATION+ .
  protecting FLOAT .
  protecting QID .
  protecting INT .
  subsort Qid < Oid .
  class Account | bal : Int .
  class SavingAccount | rate : Float .
  subclass SavingAccount < Account .
  msg credit : Oid Int -> Msg .
  msg debit : Oid Int -> Msg .
  msg from_to_transfer_ : Oid Oid Int -> Msg .
  rl credit(A:Oid,M:Nat)< A:Oid : Account | bal : N:Int >
    => < A:Oid : Account | bal :(N:Int + M:Nat)> [label credit] .
  crl debit(A:Oid,M:Nat)< A:Oid : Account | bal : N:Int >
    => < A:Oid : Account | bal :(N:Int - M:Nat)>
    if N:Int >= M:Nat = true [label debit] .
  crl (from A:Oid to B:Oid transfer M:Nat)< A:Oid : Account | bal : N:Int > <
    B:Oid : Account | bal : N':Int >
    => < A:Oid : Account | bal :(N:Int - M:Nat)> < B:Oid : Account | bal :(
    N':Int + M:Nat)>
    if N:Int >= M:Nat = true [label transfer] .
endom

    DEADLOCK-FREE mod. expr. available Oct. 28th 2008

reduce in machineint-CoreMaude :
  -2147483648 - 1
result NzMachineNat :
  2147483647

Warning: Parse error in 34 + <---*HERE*
Error: no parse for 34 + 43

reduce in machineint-CoreMaude :
  34 plus 43
result NzMachineNat :
  77

Introduced module FULL-MACHINE

reduce in FULL-MACHINE :
  g(t,v)
result State :
  t

search in FULL-MACHINE : s =>* w:State .

Solution 1
w:State --> s

Solution 2
w:State --> t

Solution 3
w:State --> v

No more solutions.

Warning: Parse error in show search <---*HERE*
Error: No parse for input.

search [,1] in FULL-MACHINE : s =>+ w:State .

Solution 1
w:State --> t

Solution 2
w:State --> v

No more solutions.

Introduced module SET-KIND-1

fmod SET-KIND-1{X :: TRIV} is
  including BOOL .
  protecting EXT-BOOL .
  protecting NAT .
  sorts KSet{X}NeKSet{X}.
  subsort NeKSet{X}< KSet{X}.
  subsort X$Elt < NeKSet{X}.
  op _in_ : X$Elt KSet{X}-> Bool .
  op card : KSet{X}-> Nat .
  op _`,_ :[KSet{X}][KSet{X}]->[KSet{X}]
    [assoc comm id: empty ctor] .
  op _intersection_ : KSet{X}KSet{X}-> KSet{X}
    [assoc comm] .
  op empty : -> KSet{X}
    [ctor] .
  mb NS:NeKSet{X},NS':NeKSet{X}: NeKSet{X} [label AAA] .
  eq E:X$Elt,E:X$Elt
    = E:X$Elt .
  eq E:X$Elt,S:KSet{X}intersection E:X$Elt,S':KSet{X}
    = E:X$Elt,S:KSet{X}intersection S':KSet{X} .
  eq E:X$Elt in E:X$Elt,S:KSet{X}
    = true .
  eq card(empty)
    = 0 .
  eq card(E:X$Elt,S:KSet{X})
    = if E:X$Elt in S:KSet{X}then card(S:KSet{X})else 1 + card(S:KSet{X})fi .
  eq E:X$Elt in S:KSet{X}
    = false [owise] .
  eq S:KSet{X}intersection S':KSet{X}
    = empty [owise] .
endfm

Introduced module AMBIGUOUS

mod AMBIGUOUS is
  including BOOL .
  sorts Foo .
  op a : -> Foo .
  op f : Foo -> Foo .
  op g : Foo -> Foo .
  op h : Foo -> Foo .
  eq f("here":Foo)
    = g("here":Foo) [print "here":Foo] .
  rl g(M:Foo)
    => h(M:Foo) [print "M = " M:Foo "g->h rule"] .
endm

reduce in AMBIGUOUS :
  f(a)
result Foo :
  g(a)

a
reduce in AMBIGUOUS :
  f(a)
result Foo :
  g(a)

Introduced module PRINT-ATTR-AMBIGUOUS

metadata = 
h(a)
metadata = 
reduce in PRINT-ATTR-AMBIGUOUS :
  f(g(a))
result Foo :
  h(h(a))

Introduced module PRINT-ATTRIBUTE-EX

first = a, rest = b a b
first = b, rest = a b
first = a, rest = b
first = b, rest = nil
reduce in PRINT-ATTRIBUTE-EX :
  reverse(a b a b)
result FooList :
  b a b a

Introduced module NONAMBIGUOUS

mod NONAMBIGUOUS is
  including BOOL .
  sorts Foo .
  op a : -> Foo .
  op f : Foo -> Foo .
  op g : Foo -> Foo .
  op h : Foo -> Foo .
  eq f(H:Foo)
    = g(H:Foo) [print "here"] .
  rl g(M:Foo)
    => h(M:Foo) [print "metadata = " M:Foo " g -> h rule"] .
endm

here
metadata = a g -> h rule
rewrite in NONAMBIGUOUS :
  f(a)
result Foo :
  h(a)

here
metadata = a g -> h rule
rewrite in NONAMBIGUOUS :
  f(a)
result Foo :
  h(a)

Introduced module PRUEBA2

mod PRUEBA2 is
  including BOOL .
  protecting CONVERSION * (op -_ : `[Float`] -> `[Float`] to -f_, op _*_ :
    `[Float`] `[Float`] -> `[Float`] to _*f_, op _+_ : `[Float`] `[Float`] ->
    `[Float`] to _+f_, op _+_ : `[String`] `[String`] -> `[String`] to conc, op
    _-_ : `[Float`] `[Float`] -> `[Float`] to _-f_, op _<=_ : `[Float`]
    `[Float`] -> `[Bool`] to _<=f_, op _<=_ : `[String`] `[String`] -> `[Bool`]
    to _let_, op _<_ : `[Float`] `[Float`] -> `[Bool`] to _<f_, op _<_ :
    `[String`] `[String`] -> `[Bool`] to _lt_, op _>=_ : `[Float`] `[Float`] ->
    `[Bool`] to _>=f_, op _>=_ : `[String`] `[String`] -> `[Bool`] to _get_, op
    _>_ : `[Float`] `[Float`] -> `[Bool`] to _>f_, op _>_ : `[String`]
    `[String`] -> `[Bool`] to _gt_, op _xor_ : `[FindResult`] `[FindResult`] ->
    `[FindResult`] to _xorN_, op abs : `[Float`] -> `[Float`] to absf, op
    ceiling : `[Float`] -> `[Float`] to ceilingf, op float : `[String`] ->
    `[Float`] to floats, op floor : `[Float`] -> `[Float`] to floorf, op max :
    `[Float`] `[Float`] -> `[Float`] to maxf, op min : `[Float`] `[Float`] ->
    `[Float`] to minf, op string : `[Float`] -> `[String`] to stringf, op
    string : `[FindResult`] `[FindResult`] -> `[String`] to toString) .
endm

reduce in PRUEBA2 :
  stringf(3.4219999999999999e+2)
result String :
  "3.4219999999999999e+2"

Introduced module FOO

search in FOO : a =>* G:Foo .

Solution 1
G:Foo --> a

Solution 2
G:Foo --> b

Solution 3
G:Foo --> c

Solution 4
G:Foo --> d

Solution 5
G:Foo --> e

No more solutions.

search in FOO : a =>+ G:Foo .

Solution 1
G:Foo --> b

Solution 2
G:Foo --> c

Solution 3
G:Foo --> d

Solution 4
G:Foo --> e

No more solutions.

search in FOO : a =>! G:Foo .

Solution 1
G:Foo --> b

Solution 2
G:Foo --> d

Solution 3
G:Foo --> e

No more solutions.

search [,1] in FOO : a =>+ G:Foo .

Solution 1
G:Foo --> b

Solution 2
G:Foo --> c

No more solutions.

search [1] in FOO : a =>* G:Foo .

Solution 1
G:Foo --> a


search [1] in FOO : a =>+ G:Foo .

Solution 1
G:Foo --> b


search [1] in FOO : a =>! G:Foo .

Solution 1
G:Foo --> b


search [1,1] in FOO : a =>+ G:Foo .

Solution 1
G:Foo --> b


search [,1] in FOO : a =>* G:Foo .

Solution 1
G:Foo --> a

Solution 2
G:Foo --> b

Solution 3
G:Foo --> c

No more solutions.

search [,1] in FOO : a =>+ G:Foo .

Solution 1
G:Foo --> b

Solution 2
G:Foo --> c

No more solutions.

search [,1] in FOO : a =>! G:Foo .

Solution 1
G:Foo --> b

No more solutions.

search [,1] in FOO : a =>+ G:Foo .

Solution 1
G:Foo --> b

Solution 2
G:Foo --> c

No more solutions.

search [1,1] in FOO : a =>* G:Foo .

Solution 1
G:Foo --> a


search [1,1] in FOO : a =>+ G:Foo .

Solution 1
G:Foo --> b


search [1,1] in FOO : a =>! G:Foo .

Solution 1
G:Foo --> b


search [1,1] in FOO : a =>+ G:Foo .

Solution 1
G:Foo --> b


Introduced module AC

unify in AC : f(X:Foo,Y:Foo) =? f(A:Foo,B:Foo,C:Foo).

Solution 1
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> f(#3:Foo,#4:Foo); C:Foo --> f(#5:Foo,
    #6:Foo); X:Foo --> f(#3:Foo,#1:Foo,#5:Foo); Y:Foo --> f(#2:Foo,#4:Foo,
    #6:Foo)



Solution 2
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> f(#3:Foo,#4:Foo); C:Foo --> #5:Foo ;
    X:Foo --> f(#3:Foo,#1:Foo,#5:Foo); Y:Foo --> f(#2:Foo,#4:Foo)

Solution 3
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> f(#3:Foo,#4:Foo); C:Foo --> #5:Foo ;
    X:Foo --> f(#3:Foo,#1:Foo); Y:Foo --> f(#2:Foo,#4:Foo,#5:Foo)

Solution 4
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> #3:Foo ; C:Foo --> f(#4:Foo,#5:Foo);
    X:Foo --> f(#3:Foo,#1:Foo,#4:Foo); Y:Foo --> f(#2:Foo,#5:Foo)

Solution 5
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> #3:Foo ; C:Foo --> #4:Foo ; X:Foo --> f(
    #3:Foo,#1:Foo,#4:Foo); Y:Foo --> #2:Foo

Solution 6
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> #3:Foo ; C:Foo --> #4:Foo ; X:Foo --> f(
    #3:Foo,#1:Foo); Y:Foo --> f(#2:Foo,#4:Foo)

Solution 7
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> #3:Foo ; C:Foo --> f(#4:Foo,#5:Foo);
    X:Foo --> f(#1:Foo,#4:Foo); Y:Foo --> f(#2:Foo,#3:Foo,#5:Foo)

Solution 8
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> #3:Foo ; C:Foo --> #4:Foo ; X:Foo --> f(
    #1:Foo,#4:Foo); Y:Foo --> f(#2:Foo,#3:Foo)

Solution 9
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> #3:Foo ; C:Foo --> #4:Foo ; X:Foo -->
    #1:Foo ; Y:Foo --> f(#2:Foo,#3:Foo,#4:Foo)

Solution 10
A:Foo --> #1:Foo ; B:Foo --> f(#2:Foo,#3:Foo); C:Foo --> f(#4:Foo,#5:Foo);
    X:Foo --> f(#2:Foo,#1:Foo,#4:Foo); Y:Foo --> f(#3:Foo,#5:Foo)

Solution 11
A:Foo --> #1:Foo ; B:Foo --> f(#2:Foo,#3:Foo); C:Foo --> #4:Foo ; X:Foo --> f(
    #2:Foo,#1:Foo,#4:Foo); Y:Foo --> #3:Foo

Solution 12
A:Foo --> #1:Foo ; B:Foo --> f(#2:Foo,#3:Foo); C:Foo --> #4:Foo ; X:Foo --> f(
    #2:Foo,#1:Foo); Y:Foo --> f(#3:Foo,#4:Foo)

Solution 13
A:Foo --> #1:Foo ; B:Foo --> #2:Foo ; C:Foo --> f(#3:Foo,#4:Foo); X:Foo --> f(
    #2:Foo,#3:Foo,#1:Foo); Y:Foo --> #4:Foo

Solution 14
A:Foo --> #1:Foo ; B:Foo --> #2:Foo ; C:Foo --> #3:Foo ; X:Foo --> f(#2:Foo,
    #1:Foo); Y:Foo --> #3:Foo

Solution 15
A:Foo --> #1:Foo ; B:Foo --> #2:Foo ; C:Foo --> f(#3:Foo,#4:Foo); X:Foo --> f(
    #3:Foo,#1:Foo); Y:Foo --> f(#2:Foo,#4:Foo)

Solution 16
A:Foo --> #1:Foo ; B:Foo --> #2:Foo ; C:Foo --> #3:Foo ; X:Foo --> f(#3:Foo,
    #1:Foo); Y:Foo --> #2:Foo

Solution 17
A:Foo --> #1:Foo ; B:Foo --> #2:Foo ; C:Foo --> #3:Foo ; X:Foo --> #1:Foo ;
    Y:Foo --> f(#2:Foo,#3:Foo)

Solution 18
A:Foo --> #1:Foo ; B:Foo --> f(#2:Foo,#3:Foo); C:Foo --> f(#4:Foo,#5:Foo);
    X:Foo --> f(#2:Foo,#4:Foo); Y:Foo --> f(#3:Foo,#1:Foo,#5:Foo)

Solution 19
A:Foo --> #1:Foo ; B:Foo --> f(#2:Foo,#3:Foo); C:Foo --> #4:Foo ; X:Foo --> f(
    #2:Foo,#4:Foo); Y:Foo --> f(#3:Foo,#1:Foo)

Solution 20
A:Foo --> #1:Foo ; B:Foo --> f(#2:Foo,#3:Foo); C:Foo --> #4:Foo ; X:Foo -->
    #2:Foo ; Y:Foo --> f(#3:Foo,#1:Foo,#4:Foo)

Solution 21
A:Foo --> #1:Foo ; B:Foo --> #2:Foo ; C:Foo --> f(#3:Foo,#4:Foo); X:Foo --> f(
    #2:Foo,#3:Foo); Y:Foo --> f(#1:Foo,#4:Foo)

Solution 22
A:Foo --> #1:Foo ; B:Foo --> #2:Foo ; C:Foo --> #3:Foo ; X:Foo --> f(#2:Foo,
    #3:Foo); Y:Foo --> #1:Foo

Solution 23
A:Foo --> #1:Foo ; B:Foo --> #2:Foo ; C:Foo --> #3:Foo ; X:Foo --> #2:Foo ;
    Y:Foo --> f(#3:Foo,#1:Foo)

Solution 24
A:Foo --> #1:Foo ; B:Foo --> #2:Foo ; C:Foo --> f(#3:Foo,#4:Foo); X:Foo -->
    #3:Foo ; Y:Foo --> f(#2:Foo,#1:Foo,#4:Foo)

Solution 25
A:Foo --> #1:Foo ; B:Foo --> #2:Foo ; C:Foo --> #3:Foo ; X:Foo --> #3:Foo ;
    Y:Foo --> f(#2:Foo,#1:Foo)

No more solutions.

unify [10] in AC : f(X:Foo,Y:Foo) =? f(A:Foo,B:Foo,C:Foo).

Solution 1
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> f(#3:Foo,#4:Foo); C:Foo --> f(#5:Foo,
    #6:Foo); X:Foo --> f(#3:Foo,#1:Foo,#5:Foo); Y:Foo --> f(#2:Foo,#4:Foo,
    #6:Foo)



Solution 2
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> f(#3:Foo,#4:Foo); C:Foo --> #5:Foo ;
    X:Foo --> f(#3:Foo,#1:Foo,#5:Foo); Y:Foo --> f(#2:Foo,#4:Foo)

Solution 3
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> f(#3:Foo,#4:Foo); C:Foo --> #5:Foo ;
    X:Foo --> f(#3:Foo,#1:Foo); Y:Foo --> f(#2:Foo,#4:Foo,#5:Foo)

Solution 4
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> #3:Foo ; C:Foo --> f(#4:Foo,#5:Foo);
    X:Foo --> f(#3:Foo,#1:Foo,#4:Foo); Y:Foo --> f(#2:Foo,#5:Foo)

Solution 5
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> #3:Foo ; C:Foo --> #4:Foo ; X:Foo --> f(
    #3:Foo,#1:Foo,#4:Foo); Y:Foo --> #2:Foo

Solution 6
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> #3:Foo ; C:Foo --> #4:Foo ; X:Foo --> f(
    #3:Foo,#1:Foo); Y:Foo --> f(#2:Foo,#4:Foo)

Solution 7
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> #3:Foo ; C:Foo --> f(#4:Foo,#5:Foo);
    X:Foo --> f(#1:Foo,#4:Foo); Y:Foo --> f(#2:Foo,#3:Foo,#5:Foo)

Solution 8
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> #3:Foo ; C:Foo --> #4:Foo ; X:Foo --> f(
    #1:Foo,#4:Foo); Y:Foo --> f(#2:Foo,#3:Foo)

Solution 9
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> #3:Foo ; C:Foo --> #4:Foo ; X:Foo -->
    #1:Foo ; Y:Foo --> f(#2:Foo,#3:Foo,#4:Foo)

Solution 10
A:Foo --> #1:Foo ; B:Foo --> f(#2:Foo,#3:Foo); C:Foo --> f(#4:Foo,#5:Foo);
    X:Foo --> f(#2:Foo,#1:Foo,#4:Foo); Y:Foo --> f(#3:Foo,#5:Foo)


Advisory: Module FOO redefined.
Introduced module FOO

unify in FOO : g(X:Foo) =? Y:Foo . /\ h(X:Foo) =? h(Z:Foo). .

Solution 1
X:Foo --> #1:Foo ; Y:Foo --> g(#1:Foo); Z:Foo --> #1:Foo



No more solutions.

unify in AC : f(X:Foo,Y:Foo) =? f(A:Foo,B:Foo,C:Foo).

Solution 1
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> f(#3:Foo,#4:Foo); C:Foo --> f(#5:Foo,
    #6:Foo); X:Foo --> f(#3:Foo,#1:Foo,#5:Foo); Y:Foo --> f(#2:Foo,#4:Foo,
    #6:Foo)



Solution 2
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> f(#3:Foo,#4:Foo); C:Foo --> #5:Foo ;
    X:Foo --> f(#3:Foo,#1:Foo,#5:Foo); Y:Foo --> f(#2:Foo,#4:Foo)

Solution 3
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> f(#3:Foo,#4:Foo); C:Foo --> #5:Foo ;
    X:Foo --> f(#3:Foo,#1:Foo); Y:Foo --> f(#2:Foo,#4:Foo,#5:Foo)

Solution 4
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> #3:Foo ; C:Foo --> f(#4:Foo,#5:Foo);
    X:Foo --> f(#3:Foo,#1:Foo,#4:Foo); Y:Foo --> f(#2:Foo,#5:Foo)

Solution 5
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> #3:Foo ; C:Foo --> #4:Foo ; X:Foo --> f(
    #3:Foo,#1:Foo,#4:Foo); Y:Foo --> #2:Foo

Solution 6
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> #3:Foo ; C:Foo --> #4:Foo ; X:Foo --> f(
    #3:Foo,#1:Foo); Y:Foo --> f(#2:Foo,#4:Foo)

Solution 7
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> #3:Foo ; C:Foo --> f(#4:Foo,#5:Foo);
    X:Foo --> f(#1:Foo,#4:Foo); Y:Foo --> f(#2:Foo,#3:Foo,#5:Foo)

Solution 8
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> #3:Foo ; C:Foo --> #4:Foo ; X:Foo --> f(
    #1:Foo,#4:Foo); Y:Foo --> f(#2:Foo,#3:Foo)

Solution 9
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> #3:Foo ; C:Foo --> #4:Foo ; X:Foo -->
    #1:Foo ; Y:Foo --> f(#2:Foo,#3:Foo,#4:Foo)

Solution 10
A:Foo --> #1:Foo ; B:Foo --> f(#2:Foo,#3:Foo); C:Foo --> f(#4:Foo,#5:Foo);
    X:Foo --> f(#2:Foo,#1:Foo,#4:Foo); Y:Foo --> f(#3:Foo,#5:Foo)

Solution 11
A:Foo --> #1:Foo ; B:Foo --> f(#2:Foo,#3:Foo); C:Foo --> #4:Foo ; X:Foo --> f(
    #2:Foo,#1:Foo,#4:Foo); Y:Foo --> #3:Foo

Solution 12
A:Foo --> #1:Foo ; B:Foo --> f(#2:Foo,#3:Foo); C:Foo --> #4:Foo ; X:Foo --> f(
    #2:Foo,#1:Foo); Y:Foo --> f(#3:Foo,#4:Foo)

Solution 13
A:Foo --> #1:Foo ; B:Foo --> #2:Foo ; C:Foo --> f(#3:Foo,#4:Foo); X:Foo --> f(
    #2:Foo,#3:Foo,#1:Foo); Y:Foo --> #4:Foo

Solution 14
A:Foo --> #1:Foo ; B:Foo --> #2:Foo ; C:Foo --> #3:Foo ; X:Foo --> f(#2:Foo,
    #1:Foo); Y:Foo --> #3:Foo

Solution 15
A:Foo --> #1:Foo ; B:Foo --> #2:Foo ; C:Foo --> f(#3:Foo,#4:Foo); X:Foo --> f(
    #3:Foo,#1:Foo); Y:Foo --> f(#2:Foo,#4:Foo)

Solution 16
A:Foo --> #1:Foo ; B:Foo --> #2:Foo ; C:Foo --> #3:Foo ; X:Foo --> f(#3:Foo,
    #1:Foo); Y:Foo --> #2:Foo

Solution 17
A:Foo --> #1:Foo ; B:Foo --> #2:Foo ; C:Foo --> #3:Foo ; X:Foo --> #1:Foo ;
    Y:Foo --> f(#2:Foo,#3:Foo)

Solution 18
A:Foo --> #1:Foo ; B:Foo --> f(#2:Foo,#3:Foo); C:Foo --> f(#4:Foo,#5:Foo);
    X:Foo --> f(#2:Foo,#4:Foo); Y:Foo --> f(#3:Foo,#1:Foo,#5:Foo)

Solution 19
A:Foo --> #1:Foo ; B:Foo --> f(#2:Foo,#3:Foo); C:Foo --> #4:Foo ; X:Foo --> f(
    #2:Foo,#4:Foo); Y:Foo --> f(#3:Foo,#1:Foo)

Solution 20
A:Foo --> #1:Foo ; B:Foo --> f(#2:Foo,#3:Foo); C:Foo --> #4:Foo ; X:Foo -->
    #2:Foo ; Y:Foo --> f(#3:Foo,#1:Foo,#4:Foo)

Solution 21
A:Foo --> #1:Foo ; B:Foo --> #2:Foo ; C:Foo --> f(#3:Foo,#4:Foo); X:Foo --> f(
    #2:Foo,#3:Foo); Y:Foo --> f(#1:Foo,#4:Foo)

Solution 22
A:Foo --> #1:Foo ; B:Foo --> #2:Foo ; C:Foo --> #3:Foo ; X:Foo --> f(#2:Foo,
    #3:Foo); Y:Foo --> #1:Foo

Solution 23
A:Foo --> #1:Foo ; B:Foo --> #2:Foo ; C:Foo --> #3:Foo ; X:Foo --> #2:Foo ;
    Y:Foo --> f(#3:Foo,#1:Foo)

Solution 24
A:Foo --> #1:Foo ; B:Foo --> #2:Foo ; C:Foo --> f(#3:Foo,#4:Foo); X:Foo -->
    #3:Foo ; Y:Foo --> f(#2:Foo,#1:Foo,#4:Foo)

Solution 25
A:Foo --> #1:Foo ; B:Foo --> #2:Foo ; C:Foo --> #3:Foo ; X:Foo --> #3:Foo ;
    Y:Foo --> f(#2:Foo,#1:Foo)

No more solutions.

unify [10] in AC : f(X:Foo,Y:Foo) =? f(A:Foo,B:Foo,C:Foo).

Solution 1
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> f(#3:Foo,#4:Foo); C:Foo --> f(#5:Foo,
    #6:Foo); X:Foo --> f(#3:Foo,#1:Foo,#5:Foo); Y:Foo --> f(#2:Foo,#4:Foo,
    #6:Foo)



Solution 2
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> f(#3:Foo,#4:Foo); C:Foo --> #5:Foo ;
    X:Foo --> f(#3:Foo,#1:Foo,#5:Foo); Y:Foo --> f(#2:Foo,#4:Foo)

Solution 3
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> f(#3:Foo,#4:Foo); C:Foo --> #5:Foo ;
    X:Foo --> f(#3:Foo,#1:Foo); Y:Foo --> f(#2:Foo,#4:Foo,#5:Foo)

Solution 4
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> #3:Foo ; C:Foo --> f(#4:Foo,#5:Foo);
    X:Foo --> f(#3:Foo,#1:Foo,#4:Foo); Y:Foo --> f(#2:Foo,#5:Foo)

Solution 5
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> #3:Foo ; C:Foo --> #4:Foo ; X:Foo --> f(
    #3:Foo,#1:Foo,#4:Foo); Y:Foo --> #2:Foo

Solution 6
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> #3:Foo ; C:Foo --> #4:Foo ; X:Foo --> f(
    #3:Foo,#1:Foo); Y:Foo --> f(#2:Foo,#4:Foo)

Solution 7
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> #3:Foo ; C:Foo --> f(#4:Foo,#5:Foo);
    X:Foo --> f(#1:Foo,#4:Foo); Y:Foo --> f(#2:Foo,#3:Foo,#5:Foo)

Solution 8
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> #3:Foo ; C:Foo --> #4:Foo ; X:Foo --> f(
    #1:Foo,#4:Foo); Y:Foo --> f(#2:Foo,#3:Foo)

Solution 9
A:Foo --> f(#2:Foo,#1:Foo); B:Foo --> #3:Foo ; C:Foo --> #4:Foo ; X:Foo -->
    #1:Foo ; Y:Foo --> f(#2:Foo,#3:Foo,#4:Foo)

Solution 10
A:Foo --> #1:Foo ; B:Foo --> f(#2:Foo,#3:Foo); C:Foo --> f(#4:Foo,#5:Foo);
    X:Foo --> f(#2:Foo,#1:Foo,#4:Foo); Y:Foo --> f(#3:Foo,#5:Foo)


fmod META-LEVEL * (op _`,_ : `[GTermList`] `[GTermList`] -> `[GTermList`] to
    _%_, op _`,_ : `[ParameterDeclList`] `[ParameterDeclList`] ->
    `[ParameterDeclList`] to _%_, op _`,_ : `[RenamingSet`] `[RenamingSet`] ->
    `[RenamingSet`] to _%_) is
  protecting META-VIEW * (op _`,_ : `[GTermList`] `[GTermList`] ->
    `[GTermList`] to _%_, op _`,_ : `[ParameterDeclList`] `[ParameterDeclList`]
    -> `[ParameterDeclList`] to _%_, op _`,_ : `[RenamingSet`] `[RenamingSet`]
    -> `[RenamingSet`] to _%_) .
  sorts Bound MatchPair MatchPair? PrintOption PrintOptionSet Result4Tuple
    Result4Tuple? ResultPair ResultPair? ResultTriple ResultTriple?
    Substitution? Trace Trace? TraceStep Type? UnificandPair UnificationPair
    UnificationPair? UnificationProblem UnificationTriple UnificationTriple? .
  subsort MatchPair < MatchPair? .
  subsort Nat < Bound .
  subsort PrintOption < PrintOptionSet .
  subsort Result4Tuple < Result4Tuple? .
  subsort ResultPair < ResultPair? .
  subsort ResultTriple < ResultTriple? .
  subsort Substitution < Substitution? .
  subsort Trace < Trace? .
  subsort TraceStep < Trace .
  subsort Type < Type? .
  subsort UnificandPair < UnificationProblem .
  subsort UnificationPair < UnificationPair? .
  subsort UnificationTriple < UnificationTriple? .
  op getContext : MatchPair -> Context .
  op getContext : Result4Tuple -> Context .
  op getSubstitution : MatchPair -> Substitution .
  op getSubstitution : Result4Tuple -> Substitution .
  op getSubstitution : ResultTriple -> Substitution .
  op getTerm : Result4Tuple -> Term .
  op getTerm : ResultPair -> Term .
  op getTerm : ResultTriple -> Term .
  op getType : Result4Tuple -> Type .
  op getType : ResultPair -> Type .
  op getType : ResultTriple -> Type .
  op metaPrettyPrint :[Module][QidSet]->[QidSet].
  op _/\_ : UnificationProblem UnificationProblem -> UnificationProblem
    [assoc comm prec 73 ctor] .
  op _=?_ : Term Term -> UnificandPair
    [prec 71 ctor] .
  op __ : PrintOptionSet PrintOptionSet -> PrintOptionSet
    [assoc comm id:(none).PrintOptionSet ctor] .
  op __ : Trace Trace -> Trace
    [assoc id:(nil).Trace format(d n d)ctor] .
  op `{_`,_`,_`,_`} : Term Type Substitution Context -> Result4Tuple
    [ctor] .
  op `{_`,_`,_`} : Substitution Substitution Nat -> UnificationTriple
    [ctor] .
  op `{_`,_`,_`} : Term Type Rule -> TraceStep
    [ctor] .
  op `{_`,_`,_`} : Term Type Substitution -> ResultTriple
    [ctor] .
  op `{_`,_`} : Substitution Context -> MatchPair
    [ctor] .
  op `{_`,_`} : Substitution Nat -> UnificationPair
    [ctor] .
  op `{_`,_`} : Term Type -> ResultPair
    [ctor] .
  op ambiguity : ResultPair ResultPair -> ResultPair?
    [ctor] .
  op anyType : -> Type?
    [ctor] .
  op completeName :[Module][QidSet]->[QidSet]
    [special(id-hook MetaLevelOpSymbol(metaCompleteName)op-hook shareWith(
    metaReduce : Module QidSet ~> ResultPair?))] .
  op downTerm : Term Universal -> Universal
    [poly(2 0)special(id-hook MetaLevelOpSymbol(metaDownTerm)op-hook shareWith(
    metaReduce : Module QidSet ~> ResultPair?))] .
  op failure : -> Result4Tuple?
    [ctor] .
  op failure : -> ResultPair?
    [ctor] .
  op failure : -> ResultTriple?
    [ctor] .
  op failure : -> Trace?
    [ctor] .
  op flat : -> PrintOption
    [ctor] .
  op format : -> PrintOption
    [ctor] .
  op getKind :[Module][QidSet]->[QidSet]
    [special(id-hook MetaLevelOpSymbol(metaGetKind)op-hook shareWith(metaReduce
    : Module QidSet ~> ResultPair?))] .
  op getKinds :[Module]->[QidSet]
    [special(id-hook MetaLevelOpSymbol(metaGetKinds)op-hook shareWith(
    metaReduce : Module QidSet ~> ResultPair?))] .
  op glbSorts :[Module][QidSet][QidSet]->[QidSet]
    [special(id-hook MetaLevelOpSymbol(metaGlbSorts)op-hook shareWith(
    metaReduce : Module QidSet ~> ResultPair?))] .
  op leastSort :[Module][QidSet]->[QidSet]
    [special(id-hook MetaLevelOpSymbol(metaLeastSort)op-hook shareWith(
    metaReduce : Module QidSet ~> ResultPair?))] .
  op lesserSorts :[Module][QidSet]->[QidSet]
    [special(id-hook MetaLevelOpSymbol(metaLesserSorts)op-hook shareWith(
    metaReduce : Module QidSet ~> ResultPair?))] .
  op maximalAritySet :[Module][QidSet][QidSet][QidSet]->[QidSet]
    [special(id-hook MetaLevelOpSymbol(metaMaximalAritySet)op-hook shareWith(
    metaReduce : Module QidSet ~> ResultPair?))] .
  op maximalSorts :[Module][QidSet]->[QidSet]
    [special(id-hook MetaLevelOpSymbol(metaMaximalSorts)op-hook shareWith(
    metaReduce : Module QidSet ~> ResultPair?))] .
  op metaApply :[Module][QidSet][QidSet][Substitution?][FindResult]->[
    ResultTriple?]
    [special(id-hook MetaLevelOpSymbol(metaApply)op-hook shareWith(metaReduce :
    Module QidSet ~> ResultPair?))] .
  op metaDisjointUnify :[Module][UnificationProblem][FindResult][FindResult]->[
    UnificationTriple?]
    [special(id-hook MetaLevelOpSymbol(metaDisjointUnify)op-hook shareWith(
    metaReduce : Module QidSet ~> ResultPair?))] .
  op metaFrewrite :[Module][QidSet][FindResult][FindResult]->[ResultPair?]
    [special(id-hook MetaLevelOpSymbol(metaFrewrite)op-hook shareWith(
    metaReduce : Module QidSet ~> ResultPair?))] .
  op metaMatch :[Module][QidSet][QidSet][Condition][FindResult]->[
    Substitution?]
    [special(id-hook MetaLevelOpSymbol(metaMatch)op-hook shareWith(metaReduce :
    Module QidSet ~> ResultPair?))] .
  op metaNarrow :[Module][QidSet][QidSet][FindResult][Bool][FindResult]->[
    ResultPair?]
    [special(id-hook MetaLevelOpSymbol(metaNarrow2)op-hook shareWith(metaReduce
    : Module QidSet ~> ResultPair?))] .
  op metaNarrow :[Module][QidSet][QidSet][QidSet][FindResult][FindResult]->[
    ResultTriple?]
    [special(id-hook MetaLevelOpSymbol(metaNarrow)op-hook shareWith(metaReduce
    : Module QidSet ~> ResultPair?))] .
  op metaNormalize :[Module][QidSet]->[ResultPair?]
    [special(id-hook MetaLevelOpSymbol(metaNormalize)op-hook shareWith(
    metaReduce : Module QidSet ~> ResultPair?))] .
  op metaParse :[Module][QidSet][QidSet]->[ResultPair?]
    [special(id-hook MetaLevelOpSymbol(metaParse)op-hook shareWith(metaReduce :
    Module QidSet ~> ResultPair?))] .
  op metaPrettyPrint :[Module][QidSet][PrintOptionSet]->[QidSet]
    [special(id-hook MetaLevelOpSymbol(metaPrettyPrint)op-hook shareWith(
    metaReduce : Module QidSet ~> ResultPair?))] .
  op metaReduce :[Module][QidSet]->[ResultPair?]
    [special(id-hook MetaLevelOpSymbol(metaReduce)op-hook qidSymbol(<Qids> : ~>
    Qid)op-hook metaTermSymbol(_`[_`] : Qid NeGroundTermList ~>
    GroundTerm)op-hook metaArgSymbol(_%_ : NeGroundTermList GroundTermList ~>
    NeGroundTermList)op-hook assignmentSymbol(_<-_ : Variable Term ~>
    Assignment)op-hook emptySubstitutionSymbol(none : ~> Substitution)op-hook
    substitutionSymbol(_;_ : Substitution Substitution ~> Substitution)op-hook
    holeSymbol(`[`] : ~> Context)op-hook headerSymbol(_`{_`} : Qid
    ParameterDeclList ~> Header)op-hook parameterDeclSymbol(_::_ : Sort
    ModuleExpression ~> ParameterDecl)op-hook parameterDeclListSymbol(_%_ :
    ParameterDeclList ParameterDeclList ~> ParameterDeclList)op-hook
    protectingSymbol(protecting_. : ModuleExpression ~> Import)op-hook
    extendingSymbol(extending_. : ModuleExpression ~> Import)op-hook
    includingSymbol(including_. : ModuleExpression ~> Import)op-hook
    nilImportListSymbol(nil : ~> ImportList)op-hook importListSymbol(__ :
    ImportList ImportList ~> ImportList)op-hook emptySortSetSymbol(none : ~>
    QidSet)op-hook sortSetSymbol(_;_ : QidSet QidSet ~> QidSet)op-hook
    subsortSymbol(subsort_<_. : Sort Sort ~> SubsortDecl)op-hook
    emptySubsortDeclSetSymbol(none : ~> SubsortDeclSet)op-hook
    subsortDeclSetSymbol(__ : SubsortDeclSet SubsortDeclSet ~>
    SubsortDeclSet)op-hook nilQidListSymbol(nil : ~> QidList)op-hook
    qidListSymbol(__ : QidList QidList ~> QidList)op-hook succSymbol(s_ : Nat
    ~> NzNat)op-hook natListSymbol(__ : NatList NatList ~> NatList)op-hook
    unboundedSymbol(unbounded : ~> Bound)op-hook stringSymbol(<Strings> : ~>
    Char)op-hook sortRenamingSymbol(sort_to_ : Qid Qid ~> Renaming)op-hook
    opRenamingSymbol(op_to_`[_`] : Qid Qid AttrSet ~> Renaming)op-hook
    opRenamingSymbol2(op_:_->_to_`[_`] : Qid TypeList Type Qid AttrSet ~>
    Renaming)op-hook labelRenamingSymbol(label_to_ : Qid Qid ~>
    Renaming)op-hook renamingSetSymbol(_%_ : RenamingSet RenamingSet ~>
    RenamingSet)op-hook sumSymbol(_+_ : ModuleExpression ModuleExpression ~>
    ModuleExpression)op-hook renamingSymbol(_*`(_`) : ModuleExpression
    RenamingSet ~> ModuleExpression)op-hook instantiationSymbol(_`{_`} :
    ModuleExpression ParameterList ~> ModuleExpression)op-hook termHookSymbol(
    term-hook : Qid Term ~> Hook)op-hook hookListSymbol(__ : HookList HookList
    ~> HookList)op-hook idHookSymbol(id-hook : Qid QidList ~> Hook)op-hook
    opHookSymbol(op-hook : Qid Qid QidList Qid ~> Hook)op-hook assocSymbol(
    assoc : ~> Attr)op-hook commSymbol(comm : ~> Attr)op-hook idemSymbol(idem :
    ~> Attr)op-hook iterSymbol(iter : ~> Attr)op-hook idSymbol(id : Term ~>
    Attr)op-hook leftIdSymbol(left-id : Term ~> Attr)op-hook rightIdSymbol(
    right-id : Term ~> Attr)op-hook stratSymbol(strat : NeNatList ~>
    Attr)op-hook memoSymbol(memo : ~> Attr)op-hook precSymbol(prec : Nat ~>
    Attr)op-hook gatherSymbol(gather : QidList ~> Attr)op-hook formatSymbol(
    format : QidList ~> Attr)op-hook ctorSymbol(ctor : ~> Attr)op-hook
    frozenSymbol(frozen : NeNatList ~> Attr)op-hook polySymbol(poly : NeNatList
    ~> Attr)op-hook configSymbol(config : ~> Attr)op-hook objectSymbol(object :
    ~> Attr)op-hook msgSymbol(msg : ~> Attr)op-hook specialSymbol(special :
    NeHookList ~> Attr)op-hook labelSymbol(label : Qid ~> Attr)op-hook
    metadataSymbol(metadata : String ~> Attr)op-hook owiseSymbol(owise : ~>
    Attr)op-hook nonexecSymbol(nonexec : ~> Attr)op-hook printSymbol(print :
    QidList ~> Attr)op-hook emptyAttrSetSymbol(none : ~> AttrSet)op-hook
    attrSetSymbol(__ : AttrSet AttrSet ~> AttrSet)op-hook opDeclSymbol(
    op_:_->_`[_`]. : Qid TypeList Type AttrSet ~> OpDecl)op-hook
    opDeclSetSymbol(__ : OpDeclSet OpDeclSet ~> OpDeclSet)op-hook
    emptyOpDeclSetSymbol(none : ~> OpDeclSet)op-hook noConditionSymbol(nil : ~>
    EqCondition)op-hook equalityConditionSymbol(_=_ : Term Term ~>
    EqCondition)op-hook sortTestConditionSymbol(_:_ : Term Sort ~>
    EqCondition)op-hook matchConditionSymbol(_:=_ : Term Term ~>
    EqCondition)op-hook rewriteConditionSymbol(_=>_ : Term Term ~>
    Condition)op-hook conjunctionSymbol(_/\_ : EqCondition EqCondition ~>
    EqCondition)op-hook mbSymbol(mb_:_`[_`]. : Term Sort AttrSet ~>
    MembAx)op-hook cmbSymbol(cmb_:_if_`[_`]. : Term Sort EqCondition AttrSet ~>
    MembAx)op-hook emptyMembAxSetSymbol(none : ~> MembAxSet)op-hook
    membAxSetSymbol(__ : MembAxSet MembAxSet ~> MembAxSet)op-hook eqSymbol(
    eq_=_`[_`]. : Term Term AttrSet ~> Equation)op-hook ceqSymbol(
    ceq_=_if_`[_`]. : Term Term EqCondition AttrSet ~> Equation)op-hook
    emptyEquationSetSymbol(none : ~> EquationSet)op-hook equationSetSymbol(__ :
    EquationSet EquationSet ~> EquationSet)op-hook rlSymbol(rl_=>_`[_`]. : Term
    Term AttrSet ~> Rule)op-hook crlSymbol(crl_=>_if_`[_`]. : Term Term
    Condition AttrSet ~> Rule)op-hook emptyRuleSetSymbol(none : ~>
    RuleSet)op-hook ruleSetSymbol(__ : RuleSet RuleSet ~> RuleSet)op-hook
    fmodSymbol(fmod_is_sorts_.____endfm : Header ImportList SortSet
    SubsortDeclSet OpDeclSet MembAxSet EquationSet ~> FModule)op-hook
    fthSymbol(fth_is_sorts_.____endfth : Qid ImportList SortSet SubsortDeclSet
    OpDeclSet MembAxSet EquationSet ~> FTheory)op-hook modSymbol(
    mod_is_sorts_._____endm : Header ImportList SortSet SubsortDeclSet
    OpDeclSet MembAxSet EquationSet RuleSet ~> SModule)op-hook thSymbol(
    th_is_sorts_._____endth : Qid ImportList SortSet SubsortDeclSet OpDeclSet
    MembAxSet EquationSet RuleSet ~> STheory)op-hook sortMappingSymbol(
    sort_to_. : Sort Sort ~> SortMapping)op-hook emptySortMappingSetSymbol(none
    : ~> SortMappingSet)op-hook sortMappingSetSymbol(__ : SortMappingSet
    SortMappingSet ~> SortMappingSet)op-hook opMappingSymbol(op_to_. : Qid Qid
    ~> OpMapping)op-hook opSpecificMappingSymbol(op_:_->_to_. : Qid TypeList
    Type Qid ~> OpMapping)op-hook opTermMappingSymbol(op_to`term_. : Term Term
    ~> OpMapping)op-hook emptyOpMappingSetSymbol(none : ~> OpMappingSet)op-hook
    opMappingSetSymbol(__ : OpMappingSet OpMappingSet ~> OpMappingSet)op-hook
    viewSymbol(view_from_to_is__endv : Header ModuleExpression ModuleExpression
    SortMappingSet OpMappingSet ~> View)op-hook anyTypeSymbol(anyType : ~>
    Type?)op-hook unificandPairSymbol(_=?_ : Term Term ~> UnificandPair)op-hook
    unificationConjunctionSymbol(_/\_ : UnificationProblem UnificationProblem
    ~> UnificationProblem)op-hook resultPairSymbol(`{_`,_`} : Term Type ~>
    ResultPair)op-hook resultTripleSymbol(`{_`,_`,_`} : Term Type Substitution
    ~> ResultTriple)op-hook result4TupleSymbol(`{_`,_`,_`,_`} : Term Type
    Substitution Context ~> Result4Tuple)op-hook matchPairSymbol(`{_`,_`} :
    Substitution Context ~> MatchPair)op-hook unificationPairSymbol(`{_`,_`} :
    Substitution Nat ~> UnificationPair)op-hook unificationTripleSymbol(
    `{_`,_`,_`} : Substitution Substitution Nat ~> UnificationTriple)op-hook
    traceStepSymbol(`{_`,_`,_`} : Term Type Rule ~> TraceStep)op-hook
    nilTraceSymbol(nil : ~> Trace)op-hook traceSymbol(__ : Trace Trace ~>
    Trace)op-hook noParseSymbol(noParse : Nat ~> ResultPair?)op-hook
    ambiguitySymbol(ambiguity : ResultPair ResultPair ~> ResultPair?)op-hook
    failure2Symbol(failure : ~> ResultPair?)op-hook failure3Symbol(failure : ~>
    ResultTriple?)op-hook failure4Symbol(failure : ~> Result4Tuple?)op-hook
    noUnifierPairSymbol(noUnifier : ~> UnificationPair?)op-hook
    noUnifierTripleSymbol(noUnifier : ~> UnificationTriple?)op-hook
    noMatchSubstSymbol(noMatch : ~> Substitution?)op-hook noMatchPairSymbol(
    noMatch : ~> MatchPair?)op-hook failureTraceSymbol(failure : ~>
    Trace?)op-hook mixfixSymbol(mixfix : ~> PrintOption)op-hook
    withParensSymbol(with-parens : ~> PrintOption)op-hook flatSymbol(flat : ~>
    PrintOption)op-hook formatPrintOptionSymbol(format : ~> PrintOption)op-hook
    numberSymbol(number : ~> PrintOption)op-hook ratSymbol(rat : ~>
    PrintOption)op-hook emptyPrintOptionSetSymbol(none : ~>
    PrintOptionSet)op-hook printOptionSetSymbol(__ : PrintOptionSet
    PrintOptionSet ~> PrintOptionSet)term-hook trueTerm(true)term-hook
    falseTerm(false))] .
  op metaRewrite :[Module][QidSet][FindResult]->[ResultPair?]
    [special(id-hook MetaLevelOpSymbol(metaRewrite)op-hook shareWith(metaReduce
    : Module QidSet ~> ResultPair?))] .
  op metaSearch :[Module][QidSet][QidSet][Condition][QidSet][FindResult][
    FindResult]->[ResultTriple?]
    [special(id-hook MetaLevelOpSymbol(metaSearch)op-hook shareWith(metaReduce
    : Module QidSet ~> ResultPair?))] .
  op metaSearchPath :[Module][QidSet][QidSet][Condition][QidSet][FindResult][
    FindResult]->[Trace?]
    [special(id-hook MetaLevelOpSymbol(metaSearchPath)op-hook shareWith(
    metaReduce : Module QidSet ~> ResultPair?))] .
  op metaUnify :[Module][UnificationProblem][FindResult][FindResult]->[
    UnificationPair?]
    [special(id-hook MetaLevelOpSymbol(metaUnify)op-hook shareWith(metaReduce :
    Module QidSet ~> ResultPair?))] .
  op metaXapply :[Module][QidSet][QidSet][Substitution?][FindResult][
    FindResult][FindResult]->[Result4Tuple?]
    [special(id-hook MetaLevelOpSymbol(metaXapply)op-hook shareWith(metaReduce
    : Module QidSet ~> ResultPair?))] .
  op metaXmatch :[Module][QidSet][QidSet][Condition][FindResult][FindResult][
    FindResult]->[MatchPair?]
    [special(id-hook MetaLevelOpSymbol(metaXmatch)op-hook shareWith(metaReduce
    : Module QidSet ~> ResultPair?))] .
  op minimalSorts :[Module][QidSet]->[QidSet]
    [special(id-hook MetaLevelOpSymbol(metaMinimalSorts)op-hook shareWith(
    metaReduce : Module QidSet ~> ResultPair?))] .
  op mixfix : -> PrintOption
    [ctor] .
  op nil : -> Trace
    [ctor] .
  op noMatch : -> MatchPair?
    [ctor] .
  op noMatch : -> Substitution?
    [ctor] .
  op noParse : Nat -> ResultPair?
    [ctor] .
  op noUnifier : -> UnificationPair?
    [ctor] .
  op noUnifier : -> UnificationTriple?
    [ctor] .
  op none : -> PrintOptionSet
    [ctor] .
  op number : -> PrintOption
    [ctor] .
  op rat : -> PrintOption
    [ctor] .
  op sameKind :[Module][QidSet][QidSet]->[Bool]
    [special(id-hook MetaLevelOpSymbol(metaSameKind)op-hook shareWith(
    metaReduce : Module QidSet ~> ResultPair?))] .
  op sortLeq :[Module][QidSet][QidSet]->[Bool]
    [special(id-hook MetaLevelOpSymbol(metaSortLeq)op-hook shareWith(metaReduce
    : Module QidSet ~> ResultPair?))] .
  op unbounded : -> Bound
    [ctor] .
  op upEqs :[QidSet][Bool]->[EquationSet]
    [special(id-hook MetaLevelOpSymbol(metaUpEqs)op-hook shareWith(metaReduce :
    Module QidSet ~> ResultPair?))] .
  op upImports :[QidSet]->[ImportList]
    [special(id-hook MetaLevelOpSymbol(metaUpImports)op-hook shareWith(
    metaReduce : Module QidSet ~> ResultPair?))] .
  op upMbs :[QidSet][Bool]->[MembAxSet]
    [special(id-hook MetaLevelOpSymbol(metaUpMbs)op-hook shareWith(metaReduce :
    Module QidSet ~> ResultPair?))] .
  op upModule :[QidSet][Bool]->[Module]
    [special(id-hook MetaLevelOpSymbol(metaUpModule)op-hook shareWith(
    metaReduce : Module QidSet ~> ResultPair?))] .
  op upOpDecls :[QidSet][Bool]->[OpDeclSet]
    [special(id-hook MetaLevelOpSymbol(metaUpOpDecls)op-hook shareWith(
    metaReduce : Module QidSet ~> ResultPair?))] .
  op upRls :[QidSet][Bool]->[RuleSet]
    [special(id-hook MetaLevelOpSymbol(metaUpRls)op-hook shareWith(metaReduce :
    Module QidSet ~> ResultPair?))] .
  op upSorts :[QidSet][Bool]->[QidSet]
    [special(id-hook MetaLevelOpSymbol(metaUpSorts)op-hook shareWith(metaReduce
    : Module QidSet ~> ResultPair?))] .
  op upSubsortDecls :[QidSet][Bool]->[SubsortDeclSet]
    [special(id-hook MetaLevelOpSymbol(metaUpSubsortDecls)op-hook shareWith(
    metaReduce : Module QidSet ~> ResultPair?))] .
  op upTerm : Universal -> Term
    [poly(1)special(id-hook MetaLevelOpSymbol(metaUpTerm)op-hook shareWith(
    metaReduce : Module QidSet ~> ResultPair?))] .
  op upView :[QidSet]->[View]
    [special(id-hook MetaLevelOpSymbol(metaUpView)op-hook shareWith(metaReduce
    : Module QidSet ~> ResultPair?))] .
  op wellFormed : Module -> Bool
    [special(id-hook MetaLevelOpSymbol(metaWellFormedModule)op-hook shareWith(
    metaReduce : Module QidSet ~> ResultPair?))] .
  op wellFormed :[Module][QidSet]->[Bool]
    [special(id-hook MetaLevelOpSymbol(metaWellFormedTerm)op-hook shareWith(
    metaReduce : Module QidSet ~> ResultPair?))] .
  op wellFormed :[Module][Substitution?]->[Bool]
    [special(id-hook MetaLevelOpSymbol(metaWellFormedSubstitution)op-hook
    shareWith(metaReduce : Module QidSet ~> ResultPair?))] .
  op with-parens : -> PrintOption
    [ctor] .
  eq getContext({T:Term,T:Type,S:Substitution,C:Context})
    = C:Context .
  eq getContext({S:Substitution,C:Context})
    = C:Context .
  eq getSubstitution({T:Term,T:Type,S:Substitution,C:Context})
    = S:Substitution .
  eq getSubstitution({T:Term,T:Type,S:Substitution})
    = S:Substitution .
  eq getSubstitution({S:Substitution,C:Context})
    = S:Substitution .
  eq getTerm({T:Term,T:Type,S:Substitution,C:Context})
    = T:Term .
  eq getTerm({T:Term,T:Type,S:Substitution})
    = T:Term .
  eq getTerm({T:Term,T:Type})
    = T:Term .
  eq getType({T:Term,T:Type,S:Substitution,C:Context})
    = T:Type .
  eq getType({T:Term,T:Type,S:Substitution})
    = T:Type .
  eq getType({T:Term,T:Type})
    = T:Type .
  eq metaPrettyPrint(M:Module,T:Term)
    = metaPrettyPrint(M:Module,T:Term,mixfix flat format number rat) .
endfm

Advisory: redefining module FOO.
    DEADLOCK-FREE mod. expr. available Oct. 28th 2008

reduce in BAR :
  check(f)
result Bool :
  true

    DEADLOCK-FREE mod. expr. available Oct. 28th 2008

fmod OCL-DATATYPE-COLLECTIONS is
  including BOOL .
  including OCL-COLLECTIONS{Int}.
endfm

Advisory: redefining module OCL-COLLECTIONS.
Advisory: redefining module OCL-DATATYPE-COLLECTIONS.
    DEADLOCK-FREE mod. expr. available Oct. 28th 2008

fmod OCL-DATATYPE-COLLECTIONS is
  including BOOL .
  including OCL-COLLECTIONS{Int} * (op empty-col to empty-col#Int) .
endfm

Introduced module FOO

reduce in FOO{Int}:
  f(3)
result Foo{Int} :
  g

Warning: Parse error in in FOO{Int}*(op 3 to term three <---*HERE*
Error: no parse for in FOO{Int}*(op 3 to term three): f(three).

Warning: Parse error in f(2 + <---*HERE*
Error: no parse for f(2 + 3)

reduce in FOO`{Int`}*`(op_+_to_plus_`) :
  f(2 plus 3)
result Foo{Int} :
  g

Introduced module BAR

reduce in BAR :
  f('q)
result Foo{Qid} :
  g

fmod BAR is
  including BOOL .
  protecting FOO{Qid} + QID .
endfm

Error: Module Qid not in database.
Error: Module FOO{Qid} + Qid not in database.

fmod FOO{Qid} + QID is
  including FOO{Qid}.
  including QID .
endfm

fmod BAR is
  sorts Bool Char FindResult Foo{Qid}Nat NzNat Qid String Zero .
  subsort Char < String .
  subsort Nat < FindResult .
  subsort NzNat < Nat .
  subsort Zero < Nat .
  op f : Qid -> Foo{Qid}.
  op g : -> Foo{Qid}.
  op 0 : -> Zero
    [ctor] .
  op <Qids> : -> Qid
    [special(id-hook QuotedIdentifierSymbol)] .
  op <Strings> : -> Char
    [special(id-hook StringSymbol)] .
  op <Strings> : -> String
    [special(id-hook StringSymbol)] .
  op _&_ : Nat Nat -> Nat
    [assoc comm prec 53 special(id-hook ACU_NumberOpSymbol(&)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op _*_ : Nat Nat -> Nat
    [assoc comm prec 31 special(id-hook ACU_NumberOpSymbol(*)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op _*_ : NzNat NzNat -> NzNat
    [assoc comm prec 31 special(id-hook ACU_NumberOpSymbol(*)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op _+_ : Nat Nat -> Nat
    [assoc comm prec 33 special(id-hook ACU_NumberOpSymbol(+)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op _+_ : NzNat Nat -> NzNat
    [assoc comm prec 33 special(id-hook ACU_NumberOpSymbol(+)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op _+_ : String String -> String
    [prec 33 gather(E e)special(id-hook StringOpSymbol(+)op-hook stringSymbol(
    <Strings> : ~> Char))] .
  op _<<_ : Nat Nat -> Nat
    [prec 35 gather(E e)special(id-hook NumberOpSymbol(<<)op-hook succSymbol(s_
    : Nat ~> NzNat))] .
  op _<=_ : Nat Nat -> Bool
    [prec 37 special(id-hook NumberOpSymbol(<=)op-hook succSymbol(s_ : Nat ~>
    NzNat)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _<=_ : String String -> Bool
    [prec 37 special(id-hook StringOpSymbol(<=)op-hook stringSymbol(<Strings> :
    ~> Char)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _<_ : Nat Nat -> Bool
    [prec 37 special(id-hook NumberOpSymbol(<)op-hook succSymbol(s_ : Nat ~>
    NzNat)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _<_ : String String -> Bool
    [prec 37 special(id-hook StringOpSymbol(<)op-hook stringSymbol(<Strings> :
    ~> Char)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _=/=_ : Universal Universal -> Bool
    [poly(1 2)prec 51 special(id-hook EqualitySymbol term-hook equalTerm(
    false)term-hook notEqualTerm(true))] .
  op _==_ : Universal Universal -> Bool
    [poly(1 2)prec 51 special(id-hook EqualitySymbol term-hook equalTerm(
    true)term-hook notEqualTerm(false))] .
  op _>=_ : Nat Nat -> Bool
    [prec 37 special(id-hook NumberOpSymbol(>=)op-hook succSymbol(s_ : Nat ~>
    NzNat)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _>=_ : String String -> Bool
    [prec 37 special(id-hook StringOpSymbol(>=)op-hook stringSymbol(<Strings> :
    ~> Char)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _>>_ : Nat Nat -> Nat
    [prec 35 gather(E e)special(id-hook NumberOpSymbol(>>)op-hook succSymbol(s_
    : Nat ~> NzNat))] .
  op _>_ : Nat Nat -> Bool
    [prec 37 special(id-hook NumberOpSymbol(>)op-hook succSymbol(s_ : Nat ~>
    NzNat)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _>_ : String String -> Bool
    [prec 37 special(id-hook StringOpSymbol(>)op-hook stringSymbol(<Strings> :
    ~> Char)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _^_ : Nat Nat -> Nat
    [prec 29 gather(E e)special(id-hook NumberOpSymbol(^)op-hook succSymbol(s_
    : Nat ~> NzNat))] .
  op _^_ : NzNat Nat -> NzNat
    [prec 29 gather(E e)special(id-hook NumberOpSymbol(^)op-hook succSymbol(s_
    : Nat ~> NzNat))] .
  op _and_ : Bool Bool -> Bool
    [assoc comm prec 55] .
  op _divides_ : NzNat Nat -> Bool
    [prec 51 special(id-hook NumberOpSymbol(divides)op-hook succSymbol(s_ : Nat
    ~> NzNat)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _implies_ : Bool Bool -> Bool
    [prec 61 gather(e E)] .
  op _or_ : Bool Bool -> Bool
    [assoc comm prec 59] .
  op _quo_ : Nat NzNat -> Nat
    [prec 31 gather(E e)special(id-hook NumberOpSymbol(quo)op-hook succSymbol(
    s_ : Nat ~> NzNat))] .
  op _rem_ : Nat NzNat -> Nat
    [prec 31 gather(E e)special(id-hook NumberOpSymbol(rem)op-hook succSymbol(
    s_ : Nat ~> NzNat))] .
  op _xor_ : Bool Bool -> Bool
    [assoc comm prec 57] .
  op _xor_ : Nat Nat -> Nat
    [assoc comm prec 55 special(id-hook ACU_NumberOpSymbol(xor)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op _|_ : Nat Nat -> Nat
    [assoc comm prec 57 special(id-hook ACU_NumberOpSymbol(|)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op _|_ : NzNat Nat -> NzNat
    [assoc comm prec 57 special(id-hook ACU_NumberOpSymbol(|)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op ascii : Char -> Nat
    [special(id-hook StringOpSymbol(ascii)op-hook stringSymbol(<Strings> : ~>
    Char)op-hook succSymbol(s_ : Nat ~> NzNat))] .
  op char :[FindResult]->[String]
    [special(id-hook StringOpSymbol(char)op-hook stringSymbol(<Strings> : ~>
    Char)op-hook succSymbol(s_ : Nat ~> NzNat))] .
  op false : -> Bool
    [ctor special(id-hook SystemFalse)] .
  op find : String String Nat -> FindResult
    [special(id-hook StringOpSymbol(find)op-hook stringSymbol(<Strings> : ~>
    Char)op-hook succSymbol(s_ : Nat ~> NzNat)term-hook notFoundTerm(
    notFound))] .
  op gcd : Nat Nat -> Nat
    [assoc comm special(id-hook ACU_NumberOpSymbol(gcd)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op gcd : NzNat Nat -> NzNat
    [assoc comm special(id-hook ACU_NumberOpSymbol(gcd)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op if_then_else_fi : Bool Universal Universal -> Universal
    [poly(2 3 0)special(id-hook BranchSymbol term-hook 1(true)term-hook 2(
    false))] .
  op lcm : Nat Nat -> Nat
    [assoc comm special(id-hook ACU_NumberOpSymbol(lcm)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op lcm : NzNat NzNat -> NzNat
    [assoc comm special(id-hook ACU_NumberOpSymbol(lcm)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op length : String -> Nat
    [special(id-hook StringOpSymbol(length)op-hook stringSymbol(<Strings> : ~>
    Char)op-hook succSymbol(s_ : Nat ~> NzNat))] .
  op max : Nat Nat -> Nat
    [assoc comm special(id-hook ACU_NumberOpSymbol(max)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op max : NzNat Nat -> NzNat
    [assoc comm special(id-hook ACU_NumberOpSymbol(max)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op min : Nat Nat -> Nat
    [assoc comm special(id-hook ACU_NumberOpSymbol(min)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op min : NzNat NzNat -> NzNat
    [assoc comm special(id-hook ACU_NumberOpSymbol(min)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op modExp :[Nat][Nat][Nat]->[Nat]
    [special(id-hook NumberOpSymbol(modExp)op-hook succSymbol(s_ : Nat ~>
    NzNat))] .
  op notFound : -> FindResult
    [ctor] .
  op not_ : Bool -> Bool
    [prec 53] .
  op qid :[String]->[Qid]
    [special(id-hook QuotedIdentifierOpSymbol(qid)op-hook
    quotedIdentifierSymbol(<Qids> : ~> Qid)op-hook stringSymbol(<Strings> : ~>
    Char))] .
  op rfind : String String Nat -> FindResult
    [special(id-hook StringOpSymbol(rfind)op-hook stringSymbol(<Strings> : ~>
    Char)op-hook succSymbol(s_ : Nat ~> NzNat)term-hook notFoundTerm(
    notFound))] .
  op s_ : Nat -> NzNat
    [ctor iter special(id-hook SuccSymbol term-hook zeroTerm(0))] .
  op sd : Nat Nat -> Nat
    [comm special(id-hook CUI_NumberOpSymbol(sd)op-hook succSymbol(s_ : Nat ~>
    NzNat))] .
  op string : Qid -> String
    [special(id-hook QuotedIdentifierOpSymbol(string)op-hook
    quotedIdentifierSymbol(<Qids> : ~> Qid)op-hook stringSymbol(<Strings> : ~>
    Char))] .
  op substr : String Nat Nat -> String
    [special(id-hook StringOpSymbol(substr)op-hook stringSymbol(<Strings> : ~>
    Char)op-hook succSymbol(s_ : Nat ~> NzNat))] .
  op true : -> Bool
    [ctor special(id-hook SystemTrue)] .
  eq A:Bool and A:Bool
    = A:Bool .
  eq A:Bool and(B:Bool xor C:Bool)
    = A:Bool and B:Bool xor A:Bool and C:Bool .
  eq false and A:Bool
    = false .
  eq true and A:Bool
    = A:Bool .
  eq A:Bool implies B:Bool
    = not(A:Bool xor A:Bool and B:Bool) .
  eq A:Bool or B:Bool
    = A:Bool and B:Bool xor A:Bool xor B:Bool .
  eq A:Bool xor A:Bool
    = false .
  eq false xor A:Bool
    = A:Bool .
  eq f(X:Qid)
    = g .
  eq not A:Bool
    = true xor A:Bool .
endfm

Introduced module BAZ

reduce in BAZ :
  f('q)
result Foo{Qid} :
  g

fmod BAZ is
  including BOOL .
  protecting FOO{Qid} + QID + BAR .
endfm

fmod FOO{Qid} + QID + BAR is
  including FOO{Qid}.
  including QID .
  including BAR .
endfm

==========================================
reduce in FULL-MAUDE : getVariants(upModule('MY-NAT-SET, true), '|_|['_`,_[
    'E:Nat,'S:NatSet]], 1, irreducible ACUUnify) .
Warning: no loop state.
Advisory: attempting to reinitialize loop.
result VariantFour: {'|_|['_`,_['E:Nat,'S:NatSet]],(none).Substitution,(
    none).Substitution,2}
==========================================
reduce in FULL-MAUDE : getVariants(upModule('MY-NAT-SET, true), '_in_['0:Nat,
    '|_|['union['_`,_['E:Nat,'S:NatSet],'_`,_['empty.NatSet,'0.Nat]]]], 1,
    irreducible ACUUnify) .
result VariantFour: {'_in_['0:Nat,'|_|['union['_`,_['E:Nat,'S:NatSet],'_`,_[
    'empty.NatSet,'0.Nat]]]],(none).Substitution,(none).Substitution,2}
    DEADLOCK-FREE mod. expr. available Oct. 28th 2008

Introduced module A

fmod A is
  including BOOL .
  including NAT .
  sorts A B .
  subsort B < A .
  op <_> : Nat ->[B].
endfm

Introduced module DINING-PHILOSOPHERS

frewrite in DINING-PHILOSOPHERS :
  initState
result Configuration :
  chopstick(1)chopstick(2)chopstick(3)chopstick(4)chopstick(5)< 1 : Philosopher
    | noOfEats : 125,noOfSticks : 0,state : thinking > < 2 : Philosopher |
    noOfEats : 0,noOfSticks : 0,state : hungry > < 3 : Philosopher | noOfEats :
    0,noOfSticks : 0,state : hungry > < 4 : Philosopher | noOfEats : 0,
    noOfSticks : 0,state : hungry > < 5 : Philosopher | noOfEats : 124,
    noOfSticks : 0,state : hungry >

search [1] in DINING-PHILOSOPHERS : initState =>! C:Configuration .

Solution 1
C:Configuration --> < 1 : Philosopher | noOfEats : 0,noOfSticks : 1,state :
    hungry > < 2 : Philosopher | noOfEats : 0,noOfSticks : 1,state : hungry > <
    3 : Philosopher | noOfEats : 0,noOfSticks : 1,state : hungry > < 4 :
    Philosopher | noOfEats : 0,noOfSticks : 1,state : hungry > < 5 :
    Philosopher | noOfEats : 0,noOfSticks : 1,state : hungry >


Introduced module POPULATION

Introduced module SYNCHR-DIVORCE

Introduced module BAD-SEPARATION

search [1] in BAD-SEPARATION : < "JR" : Person | age : 50,status : married(
    "Sue Ellen")> < "Sue Ellen" : Person | age : 46,status : married("JR")> =>*
    < X:Oid : V#0:Person |(age : N:Nat,status : separated(X':Oid)),
    V#1:AttributeSet > < X':Oid : V#2:Person |(age : N':Nat,status : married(
    X:Oid)),V#3:AttributeSet > .

Solution 1
N':Nat --> 50 ; N:Nat --> 46 ; V#0:Person --> Person ; V#1:AttributeSet --> (
    none).AttributeSet ; V#2:Person --> Person ; V#3:AttributeSet --> (
    none).AttributeSet ; X':Oid --> "JR" ; X:Oid --> "Sue Ellen"


Introduced module X

fmod X is
  including BOOL .
  sorts A B .
  subsort A < B .
  op 0 : -> A .
  op s : B -> B .
  mb s(0): A .
endfm

Warning: Parse error in fmod X is sort A B . subsort A < B . op 0 : -> A . op s
    : B -> B . cmb s(0): A . endfm <---*HERE*
Error: No parse for input.

fmod X is
  including BOOL .
  sorts A B .
  subsort A < B .
  op 0 : -> A .
  op s : B -> B .
  mb s(0): A .
endfm

Advisory: Module X redefined.
Introduced module X

fmod X is
  including BOOL .
  sorts A B .
  subsort A < B .
  op 0 : -> A .
  op s : B -> B .
  mb s(0): A .
endfm

A
BAD-SEPARATION
BOOL
BOOL-OPS
CONFIGURATION
CONFIGURATION+
DINING-PHILOSOPHERS
META-MODULE
NAT
POPULATION
STRING
SYNCHR-DIVORCE
TRUTH
TRUTH-VALUE
X

Advisory: Module X redefined.
Introduced module X

fmod X is
  including BOOL .
  sorts A B .
  subsort A < B .
  op 0 : -> A .
  op s : B -> B .
  cmb s(0): A
    if 0 = 0 .
endfm

Introduced module TEST-PLUS-LEQ

mod TEST-PLUS-LEQ is
  including BOOL .
  sorts Nat .
  op 0 : -> Nat .
  op _<=_ : Nat Nat -> Bool .
  op s : Nat -> Nat .
  op _+_ : Nat Nat -> Nat
    [comm] .
  rl 0 + Y:Nat
    => Y:Nat .
  rl s(X:Nat)+ Y:Nat
    => s(X:Nat + Y:Nat) .
  rl 0 <= Y:Nat
    => true .
  rl s(X:Nat)<= 0
    => false .
  rl s(X:Nat)<= s(Y:Nat)
    => X:Nat <= Y:Nat .
endm

search [10] in TEST-PLUS-LEQ :(X:Nat + Y:Nat)<= Y:Nat ~>* true .

Solution 1
X:Nat --> 0 ; Y:Nat --> 0

Solution 2
X:Nat --> 0 ; Y:Nat --> s(0)

Solution 3
X:Nat --> 0 ; Y:Nat --> s(s(0))

No more solutions.

search [10] in TEST-PLUS-LEQ :(X:Nat + Y:Nat)<= Y:Nat ~>* X:Bool .

Solution 1
X:Bool --> false ; X:Nat --> s(#1:Nat); Y:Nat --> 0

Solution 2
X:Bool --> false ; X:Nat --> s(#4:Nat); Y:Nat --> 0

Solution 3
X:Bool --> true ; X:Nat --> 0 ; Y:Nat --> 0

Solution 4
X:Bool --> #4:Nat <= #4:Nat ; X:Nat --> 0 ; Y:Nat --> s(#4:Nat)

Solution 5
X:Bool --> X:Nat <= 0 ; Y:Nat --> 0

Solution 6
X:Bool --> Y:Nat <= Y:Nat ; X:Nat --> 0

Solution 7
X:Bool --> (X:Nat + #1:Nat)<= #1:Nat ; Y:Nat --> s(#1:Nat)

Solution 8
X:Bool --> (X:Nat + Y:Nat)<= Y:Nat

Solution 9
X:Bool --> s(X:Nat + #1:Nat)<= s(#1:Nat); Y:Nat --> s(#1:Nat)

Solution 10
X:Bool --> s(Y:Nat + #1:Nat)<= Y:Nat ; X:Nat --> s(#1:Nat)

No more solutions.

search [10] in TEST-PLUS-LEQ :(X:Nat + Y:Nat)<= Y:Nat ~>! X:Bool .

Solution 1
X:Bool --> false ; X:Nat --> s(#11:Nat); Y:Nat --> s(0)

Solution 2
X:Bool --> false ; X:Nat --> s(#13:Nat); Y:Nat --> s(0)

Solution 3
X:Bool --> false ; X:Nat --> s(#14:Nat); Y:Nat --> s(0)

Solution 4
X:Bool --> false ; X:Nat --> s(#1:Nat); Y:Nat --> 0

Solution 5
X:Bool --> false ; X:Nat --> s(#4:Nat); Y:Nat --> 0

Solution 6
X:Bool --> false ; X:Nat --> s(0); Y:Nat --> 0

Solution 7
X:Bool --> false ; X:Nat --> s(s(#6:Nat)); Y:Nat --> 0

Solution 8
X:Bool --> true ; X:Nat --> 0 ; Y:Nat --> 0

Solution 9
X:Bool --> true ; X:Nat --> 0 ; Y:Nat --> s(0)

No more solutions.

search [,5] in TEST-PLUS-LEQ :(X:Nat + Y:Nat)<= Y:Nat ~>* true .

Solution 1
X:Nat --> 0 ; Y:Nat --> 0

Solution 2
X:Nat --> 0 ; Y:Nat --> s(0)

Solution 3
X:Nat --> 0 ; Y:Nat --> s(s(0))

Solution 4
X:Nat --> 0 ; Y:Nat --> s(s(s(0)))

No more solutions.

search [,5] in TEST-PLUS-LEQ :(X:Nat + Y:Nat)<= Y:Nat ~>* X:Bool .

Solution 1
X:Bool --> false ; X:Nat --> s(#11:Nat); Y:Nat --> s(0)

Solution 2
X:Bool --> false ; X:Nat --> s(#13:Nat); Y:Nat --> s(0)

Solution 3
X:Bool --> false ; X:Nat --> s(#14:Nat); Y:Nat --> s(0)

Solution 4
X:Bool --> false ; X:Nat --> s(#1:Nat); Y:Nat --> 0

Solution 5
X:Bool --> false ; X:Nat --> s(#1:Nat); Y:Nat --> s(0)

Solution 6
X:Bool --> false ; X:Nat --> s(#4:Nat); Y:Nat --> 0

Solution 7
X:Bool --> false ; X:Nat --> s(#6:Nat); Y:Nat --> s(0)

Solution 8
X:Bool --> false ; X:Nat --> s(0); Y:Nat --> 0

Solution 9
X:Bool --> false ; X:Nat --> s(0); Y:Nat --> s(0)

Solution 10
X:Bool --> false ; X:Nat --> s(0); Y:Nat --> s(s(0))

Solution 11
X:Bool --> false ; X:Nat --> s(s(#11:Nat)); Y:Nat --> s(0)

Solution 12
X:Bool --> false ; X:Nat --> s(s(#16:Nat)); Y:Nat --> s(0)

Solution 13
X:Bool --> false ; X:Nat --> s(s(#6:Nat)); Y:Nat --> 0

Solution 14
X:Bool --> false ; X:Nat --> s(s(#6:Nat)); Y:Nat --> s(0)

Solution 15
X:Bool --> false ; X:Nat --> s(s(0)); Y:Nat --> 0

Solution 16
X:Bool --> false ; X:Nat --> s(s(0)); Y:Nat --> s(0)

Solution 17
X:Bool --> false ; X:Nat --> s(s(s(#11:Nat))); Y:Nat --> 0

Solution 18
X:Bool --> false ; X:Nat --> s(s(s(#11:Nat))); Y:Nat --> s(0)

Solution 19
X:Bool --> false ; X:Nat --> s(s(s(#16:Nat))); Y:Nat --> s(0)

Solution 20
X:Bool --> false ; X:Nat --> s(s(s(0))); Y:Nat --> 0

Solution 21
X:Bool --> false ; X:Nat --> s(s(s(s(#16:Nat)))); Y:Nat --> 0

Solution 22
X:Bool --> true ; X:Nat --> 0 ; Y:Nat --> 0

Solution 23
X:Bool --> true ; X:Nat --> 0 ; Y:Nat --> s(0)

Solution 24
X:Bool --> true ; X:Nat --> 0 ; Y:Nat --> s(s(0))

Solution 25
X:Bool --> true ; X:Nat --> 0 ; Y:Nat --> s(s(s(0)))

Solution 26
X:Bool --> #11:Nat <= #11:Nat ; X:Nat --> 0 ; Y:Nat --> s(s(#11:Nat))

Solution 27
X:Bool --> #12:Nat <= #12:Nat ; X:Nat --> 0 ; Y:Nat --> s(s(s(#12:Nat)))

Solution 28
X:Bool --> #13:Nat <= #13:Nat ; X:Nat --> 0 ; Y:Nat --> s(s(#13:Nat))

Solution 29
X:Bool --> #14:Nat <= #14:Nat ; X:Nat --> 0 ; Y:Nat --> s(s(#14:Nat))

Solution 30
X:Bool --> #16:Nat <= #16:Nat ; X:Nat --> 0 ; Y:Nat --> s(s(s(s(#16:Nat))))

Solution 31
X:Bool --> #17:Nat <= #17:Nat ; X:Nat --> 0 ; Y:Nat --> s(s(s(#17:Nat)))

Solution 32
X:Bool --> #18:Nat <= #18:Nat ; X:Nat --> 0 ; Y:Nat --> s(s(s(#18:Nat)))

Solution 33
X:Bool --> #1:Nat <= #1:Nat ; X:Nat --> 0 ; Y:Nat --> s(#1:Nat)

Solution 34
X:Bool --> #4:Nat <= #4:Nat ; X:Nat --> 0 ; Y:Nat --> s(#4:Nat)

Solution 35
X:Bool --> #6:Nat <= #6:Nat ; X:Nat --> 0 ; Y:Nat --> s(s(#6:Nat))

Solution 36
X:Bool --> #8:Nat <= #8:Nat ; X:Nat --> 0 ; Y:Nat --> s(s(#8:Nat))

Solution 37
X:Bool --> X:Nat <= 0 ; Y:Nat --> 0

Solution 38
X:Bool --> X:Nat <= 0 ; Y:Nat --> s(0)

Solution 39
X:Bool --> X:Nat <= 0 ; Y:Nat --> s(s(0))

Solution 40
X:Bool --> Y:Nat <= Y:Nat ; X:Nat --> 0

Solution 41
X:Bool --> (#11:Nat + s(#17:Nat))<= #17:Nat ; X:Nat --> s(#11:Nat); Y:Nat -->
    s(s(#17:Nat))

Solution 42
X:Bool --> (#11:Nat + s(s(#17:Nat)))<= #17:Nat ; X:Nat --> s(s(#11:Nat)); Y:Nat
    --> s(s(#17:Nat))

Solution 43
X:Bool --> (#1:Nat + s(#17:Nat))<= #17:Nat ; X:Nat --> s(#1:Nat); Y:Nat --> s(
    s(#17:Nat))

Solution 44
X:Bool --> (#1:Nat + s(#7:Nat))<= #7:Nat ; X:Nat --> s(#1:Nat); Y:Nat --> s(
    #7:Nat)

Solution 45
X:Bool --> (#6:Nat + s(#17:Nat))<= #17:Nat ; X:Nat --> s(#6:Nat); Y:Nat --> s(
    s(#17:Nat))

Solution 46
X:Bool --> (#6:Nat + s(s(#17:Nat)))<= #17:Nat ; X:Nat --> s(s(#6:Nat)); Y:Nat
    --> s(s(#17:Nat))

Solution 47
X:Bool --> (X:Nat + #11:Nat)<= #11:Nat ; Y:Nat --> s(s(#11:Nat))

Solution 48
X:Bool --> (X:Nat + #1:Nat)<= #1:Nat ; Y:Nat --> s(#1:Nat)

Solution 49
X:Bool --> (X:Nat + #6:Nat)<= #6:Nat ; Y:Nat --> s(s(#6:Nat))

Solution 50
X:Bool --> (X:Nat + Y:Nat)<= Y:Nat

Solution 51
X:Bool --> s(#10:Nat)<= #10:Nat ; X:Nat --> s(0); Y:Nat --> s(#10:Nat)

Solution 52
X:Bool --> s(#11:Nat)<= 0 ; X:Nat --> s(#11:Nat); Y:Nat --> s(0)

Solution 53
X:Bool --> s(#11:Nat)<= s(#11:Nat); X:Nat --> 0 ; Y:Nat --> s(s(#11:Nat))

Solution 54
X:Bool --> s(#14:Nat)<= #14:Nat ; X:Nat --> s(0); Y:Nat --> s(s(#14:Nat))

Solution 55
X:Bool --> s(#15:Nat)<= #15:Nat ; X:Nat --> s(0); Y:Nat --> s(s(#15:Nat))

Solution 56
X:Bool --> s(#17:Nat)<= #17:Nat ; X:Nat --> s(0); Y:Nat --> s(s(#17:Nat))

Solution 57
X:Bool --> s(#18:Nat)<= #18:Nat ; X:Nat --> s(0); Y:Nat --> s(s(s(#18:Nat)))

Solution 58
X:Bool --> s(#19:Nat)<= #19:Nat ; X:Nat --> s(0); Y:Nat --> s(s(#19:Nat))

Solution 59
X:Bool --> s(#19:Nat)<= #19:Nat ; X:Nat --> s(0); Y:Nat --> s(s(s(#19:Nat)))

Solution 60
X:Bool --> s(#1:Nat)<= #1:Nat ; X:Nat --> s(0); Y:Nat --> s(#1:Nat)

Solution 61
X:Bool --> s(#1:Nat)<= 0 ; X:Nat --> s(#1:Nat); Y:Nat --> 0

Solution 62
X:Bool --> s(#1:Nat)<= 0 ; X:Nat --> s(#1:Nat); Y:Nat --> s(0)

Solution 63
X:Bool --> s(#1:Nat)<= s(#1:Nat); X:Nat --> 0 ; Y:Nat --> s(#1:Nat)

Solution 64
X:Bool --> s(#20:Nat)<= #20:Nat ; X:Nat --> s(0); Y:Nat --> s(s(#20:Nat))

Solution 65
X:Bool --> s(#6:Nat)<= #6:Nat ; X:Nat --> s(0); Y:Nat --> s(#6:Nat)

Solution 66
X:Bool --> s(#6:Nat)<= 0 ; X:Nat --> s(#6:Nat); Y:Nat --> s(0)

Solution 67
X:Bool --> s(#6:Nat)<= s(#6:Nat); X:Nat --> 0 ; Y:Nat --> s(s(#6:Nat))

Solution 68
X:Bool --> s(#7:Nat)<= #7:Nat ; X:Nat --> s(0); Y:Nat --> s(#7:Nat)

Solution 69
X:Bool --> s(X:Nat)<= s(0); Y:Nat --> s(0)

Solution 70
X:Bool --> s(X:Nat)<= s(0); Y:Nat --> s(s(0))

Solution 71
X:Bool --> s(Y:Nat)<= Y:Nat ; X:Nat --> s(0)

Solution 72
X:Bool --> s(#11:Nat + #16:Nat)<= #11:Nat ; X:Nat --> s(#16:Nat); Y:Nat --> s(
    s(#11:Nat))

Solution 73
X:Bool --> s(#11:Nat + #16:Nat)<= #16:Nat ; X:Nat --> s(#11:Nat); Y:Nat --> s(
    s(#16:Nat))

Solution 74
X:Bool --> s(#11:Nat + #17:Nat)<= #17:Nat ; X:Nat --> s(#11:Nat); Y:Nat --> s(
    s(#17:Nat))

Solution 75
X:Bool --> s(#11:Nat + #21:Nat)<= #11:Nat ; X:Nat --> s(#21:Nat); Y:Nat --> s(
    s(#11:Nat))

Solution 76
X:Bool --> s(#11:Nat + s(#17:Nat))<= #17:Nat ; X:Nat --> s(s(#11:Nat)); Y:Nat
    --> s(s(#17:Nat))

Solution 77
X:Bool --> s(#11:Nat + s(#22:Nat))<= #22:Nat ; X:Nat --> s(s(#11:Nat)); Y:Nat
    --> s(s(#22:Nat))

Solution 78
X:Bool --> s(#11:Nat + s(#7:Nat))<= #7:Nat ; X:Nat --> s(s(#11:Nat)); Y:Nat -->
    s(#7:Nat)

Solution 79
X:Bool --> s(#11:Nat + s(s(#22:Nat)))<= #22:Nat ; X:Nat --> s(s(s(#11:Nat)));
    Y:Nat --> s(s(#22:Nat))

Solution 80
X:Bool --> s(#16:Nat + s(#22:Nat))<= #22:Nat ; X:Nat --> s(s(#16:Nat)); Y:Nat
    --> s(s(#22:Nat))

Solution 81
X:Bool --> s(#16:Nat + s(s(#22:Nat)))<= #22:Nat ; X:Nat --> s(s(s(#16:Nat)));
    Y:Nat --> s(s(#22:Nat))

Solution 82
X:Bool --> s(#1:Nat + #11:Nat)<= #11:Nat ; X:Nat --> s(#1:Nat); Y:Nat --> s(s(
    #11:Nat))

Solution 83
X:Bool --> s(#1:Nat + #11:Nat)<= #1:Nat ; X:Nat --> s(#11:Nat); Y:Nat --> s(
    #1:Nat)

Solution 84
X:Bool --> s(#1:Nat + #16:Nat)<= #16:Nat ; X:Nat --> s(#1:Nat); Y:Nat --> s(s(
    #16:Nat))

Solution 85
X:Bool --> s(#1:Nat + #17:Nat)<= #17:Nat ; X:Nat --> s(#1:Nat); Y:Nat --> s(s(
    #17:Nat))

Solution 86
X:Bool --> s(#1:Nat + #6:Nat)<= #1:Nat ; X:Nat --> s(#6:Nat); Y:Nat --> s(
    #1:Nat)

Solution 87
X:Bool --> s(#1:Nat + #6:Nat)<= #6:Nat ; X:Nat --> s(#1:Nat); Y:Nat --> s(
    #6:Nat)

Solution 88
X:Bool --> s(#1:Nat + #7:Nat)<= #7:Nat ; X:Nat --> s(#1:Nat); Y:Nat --> s(
    #7:Nat)

Solution 89
X:Bool --> s(#21:Nat + s(#17:Nat))<= #17:Nat ; X:Nat --> s(s(#21:Nat)); Y:Nat
    --> s(s(#17:Nat))

Solution 90
X:Bool --> s(#21:Nat + s(s(#17:Nat)))<= #17:Nat ; X:Nat --> s(s(s(#21:Nat)));
    Y:Nat --> s(s(#17:Nat))

Solution 91
X:Bool --> s(#6:Nat + #11:Nat)<= #11:Nat ; X:Nat --> s(#6:Nat); Y:Nat --> s(s(
    #11:Nat))

Solution 92
X:Bool --> s(#6:Nat + #11:Nat)<= #6:Nat ; X:Nat --> s(#11:Nat); Y:Nat --> s(s(
    #6:Nat))

Solution 93
X:Bool --> s(#6:Nat + #16:Nat)<= #16:Nat ; X:Nat --> s(#6:Nat); Y:Nat --> s(s(
    #16:Nat))

Solution 94
X:Bool --> s(#6:Nat + #16:Nat)<= #6:Nat ; X:Nat --> s(#16:Nat); Y:Nat --> s(s(
    #6:Nat))

Solution 95
X:Bool --> s(#6:Nat + #17:Nat)<= #17:Nat ; X:Nat --> s(#6:Nat); Y:Nat --> s(s(
    #17:Nat))

Solution 96
X:Bool --> s(#6:Nat + #21:Nat)<= #6:Nat ; X:Nat --> s(#21:Nat); Y:Nat --> s(s(
    #6:Nat))

Solution 97
X:Bool --> s(#6:Nat + s(#12:Nat))<= #12:Nat ; X:Nat --> s(s(#6:Nat)); Y:Nat -->
    s(#12:Nat)

Solution 98
X:Bool --> s(#6:Nat + s(#17:Nat))<= #17:Nat ; X:Nat --> s(s(#6:Nat)); Y:Nat -->
    s(s(#17:Nat))

Solution 99
X:Bool --> s(#6:Nat + s(#22:Nat))<= #22:Nat ; X:Nat --> s(s(#6:Nat)); Y:Nat -->
    s(s(#22:Nat))

Solution 100
X:Bool --> s(X:Nat + #11:Nat)<= s(#11:Nat); Y:Nat --> s(s(#11:Nat))

Solution 101
X:Bool --> s(X:Nat + #11:Nat)<= s(#11:Nat); Y:Nat --> s(s(s(#11:Nat)))

Solution 102
X:Bool --> s(X:Nat + #16:Nat)<= s(#16:Nat); Y:Nat --> s(s(s(#16:Nat)))

Solution 103
X:Bool --> s(X:Nat + #1:Nat)<= s(#1:Nat); Y:Nat --> s(#1:Nat)

Solution 104
X:Bool --> s(X:Nat + #21:Nat)<= s(#21:Nat); Y:Nat --> s(s(s(#21:Nat)))

Solution 105
X:Bool --> s(X:Nat + #6:Nat)<= s(#6:Nat); Y:Nat --> s(s(#6:Nat))

Solution 106
X:Bool --> s(Y:Nat + #1:Nat)<= Y:Nat ; X:Nat --> s(#1:Nat)

Solution 107
X:Bool --> s(s(#11:Nat))<= #11:Nat ; X:Nat --> s(s(0)); Y:Nat --> s(#11:Nat)

Solution 108
X:Bool --> s(s(#11:Nat))<= 0 ; X:Nat --> s(s(#11:Nat)); Y:Nat --> s(0)

Solution 109
X:Bool --> s(s(#11:Nat))<= s(#11:Nat); X:Nat --> s(0); Y:Nat --> s(s(#11:Nat))

Solution 110
X:Bool --> s(s(#11:Nat))<= s(0); X:Nat --> s(#11:Nat); Y:Nat --> s(s(0))

Solution 111
X:Bool --> s(s(#11:Nat))<= s(s(#11:Nat)); X:Nat --> 0 ; Y:Nat --> s(s(s(
    #11:Nat)))

Solution 112
X:Bool --> s(s(#12:Nat))<= #12:Nat ; X:Nat --> s(s(0)); Y:Nat --> s(#12:Nat)

Solution 113
X:Bool --> s(s(#15:Nat))<= #15:Nat ; X:Nat --> s(s(0)); Y:Nat --> s(#15:Nat)

Solution 114
X:Bool --> s(s(#16:Nat))<= 0 ; X:Nat --> s(s(#16:Nat)); Y:Nat --> s(0)

Solution 115
X:Bool --> s(s(#16:Nat))<= s(#16:Nat); X:Nat --> s(0); Y:Nat --> s(s(#16:Nat))

Solution 116
X:Bool --> s(s(#16:Nat))<= s(0); X:Nat --> s(#16:Nat); Y:Nat --> s(s(0))

Solution 117
X:Bool --> s(s(#16:Nat))<= s(s(#16:Nat)); X:Nat --> 0 ; Y:Nat --> s(s(s(
    #16:Nat)))

Solution 118
X:Bool --> s(s(#17:Nat))<= #17:Nat ; X:Nat --> s(s(0)); Y:Nat --> s(s(#17:Nat))

Solution 119
X:Bool --> s(s(#19:Nat))<= #19:Nat ; X:Nat --> s(s(0)); Y:Nat --> s(s(#19:Nat))

Solution 120
X:Bool --> s(s(#1:Nat))<= #1:Nat ; X:Nat --> s(s(0)); Y:Nat --> s(#1:Nat)

Solution 121
X:Bool --> s(s(#1:Nat))<= s(#1:Nat); X:Nat --> s(0); Y:Nat --> s(#1:Nat)

Solution 122
X:Bool --> s(s(#1:Nat))<= s(0); X:Nat --> s(#1:Nat); Y:Nat --> s(0)

Solution 123
X:Bool --> s(s(#1:Nat))<= s(0); X:Nat --> s(#1:Nat); Y:Nat --> s(s(0))

Solution 124
X:Bool --> s(s(#20:Nat))<= #20:Nat ; X:Nat --> s(s(0)); Y:Nat --> s(s(#20:Nat))

Solution 125
X:Bool --> s(s(#6:Nat))<= #6:Nat ; X:Nat --> s(s(0)); Y:Nat --> s(#6:Nat)

Solution 126
X:Bool --> s(s(#6:Nat))<= 0 ; X:Nat --> s(s(#6:Nat)); Y:Nat --> 0

Solution 127
X:Bool --> s(s(#6:Nat))<= 0 ; X:Nat --> s(s(#6:Nat)); Y:Nat --> s(0)

Solution 128
X:Bool --> s(s(#6:Nat))<= s(#6:Nat); X:Nat --> s(0); Y:Nat --> s(#6:Nat)

Solution 129
X:Bool --> s(s(#6:Nat))<= s(#6:Nat); X:Nat --> s(0); Y:Nat --> s(s(#6:Nat))

Solution 130
X:Bool --> s(s(#6:Nat))<= s(0); X:Nat --> s(#6:Nat); Y:Nat --> s(0)

Solution 131
X:Bool --> s(s(#6:Nat))<= s(0); X:Nat --> s(#6:Nat); Y:Nat --> s(s(0))

Solution 132
X:Bool --> s(s(#6:Nat))<= s(s(#6:Nat)); X:Nat --> 0 ; Y:Nat --> s(s(#6:Nat))

Solution 133
X:Bool --> s(s(#7:Nat))<= #7:Nat ; X:Nat --> s(s(0)); Y:Nat --> s(#7:Nat)

Solution 134
X:Bool --> s(s(X:Nat))<= s(s(0)); Y:Nat --> s(s(0))

Solution 135
X:Bool --> s(s(X:Nat))<= s(s(0)); Y:Nat --> s(s(s(0)))

Solution 136
X:Bool --> s(s(Y:Nat))<= Y:Nat ; X:Nat --> s(s(0))

Solution 137
X:Bool --> s(s(#11:Nat + #16:Nat))<= s(#11:Nat); X:Nat --> s(#16:Nat); Y:Nat
    --> s(s(#11:Nat))

Solution 138
X:Bool --> s(s(#11:Nat + #16:Nat))<= s(#16:Nat); X:Nat --> s(#11:Nat); Y:Nat
    --> s(s(#16:Nat))

Solution 139
X:Bool --> s(s(#11:Nat + s(#17:Nat)))<= #17:Nat ; X:Nat --> s(s(s(#11:Nat)));
    Y:Nat --> s(#17:Nat)

Solution 140
X:Bool --> s(s(#16:Nat + s(#12:Nat)))<= #12:Nat ; X:Nat --> s(s(s(#16:Nat)));
    Y:Nat --> s(#12:Nat)

Solution 141
X:Bool --> s(s(#16:Nat + s(#7:Nat)))<= #7:Nat ; X:Nat --> s(s(s(#16:Nat)));
    Y:Nat --> s(#7:Nat)

Solution 142
X:Bool --> s(s(#1:Nat + #11:Nat))<= #1:Nat ; X:Nat --> s(s(#11:Nat)); Y:Nat -->
    s(#1:Nat)

Solution 143
X:Bool --> s(s(#1:Nat + #11:Nat))<= s(#11:Nat); X:Nat --> s(#1:Nat); Y:Nat -->
    s(s(#11:Nat))

Solution 144
X:Bool --> s(s(#1:Nat + #16:Nat))<= #1:Nat ; X:Nat --> s(s(#16:Nat)); Y:Nat -->
    s(#1:Nat)

Solution 145
X:Bool --> s(s(#1:Nat + #16:Nat))<= s(#16:Nat); X:Nat --> s(#1:Nat); Y:Nat -->
    s(s(#16:Nat))

Solution 146
X:Bool --> s(s(#1:Nat + #6:Nat))<= s(#1:Nat); X:Nat --> s(#6:Nat); Y:Nat --> s(
    #1:Nat)

Solution 147
X:Bool --> s(s(#1:Nat + #6:Nat))<= s(#6:Nat); X:Nat --> s(#1:Nat); Y:Nat --> s(
    #6:Nat)

Solution 148
X:Bool --> s(s(#6:Nat + #11:Nat))<= #11:Nat ; X:Nat --> s(s(#6:Nat)); Y:Nat -->
    s(#11:Nat)

Solution 149
X:Bool --> s(s(#6:Nat + #11:Nat))<= #6:Nat ; X:Nat --> s(s(#11:Nat)); Y:Nat -->
    s(#6:Nat)

Solution 150
X:Bool --> s(s(#6:Nat + #11:Nat))<= s(#11:Nat); X:Nat --> s(#6:Nat); Y:Nat -->
    s(s(#11:Nat))

Solution 151
X:Bool --> s(s(#6:Nat + #11:Nat))<= s(#6:Nat); X:Nat --> s(#11:Nat); Y:Nat -->
    s(s(#6:Nat))

Solution 152
X:Bool --> s(s(#6:Nat + #12:Nat))<= #12:Nat ; X:Nat --> s(s(#6:Nat)); Y:Nat -->
    s(#12:Nat)

Solution 153
X:Bool --> s(s(#6:Nat + #16:Nat))<= #6:Nat ; X:Nat --> s(s(#16:Nat)); Y:Nat -->
    s(#6:Nat)

Solution 154
X:Bool --> s(s(#6:Nat + #16:Nat))<= s(#16:Nat); X:Nat --> s(#6:Nat); Y:Nat -->
    s(s(#16:Nat))

Solution 155
X:Bool --> s(s(#6:Nat + #16:Nat))<= s(#6:Nat); X:Nat --> s(#16:Nat); Y:Nat -->
    s(s(#6:Nat))

Solution 156
X:Bool --> s(s(#7:Nat + #11:Nat))<= #7:Nat ; X:Nat --> s(s(#11:Nat)); Y:Nat -->
    s(#7:Nat)

Solution 157
X:Bool --> s(s(#7:Nat + #16:Nat))<= #7:Nat ; X:Nat --> s(s(#16:Nat)); Y:Nat -->
    s(#7:Nat)

Solution 158
X:Bool --> s(s(X:Nat + #11:Nat))<= s(s(#11:Nat)); Y:Nat --> s(s(s(#11:Nat)))

Solution 159
X:Bool --> s(s(X:Nat + #16:Nat))<= s(s(#16:Nat)); Y:Nat --> s(s(s(#16:Nat)))

Solution 160
X:Bool --> s(s(X:Nat + #6:Nat))<= s(s(#6:Nat)); Y:Nat --> s(s(#6:Nat))

Solution 161
X:Bool --> s(s(Y:Nat + #6:Nat))<= Y:Nat ; X:Nat --> s(s(#6:Nat))

Solution 162
X:Bool --> s(s(s(#11:Nat)))<= 0 ; X:Nat --> s(s(s(#11:Nat))); Y:Nat --> 0

Solution 163
X:Bool --> s(s(s(#11:Nat)))<= s(#11:Nat); X:Nat --> s(s(0)); Y:Nat --> s(
    #11:Nat)

Solution 164
X:Bool --> s(s(s(#11:Nat)))<= s(0); X:Nat --> s(s(#11:Nat)); Y:Nat --> s(0)

Solution 165
X:Bool --> s(s(s(#11:Nat)))<= s(s(#11:Nat)); X:Nat --> s(0); Y:Nat --> s(s(
    #11:Nat))

Solution 166
X:Bool --> s(s(s(#11:Nat)))<= s(s(0)); X:Nat --> s(#11:Nat); Y:Nat --> s(s(0))

Solution 167
X:Bool --> s(s(s(#11:Nat)))<= s(s(s(#11:Nat))); X:Nat --> 0 ; Y:Nat --> s(s(s(
    #11:Nat)))

Solution 168
X:Bool --> s(s(s(#12:Nat)))<= #12:Nat ; X:Nat --> s(s(s(0))); Y:Nat --> s(
    #12:Nat)

Solution 169
X:Bool --> s(s(s(#17:Nat)))<= #17:Nat ; X:Nat --> s(s(s(0))); Y:Nat --> s(
    #17:Nat)

Solution 170
X:Bool --> s(s(s(#1:Nat)))<= s(#1:Nat); X:Nat --> s(s(0)); Y:Nat --> s(#1:Nat)

Solution 171
X:Bool --> s(s(s(#1:Nat)))<= s(s(0)); X:Nat --> s(#1:Nat); Y:Nat --> s(s(0))

Solution 172
X:Bool --> s(s(s(#20:Nat)))<= #20:Nat ; X:Nat --> s(s(s(0))); Y:Nat --> s(
    #20:Nat)

Solution 173
X:Bool --> s(s(s(#6:Nat)))<= s(#6:Nat); X:Nat --> s(s(0)); Y:Nat --> s(#6:Nat)

Solution 174
X:Bool --> s(s(s(#6:Nat)))<= s(0); X:Nat --> s(s(#6:Nat)); Y:Nat --> s(0)

Solution 175
X:Bool --> s(s(s(#6:Nat)))<= s(s(#6:Nat)); X:Nat --> s(0); Y:Nat --> s(s(
    #6:Nat))

Solution 176
X:Bool --> s(s(s(#6:Nat)))<= s(s(0)); X:Nat --> s(#6:Nat); Y:Nat --> s(s(0))

Solution 177
X:Bool --> s(s(s(#7:Nat)))<= #7:Nat ; X:Nat --> s(s(s(0))); Y:Nat --> s(#7:Nat)

Solution 178
X:Bool --> s(s(s(X:Nat)))<= s(s(s(0))); Y:Nat --> s(s(s(0)))

Solution 179
X:Bool --> s(s(s(Y:Nat)))<= Y:Nat ; X:Nat --> s(s(s(0)))

Solution 180
X:Bool --> s(s(s(#11:Nat + #16:Nat)))<= #11:Nat ; X:Nat --> s(s(s(#16:Nat)));
    Y:Nat --> s(#11:Nat)

Solution 181
X:Bool --> s(s(s(#11:Nat + #16:Nat)))<= #16:Nat ; X:Nat --> s(s(s(#11:Nat)));
    Y:Nat --> s(#16:Nat)

Solution 182
X:Bool --> s(s(s(#11:Nat + #16:Nat)))<= s(#11:Nat); X:Nat --> s(s(#16:Nat));
    Y:Nat --> s(s(#11:Nat))

Solution 183
X:Bool --> s(s(s(#11:Nat + #16:Nat)))<= s(#16:Nat); X:Nat --> s(s(#11:Nat));
    Y:Nat --> s(s(#16:Nat))

Solution 184
X:Bool --> s(s(s(#11:Nat + #16:Nat)))<= s(s(#11:Nat)); X:Nat --> s(#16:Nat);
    Y:Nat --> s(s(s(#11:Nat)))

Solution 185
X:Bool --> s(s(s(#11:Nat + #16:Nat)))<= s(s(#16:Nat)); X:Nat --> s(#11:Nat);
    Y:Nat --> s(s(s(#16:Nat)))

Solution 186
X:Bool --> s(s(s(#11:Nat + #17:Nat)))<= #17:Nat ; X:Nat --> s(s(s(#11:Nat)));
    Y:Nat --> s(#17:Nat)

Solution 187
X:Bool --> s(s(s(#11:Nat + #21:Nat)))<= #11:Nat ; X:Nat --> s(s(s(#21:Nat)));
    Y:Nat --> s(#11:Nat)

Solution 188
X:Bool --> s(s(s(#11:Nat + #21:Nat)))<= s(#11:Nat); X:Nat --> s(s(#21:Nat));
    Y:Nat --> s(s(#11:Nat))

Solution 189
X:Bool --> s(s(s(#11:Nat + #21:Nat)))<= s(#21:Nat); X:Nat --> s(s(#11:Nat));
    Y:Nat --> s(s(#21:Nat))

Solution 190
X:Bool --> s(s(s(#11:Nat + #21:Nat)))<= s(s(#11:Nat)); X:Nat --> s(#21:Nat);
    Y:Nat --> s(s(s(#11:Nat)))

Solution 191
X:Bool --> s(s(s(#11:Nat + #21:Nat)))<= s(s(#21:Nat)); X:Nat --> s(#11:Nat);
    Y:Nat --> s(s(s(#21:Nat)))

Solution 192
X:Bool --> s(s(s(#12:Nat + #16:Nat)))<= #12:Nat ; X:Nat --> s(s(s(#16:Nat)));
    Y:Nat --> s(#12:Nat)

Solution 193
X:Bool --> s(s(s(#12:Nat + #21:Nat)))<= #12:Nat ; X:Nat --> s(s(s(#21:Nat)));
    Y:Nat --> s(#12:Nat)

Solution 194
X:Bool --> s(s(s(#16:Nat + #21:Nat)))<= s(#16:Nat); X:Nat --> s(s(#21:Nat));
    Y:Nat --> s(s(#16:Nat))

Solution 195
X:Bool --> s(s(s(#16:Nat + #21:Nat)))<= s(#21:Nat); X:Nat --> s(s(#16:Nat));
    Y:Nat --> s(s(#21:Nat))

Solution 196
X:Bool --> s(s(s(#16:Nat + #21:Nat)))<= s(s(#16:Nat)); X:Nat --> s(#21:Nat);
    Y:Nat --> s(s(s(#16:Nat)))

Solution 197
X:Bool --> s(s(s(#16:Nat + #21:Nat)))<= s(s(#21:Nat)); X:Nat --> s(#16:Nat);
    Y:Nat --> s(s(s(#21:Nat)))

Solution 198
X:Bool --> s(s(s(#16:Nat + s(#22:Nat))))<= #22:Nat ; X:Nat --> s(s(s(s(
    #16:Nat)))); Y:Nat --> s(#22:Nat)

Solution 199
X:Bool --> s(s(s(#1:Nat + #11:Nat)))<= s(#1:Nat); X:Nat --> s(s(#11:Nat));
    Y:Nat --> s(#1:Nat)

Solution 200
X:Bool --> s(s(s(#1:Nat + #11:Nat)))<= s(s(#11:Nat)); X:Nat --> s(#1:Nat);
    Y:Nat --> s(s(#11:Nat))

Solution 201
X:Bool --> s(s(s(#1:Nat + #16:Nat)))<= #1:Nat ; X:Nat --> s(s(s(#16:Nat)));
    Y:Nat --> s(#1:Nat)

Solution 202
X:Bool --> s(s(s(#1:Nat + #16:Nat)))<= s(s(#16:Nat)); X:Nat --> s(#1:Nat);
    Y:Nat --> s(s(s(#16:Nat)))

Solution 203
X:Bool --> s(s(s(#1:Nat + #21:Nat)))<= #1:Nat ; X:Nat --> s(s(s(#21:Nat)));
    Y:Nat --> s(#1:Nat)

Solution 204
X:Bool --> s(s(s(#1:Nat + #21:Nat)))<= s(s(#21:Nat)); X:Nat --> s(#1:Nat);
    Y:Nat --> s(s(s(#21:Nat)))

Solution 205
X:Bool --> s(s(s(#21:Nat + s(#12:Nat))))<= #12:Nat ; X:Nat --> s(s(s(s(
    #21:Nat)))); Y:Nat --> s(#12:Nat)

Solution 206
X:Bool --> s(s(s(#21:Nat + s(#17:Nat))))<= #17:Nat ; X:Nat --> s(s(s(s(
    #21:Nat)))); Y:Nat --> s(#17:Nat)

Solution 207
X:Bool --> s(s(s(#21:Nat + s(#7:Nat))))<= #7:Nat ; X:Nat --> s(s(s(s(
    #21:Nat)))); Y:Nat --> s(#7:Nat)

Solution 208
X:Bool --> s(s(s(#6:Nat + #11:Nat)))<= s(#11:Nat); X:Nat --> s(s(#6:Nat));
    Y:Nat --> s(#11:Nat)

Solution 209
X:Bool --> s(s(s(#6:Nat + #11:Nat)))<= s(#6:Nat); X:Nat --> s(s(#11:Nat));
    Y:Nat --> s(#6:Nat)

Solution 210
X:Bool --> s(s(s(#6:Nat + #11:Nat)))<= s(s(#11:Nat)); X:Nat --> s(#6:Nat);
    Y:Nat --> s(s(#11:Nat))

Solution 211
X:Bool --> s(s(s(#6:Nat + #11:Nat)))<= s(s(#6:Nat)); X:Nat --> s(#11:Nat);
    Y:Nat --> s(s(#6:Nat))

Solution 212
X:Bool --> s(s(s(#6:Nat + #16:Nat)))<= #6:Nat ; X:Nat --> s(s(s(#16:Nat)));
    Y:Nat --> s(#6:Nat)

Solution 213
X:Bool --> s(s(s(#6:Nat + #16:Nat)))<= s(#16:Nat); X:Nat --> s(s(#6:Nat));
    Y:Nat --> s(s(#16:Nat))

Solution 214
X:Bool --> s(s(s(#6:Nat + #16:Nat)))<= s(#6:Nat); X:Nat --> s(s(#16:Nat));
    Y:Nat --> s(s(#6:Nat))

Solution 215
X:Bool --> s(s(s(#6:Nat + #16:Nat)))<= s(s(#16:Nat)); X:Nat --> s(#6:Nat);
    Y:Nat --> s(s(s(#16:Nat)))

Solution 216
X:Bool --> s(s(s(#6:Nat + #21:Nat)))<= #6:Nat ; X:Nat --> s(s(s(#21:Nat)));
    Y:Nat --> s(#6:Nat)

Solution 217
X:Bool --> s(s(s(#6:Nat + #21:Nat)))<= s(#21:Nat); X:Nat --> s(s(#6:Nat));
    Y:Nat --> s(s(#21:Nat))

Solution 218
X:Bool --> s(s(s(#6:Nat + #21:Nat)))<= s(#6:Nat); X:Nat --> s(s(#21:Nat));
    Y:Nat --> s(s(#6:Nat))

Solution 219
X:Bool --> s(s(s(#6:Nat + #21:Nat)))<= s(s(#21:Nat)); X:Nat --> s(#6:Nat);
    Y:Nat --> s(s(s(#21:Nat)))

Solution 220
X:Bool --> s(s(s(#7:Nat + #16:Nat)))<= #7:Nat ; X:Nat --> s(s(s(#16:Nat)));
    Y:Nat --> s(#7:Nat)

Solution 221
X:Bool --> s(s(s(#7:Nat + #21:Nat)))<= #7:Nat ; X:Nat --> s(s(s(#21:Nat)));
    Y:Nat --> s(#7:Nat)

Solution 222
X:Bool --> s(s(s(X:Nat + #11:Nat)))<= s(s(s(#11:Nat))); Y:Nat --> s(s(s(
    #11:Nat)))

Solution 223
X:Bool --> s(s(s(X:Nat + #16:Nat)))<= s(s(s(#16:Nat))); Y:Nat --> s(s(s(s(
    #16:Nat))))

Solution 224
X:Bool --> s(s(s(X:Nat + #21:Nat)))<= s(s(s(#21:Nat))); Y:Nat --> s(s(s(s(
    #21:Nat))))

Solution 225
X:Bool --> s(s(s(Y:Nat + #11:Nat)))<= Y:Nat ; X:Nat --> s(s(s(#11:Nat)))

Solution 226
X:Bool --> s(s(s(s(#11:Nat))))<= s(#11:Nat); X:Nat --> s(s(s(0))); Y:Nat --> s(
    #11:Nat)

Solution 227
X:Bool --> s(s(s(s(#11:Nat))))<= s(0); X:Nat --> s(s(s(#11:Nat))); Y:Nat --> s(
    0)

Solution 228
X:Bool --> s(s(s(s(#11:Nat))))<= s(s(#11:Nat)); X:Nat --> s(s(0)); Y:Nat --> s(
    s(#11:Nat))

Solution 229
X:Bool --> s(s(s(s(#11:Nat))))<= s(s(0)); X:Nat --> s(s(#11:Nat)); Y:Nat --> s(
    s(0))

Solution 230
X:Bool --> s(s(s(s(#11:Nat))))<= s(s(s(#11:Nat))); X:Nat --> s(0); Y:Nat --> s(
    s(s(#11:Nat)))

Solution 231
X:Bool --> s(s(s(s(#11:Nat))))<= s(s(s(0))); X:Nat --> s(#11:Nat); Y:Nat --> s(
    s(s(0)))

Solution 232
X:Bool --> s(s(s(s(#16:Nat))))<= 0 ; X:Nat --> s(s(s(s(#16:Nat)))); Y:Nat --> 0

Solution 233
X:Bool --> s(s(s(s(#16:Nat))))<= s(#16:Nat); X:Nat --> s(s(s(0))); Y:Nat --> s(
    #16:Nat)

Solution 234
X:Bool --> s(s(s(s(#16:Nat))))<= s(0); X:Nat --> s(s(s(#16:Nat))); Y:Nat --> s(
    0)

Solution 235
X:Bool --> s(s(s(s(#16:Nat))))<= s(s(#16:Nat)); X:Nat --> s(s(0)); Y:Nat --> s(
    s(#16:Nat))

Solution 236
X:Bool --> s(s(s(s(#16:Nat))))<= s(s(0)); X:Nat --> s(s(#16:Nat)); Y:Nat --> s(
    s(0))

Solution 237
X:Bool --> s(s(s(s(#16:Nat))))<= s(s(s(#16:Nat))); X:Nat --> s(0); Y:Nat --> s(
    s(s(#16:Nat)))

Solution 238
X:Bool --> s(s(s(s(#16:Nat))))<= s(s(s(0))); X:Nat --> s(#16:Nat); Y:Nat --> s(
    s(s(0)))

Solution 239
X:Bool --> s(s(s(s(#16:Nat))))<= s(s(s(s(#16:Nat)))); X:Nat --> 0 ; Y:Nat -->
    s(s(s(s(#16:Nat))))

Solution 240
X:Bool --> s(s(s(s(#1:Nat))))<= s(#1:Nat); X:Nat --> s(s(s(0))); Y:Nat --> s(
    #1:Nat)

Solution 241
X:Bool --> s(s(s(s(#1:Nat))))<= s(s(s(0))); X:Nat --> s(#1:Nat); Y:Nat --> s(s(
    s(0)))

Solution 242
X:Bool --> s(s(s(s(#6:Nat))))<= s(#6:Nat); X:Nat --> s(s(s(0))); Y:Nat --> s(
    #6:Nat)

Solution 243
X:Bool --> s(s(s(s(#6:Nat))))<= s(s(#6:Nat)); X:Nat --> s(s(0)); Y:Nat --> s(s(
    #6:Nat))

Solution 244
X:Bool --> s(s(s(s(#6:Nat))))<= s(s(0)); X:Nat --> s(s(#6:Nat)); Y:Nat --> s(s(
    0))

Solution 245
X:Bool --> s(s(s(s(#6:Nat))))<= s(s(s(0))); X:Nat --> s(#6:Nat); Y:Nat --> s(s(
    s(0)))

Solution 246
X:Bool --> s(s(s(s(X:Nat))))<= s(s(s(s(0)))); Y:Nat --> s(s(s(s(0))))

Solution 247
X:Bool --> s(s(s(s(Y:Nat))))<= Y:Nat ; X:Nat --> s(s(s(s(0))))

Solution 248
X:Bool --> s(s(s(s(#11:Nat + #16:Nat))))<= s(#11:Nat); X:Nat --> s(s(s(
    #16:Nat))); Y:Nat --> s(#11:Nat)

Solution 249
X:Bool --> s(s(s(s(#11:Nat + #16:Nat))))<= s(#16:Nat); X:Nat --> s(s(s(
    #11:Nat))); Y:Nat --> s(#16:Nat)

Solution 250
X:Bool --> s(s(s(s(#11:Nat + #16:Nat))))<= s(s(#11:Nat)); X:Nat --> s(s(
    #16:Nat)); Y:Nat --> s(s(#11:Nat))

Solution 251
X:Bool --> s(s(s(s(#11:Nat + #16:Nat))))<= s(s(#16:Nat)); X:Nat --> s(s(
    #11:Nat)); Y:Nat --> s(s(#16:Nat))

Solution 252
X:Bool --> s(s(s(s(#11:Nat + #16:Nat))))<= s(s(s(#11:Nat))); X:Nat --> s(
    #16:Nat); Y:Nat --> s(s(s(#11:Nat)))

Solution 253
X:Bool --> s(s(s(s(#11:Nat + #16:Nat))))<= s(s(s(#16:Nat))); X:Nat --> s(
    #11:Nat); Y:Nat --> s(s(s(#16:Nat)))

Solution 254
X:Bool --> s(s(s(s(#1:Nat + #16:Nat))))<= s(#1:Nat); X:Nat --> s(s(s(
    #16:Nat))); Y:Nat --> s(#1:Nat)

Solution 255
X:Bool --> s(s(s(s(#1:Nat + #16:Nat))))<= s(s(s(#16:Nat))); X:Nat --> s(
    #1:Nat); Y:Nat --> s(s(s(#16:Nat)))

Solution 256
X:Bool --> s(s(s(s(#6:Nat + #16:Nat))))<= s(#6:Nat); X:Nat --> s(s(s(
    #16:Nat))); Y:Nat --> s(#6:Nat)

Solution 257
X:Bool --> s(s(s(s(#6:Nat + #16:Nat))))<= s(s(#16:Nat)); X:Nat --> s(s(
    #6:Nat)); Y:Nat --> s(s(#16:Nat))

Solution 258
X:Bool --> s(s(s(s(#6:Nat + #16:Nat))))<= s(s(#6:Nat)); X:Nat --> s(s(
    #16:Nat)); Y:Nat --> s(s(#6:Nat))

Solution 259
X:Bool --> s(s(s(s(#6:Nat + #16:Nat))))<= s(s(s(#16:Nat))); X:Nat --> s(
    #6:Nat); Y:Nat --> s(s(s(#16:Nat)))

Solution 260
X:Bool --> s(s(s(s(X:Nat + #16:Nat))))<= s(s(s(s(#16:Nat)))); Y:Nat --> s(s(s(
    s(#16:Nat))))

Solution 261
X:Bool --> s(s(s(s(Y:Nat + #16:Nat))))<= Y:Nat ; X:Nat --> s(s(s(s(#16:Nat))))

Solution 262
X:Bool --> s(s(s(s(s(#11:Nat + #21:Nat)))))<= s(#11:Nat); X:Nat --> s(s(s(s(
    #21:Nat)))); Y:Nat --> s(#11:Nat)

Solution 263
X:Bool --> s(s(s(s(s(#11:Nat + #21:Nat)))))<= s(s(#11:Nat)); X:Nat --> s(s(s(
    #21:Nat))); Y:Nat --> s(s(#11:Nat))

Solution 264
X:Bool --> s(s(s(s(s(#11:Nat + #21:Nat)))))<= s(s(#21:Nat)); X:Nat --> s(s(s(
    #11:Nat))); Y:Nat --> s(s(#21:Nat))

Solution 265
X:Bool --> s(s(s(s(s(#11:Nat + #21:Nat)))))<= s(s(s(#11:Nat))); X:Nat --> s(s(
    #21:Nat)); Y:Nat --> s(s(s(#11:Nat)))

Solution 266
X:Bool --> s(s(s(s(s(#11:Nat + #21:Nat)))))<= s(s(s(#21:Nat))); X:Nat --> s(s(
    #11:Nat)); Y:Nat --> s(s(s(#21:Nat)))

Solution 267
X:Bool --> s(s(s(s(s(#11:Nat + #21:Nat)))))<= s(s(s(s(#21:Nat)))); X:Nat --> s(
    #11:Nat); Y:Nat --> s(s(s(s(#21:Nat))))

Solution 268
X:Bool --> s(s(s(s(s(#16:Nat + #21:Nat)))))<= s(#16:Nat); X:Nat --> s(s(s(s(
    #21:Nat)))); Y:Nat --> s(#16:Nat)

Solution 269
X:Bool --> s(s(s(s(s(#16:Nat + #21:Nat)))))<= s(#21:Nat); X:Nat --> s(s(s(s(
    #16:Nat)))); Y:Nat --> s(#21:Nat)

Solution 270
X:Bool --> s(s(s(s(s(#16:Nat + #21:Nat)))))<= s(s(#16:Nat)); X:Nat --> s(s(s(
    #21:Nat))); Y:Nat --> s(s(#16:Nat))

Solution 271
X:Bool --> s(s(s(s(s(#16:Nat + #21:Nat)))))<= s(s(#21:Nat)); X:Nat --> s(s(s(
    #16:Nat))); Y:Nat --> s(s(#21:Nat))

Solution 272
X:Bool --> s(s(s(s(s(#16:Nat + #21:Nat)))))<= s(s(s(#16:Nat))); X:Nat --> s(s(
    #21:Nat)); Y:Nat --> s(s(s(#16:Nat)))

Solution 273
X:Bool --> s(s(s(s(s(#16:Nat + #21:Nat)))))<= s(s(s(#21:Nat))); X:Nat --> s(s(
    #16:Nat)); Y:Nat --> s(s(s(#21:Nat)))

Solution 274
X:Bool --> s(s(s(s(s(#16:Nat + #21:Nat)))))<= s(s(s(s(#16:Nat)))); X:Nat --> s(
    #21:Nat); Y:Nat --> s(s(s(s(#16:Nat))))

Solution 275
X:Bool --> s(s(s(s(s(#16:Nat + #21:Nat)))))<= s(s(s(s(#21:Nat)))); X:Nat --> s(
    #16:Nat); Y:Nat --> s(s(s(s(#21:Nat))))

Solution 276
X:Bool --> s(s(s(s(s(#1:Nat + #21:Nat)))))<= s(#1:Nat); X:Nat --> s(s(s(s(
    #21:Nat)))); Y:Nat --> s(#1:Nat)

Solution 277
X:Bool --> s(s(s(s(s(#1:Nat + #21:Nat)))))<= s(s(s(s(#21:Nat)))); X:Nat --> s(
    #1:Nat); Y:Nat --> s(s(s(s(#21:Nat))))

Solution 278
X:Bool --> s(s(s(s(s(#6:Nat + #21:Nat)))))<= s(#6:Nat); X:Nat --> s(s(s(s(
    #21:Nat)))); Y:Nat --> s(#6:Nat)

Solution 279
X:Bool --> s(s(s(s(s(#6:Nat + #21:Nat)))))<= s(s(#6:Nat)); X:Nat --> s(s(s(
    #21:Nat))); Y:Nat --> s(s(#6:Nat))

Solution 280
X:Bool --> s(s(s(s(s(#6:Nat + #21:Nat)))))<= s(s(s(#21:Nat))); X:Nat --> s(s(
    #6:Nat)); Y:Nat --> s(s(s(#21:Nat)))

Solution 281
X:Bool --> s(s(s(s(s(#6:Nat + #21:Nat)))))<= s(s(s(s(#21:Nat)))); X:Nat --> s(
    #6:Nat); Y:Nat --> s(s(s(s(#21:Nat))))

Solution 282
X:Bool --> s(s(s(s(s(X:Nat + #21:Nat)))))<= s(s(s(s(s(#21:Nat))))); Y:Nat -->
    s(s(s(s(s(#21:Nat)))))

Solution 283
X:Bool --> s(s(s(s(s(Y:Nat + #21:Nat)))))<= Y:Nat ; X:Nat --> s(s(s(s(s(
    #21:Nat)))))

No more solutions.

search [,5] in TEST-PLUS-LEQ :(X:Nat + Y:Nat)<= Y:Nat ~>! X:Bool .

Solution 1
X:Bool --> false ; X:Nat --> s(#11:Nat); Y:Nat --> s(0)

Solution 2
X:Bool --> false ; X:Nat --> s(#13:Nat); Y:Nat --> s(0)

Solution 3
X:Bool --> false ; X:Nat --> s(#14:Nat); Y:Nat --> s(0)

Solution 4
X:Bool --> false ; X:Nat --> s(#1:Nat); Y:Nat --> 0

Solution 5
X:Bool --> false ; X:Nat --> s(#1:Nat); Y:Nat --> s(0)

Solution 6
X:Bool --> false ; X:Nat --> s(#4:Nat); Y:Nat --> 0

Solution 7
X:Bool --> false ; X:Nat --> s(#6:Nat); Y:Nat --> s(0)

Solution 8
X:Bool --> false ; X:Nat --> s(0); Y:Nat --> 0

Solution 9
X:Bool --> false ; X:Nat --> s(0); Y:Nat --> s(0)

Solution 10
X:Bool --> false ; X:Nat --> s(s(#11:Nat)); Y:Nat --> s(0)

Solution 11
X:Bool --> false ; X:Nat --> s(s(#6:Nat)); Y:Nat --> 0

Solution 12
X:Bool --> false ; X:Nat --> s(s(#6:Nat)); Y:Nat --> s(0)

Solution 13
X:Bool --> false ; X:Nat --> s(s(0)); Y:Nat --> 0

Solution 14
X:Bool --> false ; X:Nat --> s(s(s(#11:Nat))); Y:Nat --> 0

Solution 15
X:Bool --> true ; X:Nat --> 0 ; Y:Nat --> 0

Solution 16
X:Bool --> true ; X:Nat --> 0 ; Y:Nat --> s(0)

Solution 17
X:Bool --> true ; X:Nat --> 0 ; Y:Nat --> s(s(0))

No more solutions.

Introduced module VENDING-MACHINE

mod VENDING-MACHINE is
  including BOOL .
  sorts Coffee Coin Cookie Item State .
  subsort Coffee < Item .
  subsort Coin < State .
  subsort Cookie < Item .
  subsort Item < State .
  op $ : -> Coin .
  op a : -> Cookie .
  op c : -> Coffee .
  op null : -> State .
  op q : -> Coin .
  op __ : State State -> State
    [assoc comm] .
  rl St:State $
    => St:State c .
  rl St:State $
    => St:State a q .
  rl St:State null
    => St:State null $ .
  rl St:State null
    => St:State null q .
  rl St:State q q q q
    => St:State $ .
  rl null St:State
    => if St:State == c then null a else null St:State fi .
endm

Introduced module TEST-APPEND

mod TEST-APPEND is
  including BOOL .
  sorts Nat NatList NatOrClash .
  subsort Nat < NatOrClash .
  op 0 : -> Nat .
  op _:_ : Nat NatList -> NatList .
  op _=:=_>>_ : NatList NatList Nat -> NatOrClash .
  op append : NatList NatList -> NatList .
  op clash : -> NatOrClash .
  op last : NatList -> NatOrClash .
  op nil : -> NatList .
  op s : Nat -> Nat .
  rl nil =:= nil >> X:Nat
    => X:Nat .
  rl nil =:= N:Nat : XS:NatList >> X:Nat
    => clash .
  rl (N:Nat : XS:NatList)=:= nil >> X:Nat
    => clash .
  rl (N:Nat : XS:NatList)=:= N:Nat : YS:NatList >> X:Nat
    => XS:NatList =:= YS:NatList >> X:Nat .
  rl append(nil,YS:NatList)
    => YS:NatList .
  rl append(N:Nat : XS:NatList,YS:NatList)
    => N:Nat : append(XS:NatList,YS:NatList) .
  rl last(XS:NatList)
    => append(YS:NatList,N:Nat : nil)=:= XS:NatList >> N:Nat [nonexec] .
endm

set include BOOL off

set include TRUTH-VALUE on

Introduced module MBOOL

Advisory: Module NAT redefined.
Introduced module NAT

Introduced module INT

Introduced theory NAT*

Introduced module NAT/

Introduced module DINING-PHILS

Introduced view 5

frewrite in DINING-PHILS{5}:
  initState(s s s s 0 * s s s s s 0)
result Configuration :
  < bowl : Bowl | amount : 0 > <[0]: Philosopher | lunches : s s s s s s s s s
    s s s s s s s s s s s 0,state : thinking,sticks : 0 > <[s 0]: Philosopher |
    lunches : 0,state : hungry,sticks : s s 0 > <[s s 0]: Philosopher | lunches
    : 0,state : hungry,sticks : s 0 > <[s s s 0]: Philosopher | lunches : 0,
    state : hungry,sticks : s 0 > <[s s s s 0]: Philosopher | lunches : 0,state
    : hungry,sticks : s 0 >

    DEADLOCK-FREE mod. expr. available Oct. 28th 2008

reduce in GEN-TREE-TEST :
  elts(1[(3[(4[none]),none]),(2[none]),none])
result Set{Int} :
  1 2 3 4

reduce in GEN-TREE-TEST :
  sameShape(1[(3[(4[none]),none]),(2[none]),none],4[(2[(1[none]),none]),(3[
    none]),none])
result MBool :
  (true).MBool

Advisory: redefining module FOO.
    DEADLOCK-FREE mod. expr. available Oct. 28th 2008

reduce in MLIST{String}:
  "one" "two" "three"
result List{String} :
  "one" "two" "three"

reduce in MLIST{Foo}:
  f g h
result List{Foo} :
  f g h


Maude> 